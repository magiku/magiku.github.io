<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【生成树协议】STP、RSTP | Magiku's药剂屋</title><meta name="author" content="Magiku"><meta name="copyright" content="Magiku"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本篇主要是介绍防止环路的协议——生成树协议，STP是最原始的生成树协议，而RSTP是改进后的生成树协议。">
<meta property="og:type" content="article">
<meta property="og:title" content="【生成树协议】STP、RSTP">
<meta property="og:url" content="https://magiku.github.io/2024/01/03/%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AE%E4%B9%8BSTP%E4%B8%8ERSTP/index.html">
<meta property="og:site_name" content="Magiku&#39;s药剂屋">
<meta property="og:description" content="本篇主要是介绍防止环路的协议——生成树协议，STP是最原始的生成树协议，而RSTP是改进后的生成树协议。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://c4893f9d.telegraph-image-713.pages.dev/file/dcb11262f483239ffc471.png">
<meta property="article:published_time" content="2024-01-03T08:00:00.000Z">
<meta property="article:modified_time" content="2024-01-03T08:00:00.000Z">
<meta property="article:author" content="Magiku">
<meta property="article:tag" content="网络">
<meta property="article:tag" content="STP">
<meta property="article:tag" content="RSTP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://c4893f9d.telegraph-image-713.pages.dev/file/dcb11262f483239ffc471.png"><link rel="shortcut icon" href="https://telegraph-image-713.pages.dev/file/35fde8abe3ef661685f2b.png"><link rel="canonical" href="https://magiku.github.io/2024/01/03/%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AE%E4%B9%8BSTP%E4%B8%8ERSTP/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【生成树协议】STP、RSTP',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-03 16:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.8/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/dcb11262f483239ffc471.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Magiku's药剂屋"><span class="site-name">Magiku's药剂屋</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【生成树协议】STP、RSTP</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-03T08:00:00.000Z" title="发表于 2024-01-03 16:00:00">2024-01-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-03T08:00:00.000Z" title="更新于 2024-01-03 16:00:00">2024-01-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【生成树协议】STP、RSTP"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="STP（生成树协议）"><a href="#STP（生成树协议）" class="headerlink" title="STP（生成树协议）"></a>STP（生成树协议）</h1><p>以太网交换网络中为了进行链路备份，提高网络可靠性，通常会使用冗余链路。</p>
<p>但是使用冗余链路会在交换网络上产生环路，引发广播风暴以及MAC地址表不稳定等故障现象，从而导致用户通信质量较差，甚至通信中断。</p>
<p>为解决交换网络中的环路问题，提出了生成树协议STP（Spanning Tree Protocol）。</p>
<p><strong>运行STP协议的设备通过彼此交互信息发现网络中的环路，并有选择的对某个接口进行阻塞，最终将环形网络结构修剪成无环路的树形网络结构。</strong></p>
<blockquote>
<p>对于聚合的链路，其在实际作用中已经成为单条链路了，所以STP并不感知，也就不会阻塞管控。</p>
</blockquote>
<p>STP是一个成熟的自动化协议，在交换设备上开启STP功能（<strong>stp enable</strong>）即可做到防止环路，无需再做任何配置。</p>
<p>甚至对于大部分可stp的设备来说，都<strong>默认开启了stp功能的</strong>。因此我们的目标是学习STP是如何实现防环的。</p>
<blockquote>
<p>也还是有一些可配置的东西的，主要是用来修改什么链路被阻塞。不修改也没关系，只是链路不是最优的而已，并不影响通信。</p>
</blockquote>
<h2 id="STP的基础概念"><a href="#STP的基础概念" class="headerlink" title="STP的基础概念"></a>STP的基础概念</h2><p>在此之前，我们需要先理解几个概念。</p>
<p>请先全部看完，不要就某一点死磕，要合在一起才能理解透。</p>
<h3 id="BPDU（Bridge-Protocol-Data-Unit）"><a href="#BPDU（Bridge-Protocol-Data-Unit）" class="headerlink" title="BPDU（Bridge Protocol Data Unit）"></a>BPDU（Bridge Protocol Data Unit）</h3><p>STP协议中的数据单元，用于在网络中传递信息并计算最佳路径。(类似于vlan技术的vlan标签那种作用，不过BPDU是一个完整的数据包)</p>
<p>BPDU包含以下重要信息：</p>
<ol>
<li>源MAC地址：BPDU的发送者的MAC地址。</li>
<li>目的MAC地址：BPDU的接收者的MAC地址。</li>
<li>源优先级（Priority）：用于确定根桥（Root Bridge）的优先级。</li>
<li>源根标识（Root Identifier）：用于标识根桥的MAC地址和优先级。</li>
<li>发送端口标识（Port Identifier）：用于标识发送BPDU的端口。</li>
<li>路径开销（Path Cost）：用于计算到达根桥的路径开销。</li>
<li>BPDU类型：用于标识BPDU的类型，一共有两种：<em>配置BPDU</em> 、<em>拓扑更改通知BPDU</em>。</li>
</ol>
<p><strong>STP通过在网络中传递BPDU来建立一个拓扑树，选择一个根桥，并禁用一些端口以防止环路。</strong></p>
<p>设备通过<em>配置BPDU</em>比较优先级、根标识、路径开销等信息来确定最佳路径，并选择根桥。</p>
<p><strong>当网络中发生拓扑变化时，如链路故障或端口状态改变，STP会生成并发送<em>拓扑更改通知BPDU</em>，通知其他设备进行拓扑重计算。</strong></p>
<p>这样，网络中的所有设备都能保持一个无环的拓扑结构，确保数据包的正常传输。</p>
<blockquote>
<p>BPDU是通过组播的方式进行转发的，其组播地址为 <code>01:80:C2:00:00:00</code>。</p>
</blockquote>
<h3 id="根桥（Root-Bridge）"><a href="#根桥（Root-Bridge）" class="headerlink" title="根桥（Root Bridge）"></a>根桥（Root Bridge）</h3><p>树形的网络结构必须有树根，于是STP引入了根桥的概念。根桥是在使用STP协议的网络中，被选为拓扑树根节点的交换机。</p>
<p>对于一个STP网络，根桥在全网中只有一个，它是整个网络的逻辑中心，但不一定是物理中心。</p>
<p><strong>根桥是网络中所有交换机的参考点，用于计算最佳路径和防止环路。</strong></p>
<p>根桥会根据网络拓扑的变化而动态变化。根桥的选择是通过比较交换机的优先级（Priority）来确定的。</p>
<p><strong>每个交换机都有一个默认的优先级值，通常是32768。优先级值越低，交换机被选为根桥的概率越大。</strong></p>
<p>如果优先级相同，则比较交换机的MAC地址，MAC地址较小的交换机将成为根桥。</p>
<blockquote>
<p>具体来说，是通过比较***BID (Bridge ID)**<em>来确定根桥的，其值为</em>优先级 + mac地址*。</p>
<p>一般都不会修改设备的mac地址，所以人为的修改根桥是通过修改优先级（默认32768的那个）来实现的。</p>
</blockquote>
<p>根桥的作用是：</p>
<ol>
<li><p><strong>确定最佳路径</strong>：根桥作为拓扑树的根节点，它决定了数据包在网络中的传输路径。其他交换机通过比较路径开销（Path Cost）选择到达根桥的最佳路径。路径开销是通过每个链路的速度来计算的，速度越快，路径开销越低，被选为最佳路径的概率越大。</p>
</li>
<li><p><strong>防止环路</strong>：根桥通过发送BPDU（Bridge Protocol Data Unit）来通知其他交换机网络的拓扑结构。交换机根据接收到的BPDU信息进行拓扑计算，并禁用一些端口以防止环路的发生。这样，根桥确保网络中没有冗余的链路，避免了数据包在网络中无限循环的问题。</p>
</li>
</ol>
<p>根桥是STP协议中的一个重要概念，它的选择对网络的性能和稳定性有着重要影响。</p>
<p>在一个网络中，只有一个交换机能够成为根桥，其他交换机都将根据根桥的信息进行拓扑计算和路径选择。</p>
<h3 id="路径开销（Path-Cost）"><a href="#路径开销（Path-Cost）" class="headerlink" title="路径开销（Path Cost）"></a>路径开销（Path Cost）</h3><p>STP中的路径开销（Path Cost）是用于计算到达根桥的路径代价的指标（类似于耗时、延迟）。</p>
<p><strong>路径开销是基于链路的速度来计算的，速度越快，路径开销越低，被选为最佳路径的概率越大。</strong></p>
<p>在STP中，每个链路都有一个默认的路径开销值，这个值根据链路的速度来确定。</p>
<blockquote>
<p>以下是两种标准下链路速度和对应的默认路径开销值：</p>
<table>
<thead>
<tr>
<th>链路速度</th>
<th>IEEE 802.1D-1998</th>
<th>IEEE 802.1T</th>
</tr>
</thead>
<tbody><tr>
<td>10 Mbps</td>
<td>100</td>
<td>200000</td>
</tr>
<tr>
<td>100 Mbps</td>
<td>19</td>
<td>20000</td>
</tr>
<tr>
<td>1 Gbps</td>
<td>4</td>
<td>2000</td>
</tr>
<tr>
<td>10 Gbps</td>
<td>2</td>
<td>200</td>
</tr>
</tbody></table>
<p>不同厂商的设备默认使用的标准可能不同，但可进行切换。华为还有一个自己私有的计算方式，不过还好默认的是IEEE 802.1T。</p>
</blockquote>
<p>路径开销的计算是通过将链路上的路径开销值相加来完成的。</p>
<p><strong>当STP计算最佳路径时，会比较到达根桥的不同路径的路径开销。</strong></p>
<p><strong>路径开销较小的路径（也就是速度最快的路径）将被选为最佳路径，数据包将通过该路径传输</strong>。</p>
<p>选择最佳路径，是为了确保数据包在网络中的传输效率和稳定性，这样可以避免数据包在网络中出现拥塞或延迟的问题。</p>
<p>路径开销是STP协议中的一个重要概念，它与拓扑计算密切相关，确保网络中的数据包能够以最佳路径传输，同时避免环路的发生。</p>
<h3 id="根端口（Root-Port）和指定端口（Designated-Port）"><a href="#根端口（Root-Port）和指定端口（Designated-Port）" class="headerlink" title="根端口（Root Port）和指定端口（Designated Port）"></a>根端口（Root Port）和指定端口（Designated Port）</h3><p>在STP中，根端口和指定端口是两种不同类型的端口，用于建立拓扑树并选择最佳路径。</p>
<ol>
<li><p>根端口（Root Port）：根端口是指每个非根桥上与根桥相连的端口，根端口负责与根桥进行通信。每个非根桥都会选择一个且仅一个根端口，<strong>该端口提供了到达根桥的最佳路径。</strong></p>
</li>
<li><p>指定端口（Designated Port）：指定端口是指在<strong>每个链路上被选为传输BPDU的端口。</strong>指定端口是从每个交换机上与相邻交换机连接的端口中选择出的。</p>
</li>
</ol>
<p><strong>根端口和指定端口的选择是通过STP协议中的BPDU交换来完成的。交换机通过比较BPDU中的路径开销和优先级等信息，选择最佳的根端口和指定端口，以确保数据包在网络中的传输路径是无环且最优的。</strong></p>
<p>根端口和指定端口是STP协议中的关键概念，它们的选择和配置对于网络的性能和稳定性非常重要。通过选择最佳的根端口和指定端口，STP协议能够建立一个无环的拓扑树，并提供最佳的数据包传输路径。</p>
<p><strong>可以简单理解不是根端口的都为指定端口，而如果一条链路两端都是指定端口(环路)，那么其中一个必须成为阻塞端口，根据优先级阻塞其中一个。</strong></p>
<blockquote>
<p>请记住，<strong>STP的核心是消除环路</strong>，其次才是确定最佳路径。</p>
<p><strong>根端口是用来接收根桥发来的BPDU，指定端口是用来转发BPDU给其他交换机。</strong></p>
<p>优先级不只是开销，因为存在开销一样的情况，后面会具体学习优先级的相关内容。</p>
</blockquote>
<h2 id="STP原理"><a href="#STP原理" class="headerlink" title="STP原理"></a>STP原理</h2><h3 id="启用到稳定阶段"><a href="#启用到稳定阶段" class="headerlink" title="启用到稳定阶段"></a>启用到稳定阶段</h3><p>先放一张最终图理解一下上面介绍的概念。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/ffd3db0ec56b34897011b.png" alt="图1——STP接口"></p>
<p>如图，交换1为根桥，链路都为同一速率，所以交换机2、交换机3与交换机1相连的接口都为根端口。</p>
<p>交换机4左侧的端口到达交换1的优先级最高选为根端口。</p>
<p>其他剩下的链路为指定端口，其中有两条链路，两侧都为指定端口，再判断哪个端口优先级高，将低的阻塞掉。</p>
<p>最后拓扑就被修剪为树状了，达到了避免环路的目的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/aed1e6d5a664d8697ec45.png" alt="图2——修剪为树状拓扑"></p>
<p>同时，被阻塞的链路在目前被选中的最佳路径链路断开时能够自动启用，成为新的最佳链路，完成链路冗余的目的。</p>
<p>达成这个过程，依靠的就是交换机之间发送的BPDU包，设备的接口从加入到稳定一共会经过以下5个阶段。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/184939c74fdba4c36aae2.png" alt="图3——STP接口状态"></p>
<table>
<thead>
<tr>
<th>端口状态</th>
<th>目的</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Disabled</td>
<td>端口不仅不处理BPDU报文，也不转发用户流量。</td>
<td>端口状态为Down。</td>
</tr>
<tr>
<td>Listening</td>
<td>确定端口角色，将选举出根桥、根端口和指定端口。不转发用户流量。</td>
<td>过渡状态，持续15秒。</td>
</tr>
<tr>
<td>Learning</td>
<td>设备会根据收到的用户流量构建MAC地址表，但不转发用户流量。</td>
<td>过渡状态，持续15秒。增加Learning状态防止临时环路。</td>
</tr>
<tr>
<td>Forwarding</td>
<td>端口既转发用户流量也处理BPDU报文。</td>
<td>只有根端口或指定端口才能进入Forwarding状态。</td>
</tr>
<tr>
<td>Blocking</td>
<td>端口仅仅接收并处理BPDU，不转发用户流量。</td>
<td>阻塞端口的最终状态。</td>
</tr>
</tbody></table>
<p><strong>网络中所有的设备启动STP协议后，每一台设备都认为自己是根桥。</strong></p>
<p>此时，每台设备仅仅收发<em>配置BPDU</em>，而不转发用户流量，所有的端口都处于Listening状态。</p>
<p>所有设备通过交换<em>配置BPDU后</em>，进行选举工作，选出根桥、根端口和指定端口。</p>
<p>这就是STP的启动到稳定过程，这个过程常被称为“<strong>收敛</strong>”。</p>
<p><strong>该过程中用户流量无法传输，呈现为断网状态，一般收敛时间至少需要30秒</strong>（Listening状态与Learning状态的总耗时）。</p>
<blockquote>
<p>在稳定的状态下，发送链路变化时，也需要端口经过状态的切换，因此也需要至少30秒的时间。</p>
</blockquote>
<h3 id="稳定后的维护阶段"><a href="#稳定后的维护阶段" class="headerlink" title="稳定后的维护阶段"></a>稳定后的维护阶段</h3><p>一般STP稳定之后，根桥会周期性的发布BPDU以维护STP状态（默认2秒一次），其他设备只接收并转发该BPDU。</p>
<p>网络中发生拓扑变化时，例如链路中断或接口异常Down等情况，由于MAC地址的老化时间的存在（老化是指“过期”，时间默认为5分钟，超过该时间未更新就会删除交换mac地址表内的该mac信息）。</p>
<p>如果不及时通知上游设备，则可能会导致上游设备的报文在这段时间内一直向一个不可达的链路发送。</p>
<p>这样就可能导致流量的丢失，此时就需要拓扑变化机制来将拓扑的变更及时通知到整个STP网络。</p>
<blockquote>
<p>使用ensp模拟器的话就可能会出现这个bug，链路变动后，交换机的mac地址表却未随着变动，导致通信失败。</p>
</blockquote>
<p>TCN BPDU（Topology Change Notification Bridge Protocol Data Unit，拓扑更改通知BPDU）是一种特殊类型的BPDU报文，用于通知网络中的其他设备发生了拓扑变化。</p>
<p><strong>当网络中的拓扑发生变化，比如链路故障或端口状态改变时，交换机会生成并发送TCN BPDU报文。</strong>TCN BPDU报文的目的是通知其他设备进行拓扑重计算，以便更新拓扑树并选择新的最佳路径，<strong>同时将MAC地址老化时间暂时改为15秒，适应拓扑变。</strong></p>
<p>TCN BPDU报文的发送和接收是STP协议中的重要机制，它确保网络中的所有设备能够及时感知到拓扑变化，并相应地调整拓扑树和路径选择，以保持网络的稳定性和高可用性。</p>
<p>TCN BPDU报文的触发过程：</p>
<ol>
<li><p>当交换设备的接口发生变更后，下游设备会不间断地向上游设备发送TCN BPDU报文。</p>
</li>
<li><p>上游设备收到下游设备发来的TCN BPDU报文后，只有指定端口处理TCN BPDU报文。其它端口也有可能收到TCN BPDU报文，但不会处理。（指定端口为最靠近根桥的端口）</p>
</li>
<li><p>上游设备会把<em>配置BPDU</em>报文中的Flags的TC位和TCA位同时置1，然后发送给下游设备，</p>
<p>TC位置1是为了通知下游设备直接删除桥MAC地址表项，TCA位置1是为了通知下游设备停止发送TCN BPDU报文。</p>
</li>
<li><p>上游设备复制一份TCN BPDU报文，向根桥方向发送。</p>
</li>
<li><p>重复步骤1、2、3、4，<strong>直到根桥收到TCN BPDU报文</strong>。</p>
</li>
</ol>
<blockquote>
<p>置位的TC标记的配置BPDU报文主要是上游设备用来告知下游设备拓扑发生变化，请下游设备直接删除桥MAC地址表项，从而达到快速收敛的目的。</p>
</blockquote>
<h3 id="选举优先级"><a href="#选举优先级" class="headerlink" title="选举优先级"></a>选举优先级</h3><h4 id="根桥的选举"><a href="#根桥的选举" class="headerlink" title="根桥的选举"></a>根桥的选举</h4><p>设备开启阶段，所有设备都会认为自己是根桥，在发送的配置BPDU中，将根桥项目填写为自己的mac。</p>
<p><strong>交换机之间彼此收发配置BPDU，比较收到的包中根桥优先级与自己优先级的差距。</strong></p>
<p>( <strong>选举根桥的BID＝优先级＋mac地址；默认优先级为32768，越小越优先。</strong>)</p>
<p>自身BID低，就不再主动发布根桥为自己的<em>配置BPDU</em>包了。</p>
<p>转而开始转发其认可为根桥的BPDU包，同时也填入了其到根桥的开销。例如：</p>
<blockquote>
<p>Root Identifier: 32768 &#x2F; 0 &#x2F; 4c:1f:cc:07:3f:df</p>
<p>Root Path Cost: 20000</p>
<p>Bridge Identifier: 32768 &#x2F; 0 &#x2F; 4c:1f:cc:16:72:7b</p>
</blockquote>
<p>第三行为交换机自己的BID。</p>
<p>最终，当只剩下一台设备在自发性的产生并发布BPDU，其他设备只转发该BPDU，根桥的选举也就结束了。</p>
<h4 id="根端口的选举"><a href="#根端口的选举" class="headerlink" title="根端口的选举"></a>根端口的选举</h4><p>根桥确定后，就开始选举根端口，根端口是到达根桥的最佳路径所在的接口。</p>
<p>优先级为：开销》对端BID（包括mac）》对端PID》本端PID</p>
<p>一个一个讲，请注意，现在是在选举<strong>一台交换机</strong>上的哪个端口为根端口。</p>
<h5 id="开销"><a href="#开销" class="headerlink" title="开销"></a>开销</h5><p><strong>收到的BPDU中，包含了Root Path Cost这一项表示到根桥的总开销，但这个BPDU是由上级交换机生成发送过来的，因此是上级交换机到根桥的开销。</strong></p>
<p><strong>所以要计算本端交换机端口到到根桥的开销，还得再加上与上级交换机所在链路的开销值。</strong></p>
<p>开销越小的越优先。</p>
<h5 id="对端BID"><a href="#对端BID" class="headerlink" title="对端BID"></a>对端BID</h5><p>当端口到根桥的开销值一样时，就开始比较对端设备的BID。（也就是比较收到的两个BPDU中的BID值）</p>
<p>哪个端口的上级交换机的BID更优先，就采用哪个端口作为根端口。</p>
<h5 id="对端PID"><a href="#对端PID" class="headerlink" title="对端PID"></a>对端PID</h5><p>如果对端都是同一个交换机，就开始比较PID（PID＝接口优先级+接口编号）。</p>
<p>接口优先级默认为128，而接口编号就是查看交换机接口信息时从上到下的顺序。（display interface brief ）</p>
<blockquote>
<p>PID也是BPDU包中的一个字段。</p>
</blockquote>
<h5 id="本端PID"><a href="#本端PID" class="headerlink" title="本端PID"></a>本端PID</h5><p>如果遇到了对端为同一接口，就比较自己这边的PID。（两台交换机之间串联了一个集线器就会出现这个情况。）</p>
<hr>
<blockquote>
<p>因此，请不要简单的认为与根桥连在一起的交换机，其直连链路就是根端口所在的链路。</p>
<p>如果该直连链路速率低（比如百兆），那么其开销值可能大于从其他交换机绕行的链路（比如千兆）。</p>
</blockquote>
<h4 id="指定端口-阻塞端口的选举"><a href="#指定端口-阻塞端口的选举" class="headerlink" title="指定端口&#x2F;阻塞端口的选举"></a>指定端口&#x2F;阻塞端口的选举</h4><p>对于一台交换机来说，确定完根端口后，其他接入在STP中的端口就都是指定端口了。</p>
<p><strong>但当两台非根桥交换机连在一起，且链路所在端口都不是根端口时，就必须选举出最优的一个作为指定，另一个阻塞。</strong></p>
<blockquote>
<p>STP本质是防止环路的技术，当链路两侧都不是根端口，说明该链路是环路。</p>
</blockquote>
<p>指定端口是用来转发根桥发来的BPDU的，因此要选出到根桥路径最佳的那一个。</p>
<p>所以第一个优先级就是比较端口到达根桥的开销。（其实就是交换机的根端口到根桥的开销，也就是BPDU包里的Root Path Cost）</p>
<p>当开销相同时，就比较设备的BID。（BID中包含了mac地址，因此不存在BID相同的情况）</p>
<h4 id="说白了，选举的就是为了传递最好的BPDU"><a href="#说白了，选举的就是为了传递最好的BPDU" class="headerlink" title="说白了，选举的就是为了传递最好的BPDU"></a>说白了，选举的就是为了传递最好的BPDU</h4><p>一是要求传递出的BPDU中的Root Path Cost（到根桥开销）为最小。</p>
<p>二是要求传递出的BPDU中BID与PID为优先级最高的。</p>
<h3 id="STP中的几个时间"><a href="#STP中的几个时间" class="headerlink" title="STP中的几个时间"></a>STP中的几个时间</h3><p> <span id="bpdu">先贴一个抓到的BPDU包的报文内容</span></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Spanning Tree Protocol</span><br><span class="line">    Protocol Identifier: Spanning Tree Protocol (0x0000)</span><br><span class="line">    Protocol Version Identifier: Spanning Tree (0)</span><br><span class="line">    BPDU Type: Configuration (0x00)</span><br><span class="line">    BPDU flags: 0x00</span><br><span class="line">        0... .... = Topology Change Acknowledgment: No</span><br><span class="line">        .... ...0 = Topology Change: No</span><br><span class="line">    Root Identifier: 32768 / 0 / 4c:1f:cc:58:6c:b7</span><br><span class="line">    Root Path Cost: 0</span><br><span class="line">    Bridge Identifier: 32768 / 0 / 4c:1f:cc:58:6c:b7</span><br><span class="line">    Port identifier: 0x8001</span><br><span class="line">    Message Age: 0</span><br><span class="line">    Max Age: 20</span><br><span class="line">    Hello Time: 2</span><br><span class="line">    Forward Delay: 15</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>时间</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Message Age</td>
<td>该BPDU包年龄值（以秒为单位）。默认每经过一个交换机，年龄就加1s。</td>
</tr>
<tr>
<td>Max Age</td>
<td>最大年龄值，默认为20s。收到的包Message Age大于20就丢弃该BPDU包。二是当接口持续20秒未收到BPDU，则认为上游设备已经出现故障，本设备会重新进行生成树计算。</td>
</tr>
<tr>
<td>hello time</td>
<td>2s。根桥定期发布<em>配置BPDU</em>的时间。</td>
</tr>
<tr>
<td>Forward Delay</td>
<td>状态迁移的延迟时间，默认15s。接口进入监听与学习状态各需要等待15秒，总计30秒。<br />也就是说30秒是端口状态发生变化直到稳定的最短时间。</td>
</tr>
<tr>
<td>Max Age + Forward Delay</td>
<td>50s。最坏情况下，拓扑发生变化后，先等待20s才开始重选举，选举又需要30s的时间收敛，一共50s，就是网络恢复正常所消耗的最短时间。</td>
</tr>
</tbody></table>
<blockquote>
<p>注：华为交换机不再使用Max Age 来决定端口角色变化需等待的超时时间。</p>
<p>目前，华为交换机STP&#x2F;RSTP 实现中，超时时间＝Hello Time × 3 × Timer Factor。</p>
<p>（若未设置Timer Factor的值，则超过时间是Hello Time的9倍。）</p>
</blockquote>
<h2 id="STP的配置"><a href="#STP的配置" class="headerlink" title="STP的配置"></a>STP的配置</h2><p>STP由于收敛需要30秒，故障响应也要20秒；不是很迅速，所以目前都采用的改进后的RSTP或MSTP。</p>
<p>因此，如果要体验与配置STP，需要先将STP模式修改为原始的STP。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>stp enable</strong></td>
<td>开启stp，默认就是开启状态。</td>
</tr>
<tr>
<td><strong>stp disable</strong></td>
<td>关闭stp。</td>
</tr>
<tr>
<td><strong>stp mode stp</strong></td>
<td>修改STP模式为STP</td>
</tr>
<tr>
<td><strong>stp priority</strong>  ？</td>
<td>修改设备的BID优先级，默认为32768。修改需要填写为4096的倍数。</td>
</tr>
<tr>
<td><strong>stp root primary</strong></td>
<td>配置当前设备为根桥设备。 等同于<strong>stp priority</strong>  0</td>
</tr>
<tr>
<td><strong>stp root secondary</strong></td>
<td>配置当前设备为备用根桥设备。 等同于<strong>stp priority</strong>  4096</td>
</tr>
<tr>
<td><strong>stp pathcost-standard</strong> ？</td>
<td>修改设备的开销计算标准。参数为<em>dot1d-1998</em>或<em>dot1t</em></td>
</tr>
<tr>
<td><strong>display stp</strong></td>
<td>查看生成树的状态信息与统计信息。带brief则显示接口主要信息。<br />也可以指定查看某一接口的信息。如：<strong>dis stp interface</strong> <em>GigabitEthernet 0&#x2F;0&#x2F;1</em></td>
</tr>
<tr>
<td>以下命令为接口视图下执行</td>
<td></td>
</tr>
<tr>
<td><strong>stp cost</strong> ？</td>
<td>修改当前端口的路径开销值。（填数值）</td>
</tr>
<tr>
<td><strong>stp port priority</strong> ？</td>
<td>修改端口的优先级，默认为128。</td>
</tr>
</tbody></table>
<blockquote>
<p>一般常用的也就设置主根桥与备用根桥。</p>
</blockquote>
<p>配置就不演示了，推荐自己打开ensp自己随便搭几个交换机跟多条链路，然后自己推算一下根桥、根端口、指定端口、阻塞端口是谁。</p>
<p>再思考一下如果要修改的话，需要使用什么命令（修改谁的BID优先级，修改哪个接口的开销或PID优先级）。</p>
<h1 id="RSTP"><a href="#RSTP" class="headerlink" title="RSTP"></a>RSTP</h1><h2 id="STP的不足之处"><a href="#STP的不足之处" class="headerlink" title="STP的不足之处"></a>STP的不足之处</h2><p>STP协议虽然能够解决环路问题，但是由于网络拓扑收敛慢，影响了用户通信质量。如果网络中的拓扑结构频繁变化，网络也会随之频繁失去连通性，从而导致用户通信频繁中断，这是用户无法忍受的。</p>
<p>STP的不足之处如下：</p>
<ul>
<li><p>STP没有细致区分端口状态和端口角色，不利于初学者学习及部署。</p>
<p>网络协议的优劣往往取决于协议是否对各种情况加以细致区分。</p>
<ul>
<li>从用户角度来讲，Listening、Learning和Blocking状态并没有区别，都同样不转发用户流量。</li>
<li>从使用和配置角度来讲，端口之间最本质的区别并不在于端口状态，而是在于端口扮演的角色。</li>
</ul>
</li>
<li><p>STP算法是被动的算法，依赖定时器等待的方式判断拓扑变化，收敛速度慢。</p>
</li>
<li><p>STP算法要求在稳定的拓扑中，根桥主动发出配置BPDU报文，而其他设备进行处理，传遍整个STP网络。这也是导致拓扑收敛慢的主要原因之一。</p>
</li>
</ul>
<blockquote>
<p>端口状态指Disabled、Listening、Learning、Forwarding、Blocking这五个。</p>
<p>端口角色指的是根端口、指定端口、阻塞端口这三个。</p>
</blockquote>
<h2 id="RSTP对STP的改进"><a href="#RSTP对STP的改进" class="headerlink" title="RSTP对STP的改进"></a>RSTP对STP的改进</h2><p>根据STP的不足，RSTP新增加了2种端口角色，删除了3种端口状态，并且把端口属性充分的按照状态和角色解耦。</p>
<p>此外，RSTP还增加了相应的一些增强特性和保护措施，实现网络的稳定和快速收敛。</p>
<h3 id="通过端口角色的增补，简化了生成树协议的理解及部署。"><a href="#通过端口角色的增补，简化了生成树协议的理解及部署。" class="headerlink" title="通过端口角色的增补，简化了生成树协议的理解及部署。"></a><strong>通过端口角色的增补，简化了生成树协议的理解及部署。</strong></h3><p>RSTP的端口角色共有4种：根端口、指定端口、Alternate端口（原STP中的阻塞端口）和Backup端口。</p>
<p>根端口和指定端口的作用同STP协议中定义，Alternate端口和Backup端口的描述如下：</p>
<ul>
<li><p>从配置BPDU报文发送角度来看：</p>
<ul>
<li>Alternate端口就是由于学习到其它网桥发送的配置BPDU报文而阻塞的端口。</li>
<li>Backup端口就是由于学习到自己发送的配置BPDU报文而阻塞的端口。</li>
</ul>
</li>
<li><p>从用户流量角度来看：</p>
<ul>
<li>Alternate端口作为根端口的备份端口，提供了从指定桥到根的另一条可切换路径。</li>
<li>Backup端口作为指定端口的备份，提供了另一条从根桥到相应网络的备份通路。</li>
</ul>
<p>给一个RSTP域内所有端口分配角色的过程就是整个拓扑收敛的过程。</p>
</li>
</ul>
<h3 id="端口状态的重新划分"><a href="#端口状态的重新划分" class="headerlink" title="端口状态的重新划分"></a><strong>端口状态的重新划分</strong></h3><p>RSTP的状态规范把原来的5种状态缩减为3种。根据端口是否转发用户流量和学习MAC地址来划分:</p>
<ul>
<li>如果不转发用户流量也不学习MAC地址，那么端口状态就是Discarding状态。</li>
<li>如果不转发用户流量但是学习MAC地址，那么端口状态就是Learning状态。</li>
<li>如果既转发用户流量又学习MAC地址，那么端口状态就是Forwarding状态。</li>
</ul>
<p>如表所示，新的端口状态与STP规定的端口状态比较。端口状态和端口角色是没有必然联系的，显示了各种端口角色能够具有的端口状态。</p>
<table>
<thead>
<tr>
<th>STP端口状态</th>
<th>RSTP端口状态</th>
<th>端口在拓扑中的角色</th>
</tr>
</thead>
<tbody><tr>
<td>Blocking</td>
<td>Discarding</td>
<td>包括Alternate端口、Backup端口</td>
</tr>
<tr>
<td>Disabled</td>
<td>Discarding</td>
<td>包括Disable端口</td>
</tr>
<tr>
<td>Listening</td>
<td>Discarding</td>
<td>包括根端口、指定端口</td>
</tr>
<tr>
<td>Learning</td>
<td>Learning</td>
<td>包括根端口、指定端口</td>
</tr>
<tr>
<td>Forwarding</td>
<td>Forwarding</td>
<td>包括根端口、指定端口</td>
</tr>
</tbody></table>
<h3 id="配置BPDU的处理发生变化"><a href="#配置BPDU的处理发生变化" class="headerlink" title="配置BPDU的处理发生变化"></a><strong><em>配置BPDU</em>的处理发生变化</strong></h3><ul>
<li><p>拓扑稳定后，<em>配置BPDU</em>报文的发送方式</p>
<p>在STP中，拓扑稳定后，根桥按照Hello Time规定的时间间隔发送配置BPDU。其他非根桥设备在收到上游设备发送过来的配置BPDU后，才会触发发出配置BPDU，此方式使得STP协议计算复杂且缓慢。</p>
<p>RSTP对此进行了改进，即在拓扑稳定后，无论非根桥设备是否接收到根桥传来的配置BPDU报文，非根桥设备仍然按照Hello Timer规定的时间间隔发送配置BPDU，该行为完全由每台设备自主进行。</p>
</li>
<li><p>更短的BPDU超时计时</p>
<p>如果一个端口在超时时间（超时时间＝Hello Time × 3 × Timer Factor）内没有收到上游设备发送过来的配置BPDU，那么该设备认为与此邻居之间的协商失败。而不像STP那样需要先等待一个Max Age。</p>
</li>
<li><p>处理次等BPDU</p>
<p>当一个端口收到上游的指定桥发来的BPDU报文时，该端口会将自身存储的BPDU与收到的BPDU进行比较。</p>
<p>如果该端口存储的BPDU的优先级高于收到的BPDU，那么该端口会直接丢弃收到的BPDU，立即回应自身存储的BPDU。</p>
<p>当上游设备收到下游设备回应的BPDU后，上游设备会根据收到的BPDU报文中相应的字段立即更新自己存储的BPDU。</p>
<p>由此，RSTP处理次等BPDU报文不再依赖于任何定时器通过超时解决拓扑收敛，从而加快了拓扑收敛。</p>
</li>
</ul>
<h3 id="快速收敛"><a href="#快速收敛" class="headerlink" title="快速收敛"></a><strong>快速收敛</strong></h3><ul>
<li><p><strong>Proposal&#x2F;Agreement机制</strong></p>
<p>当一个端口被选举成为指定端口之后，在STP中，该端口至少要等待一个Forward Delay（Learning）时间才会迁移到Forwarding状态。</p>
<p>而在RSTP中，此端口会先进入Discarding状态，再通过Proposal&#x2F;Agreement机制快速进入Forward状态。这种机制必须在点到点全双工链路上使用。</p>
<p>Proposal&#x2F;Agreement机制简称P&#x2F;A机制，详细描述稍后介绍。</p>
</li>
<li><p><strong>端口快速切换机制</strong></p>
<p>如果RSTP网络中，一台交换机的根端口失效，那么该交换机最优的Alternate端口将成为根端口并直接进入Forwarding状态。</p>
<p>因为通过这个Alternate端口连接的链路上必然有个指定端口可以通往根桥。</p>
<p>阻塞端口也是周期性的接收到BPDU包才能保持的，因此必定是到根桥链路为通的状态。</p>
</li>
<li><p>STP模式时，阻塞端口切换成根端口后，要等待一个Forward Delay时间（缺省值为15秒）进入Learning状态，再继续等待一个Forward Delay时间才进入Forwarding状态。</p>
<ul>
<li>RSTP模式时，阻塞端口切换成根端口后，直接进入Forwarding状态。</li>
</ul>
<p>相比较STP模式时接口需要等待2*Forward Delay时间才能进入Forwarding状态，RSTP模式时的根端口快速切换机制使接口直接切换成Forwarding状态，减少业务流量丢包。</p>
<p>同样的，如果指定端口失效，该交换机最优的Backup端口将成为指定端口并直接进入Forwarding状态</p>
</li>
</ul>
<blockquote>
<p>此处指的都是同一台交换机存在阻塞端口的情况。</p>
</blockquote>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>RSTP作为一个独立于STP的新协议，其报文自然也会有所改动，马上就会开始介绍。</p>
<p>STP如果抛开时间问题，其已经是非常完美的防环协议了。但作为早期协议，并没有考虑到安全问题，恶意者可以利用BPDU的优先级选举机制来搞破坏，通过伪装BPDU报文，发送给交换设备，以引起通信的异常中断。</p>
<p>为此，RSTP就加入了许多安全保护机制。（也是稍后介绍）</p>
<h2 id="RST-BPDU"><a href="#RST-BPDU" class="headerlink" title="RST BPDU"></a>RST BPDU</h2><p>在配置BPDU报文的格式上，除了保证和STP格式基本一致之外，RSTP作了一些小变化：</p>
<ul>
<li>Type字段，配置BPDU类型不再是0而是2，所以运行STP的设备收到RSTP的配置BPDU时会丢弃。</li>
<li>Flags字段，使用了原来保留的中间6位，这样改变的配置BPDU叫做RST BPDU。</li>
</ul>
<p>下表为一个RSTP协议的BDPU报文中的内容。可以与前面摘抄的<a href="#bpdu">STP的BPDU</a>比对。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Spanning Tree Protocol</span><br><span class="line">    Protocol Identifier: Spanning Tree Protocol (0x0000)</span><br><span class="line">    Protocol Version Identifier: Rapid Spanning Tree (2)</span><br><span class="line">    BPDU Type: Rapid/Multiple Spanning Tree (0x02)</span><br><span class="line">    BPDU flags: 0x7c, Agreement, Forwarding, Learning, Port Role: Designated</span><br><span class="line">        0... .... = Topology Change Acknowledgment: No</span><br><span class="line">        .1.. .... = Agreement: Yes</span><br><span class="line">        ..1. .... = Forwarding: Yes</span><br><span class="line">        ...1 .... = Learning: Yes</span><br><span class="line">        .... 11.. = Port Role: Designated (3)</span><br><span class="line">        .... ..0. = Proposal: No</span><br><span class="line">        .... ...0 = Topology Change: No</span><br><span class="line">    Root Identifier: 32768 / 0 / 4c:1f:cc:4b:6f:48</span><br><span class="line">    Root Path Cost: 0</span><br><span class="line">    Bridge Identifier: 32768 / 0 / 4c:1f:cc:4b:6f:48</span><br><span class="line">    Port identifier: 0x8001</span><br><span class="line">    Message Age: 0</span><br><span class="line">    Max Age: 20</span><br><span class="line">    Hello Time: 2</span><br><span class="line">    Forward Delay: 15</span><br><span class="line">    Version 1 Length: 0</span><br></pre></td></tr></table></figure>

<p>其中，flags字段的信息如下：</p>
<ul>
<li>Topology Change Acknowledgment: No - 该标志位表示没有收到拓扑变化的确认。</li>
<li>Agreement: Yes - 该标志位表示该端口与对应的邻居端口达成了一致，表示两个端口的状态相互匹配。</li>
<li>Forwarding: Yes - 该标志位表示该端口处于转发状态，可以接收和转发数据帧。</li>
<li>Learning: Yes - 该标志位表示该端口处于学习状态，可以接收数据帧并将源 MAC 地址添加到 MAC 地址表中。</li>
<li>Port Role: Designated (3) - 该标志位表示端口角色为 Designated，即指定端口。其他字节对应的端口如下：<ul>
<li>00 Unknown</li>
<li>01 Alternate&#x2F;Backup port</li>
<li>10 Root port</li>
<li>11 Designated port</li>
</ul>
</li>
<li>Proposal: No - 该标志位表示没有发送 RSTP 配置 BPDU 的提议。</li>
<li>Topology Change: No - 该标志位表示没有网络拓扑变化。</li>
</ul>
<blockquote>
<p>这种BPDU称为RST BPDU，以区分普通STP的BPDU。 从现在开始，本文后续关于RSTP的BPDU包都会称为RST BPDU。</p>
</blockquote>
<h2 id="Proposal-Agreement机制"><a href="#Proposal-Agreement机制" class="headerlink" title="Proposal&#x2F;Agreement机制"></a>Proposal&#x2F;Agreement机制</h2><p>在STP中，端口需要等待Forward Delay时间才迁移到Forwarding状态，其目的是为了避免环路，等待一定的时间，以保证所有设备都确定好了端口角色。</p>
<p>在RSTP中，当一个端口被选为根端口和指定端口后，其进入转发状态的延时将大大缩短，从Discarding尽快进入Forwarding状态。</p>
<p>指定端口的端口状态快速迁移的条件是：</p>
<ul>
<li>如果指定端口是边缘端口，则指定端口可以直接进入转发状态。（边缘端口即该端口直接与用户终端相连，而没有连接到其他交换设备或共享网段上）</li>
<li>如果指定端口连接着点对点链路，则设备可以通过与下游设备握手，得到响应后即刻进入转发状态。该握手机制为Proposal&#x2F;Agreement机制</li>
</ul>
<p>根端口的端口状态快速迁移的条件是：</p>
<ul>
<li>本设备上旧的根端口已经停止转发数据，而且上游指定端口已经开始转发数据。</li>
</ul>
<blockquote>
<p>Proposal与Agreement的数值位于RST BPDU包的flags字段内（请看上一节贴出的flags字段内容）</p>
</blockquote>
<h3 id="Proposal-Agreement机制过程原理"><a href="#Proposal-Agreement机制过程原理" class="headerlink" title="Proposal&#x2F;Agreement机制过程原理"></a>Proposal&#x2F;Agreement机制过程原理</h3><p>Proposal&#x2F;Agreement机制，目前交换设备的端口支持以下两种方式：</p>
<ul>
<li>普通方式：当前端口在计算同步标志位时忽略根端口。<ol>
<li>上游设备发送Proposal报文，请求进行快速迁移，下游设备接收到后，把与上游设备相连的端口设置为根端口，并阻塞所有非边缘端口，根端口转为Forwarding状态。</li>
<li>下游设备回应Agreement报文，上游设备接收到后，把与下游设备相连的端口设置为指定端口，指定端口进入Forwarding状态。</li>
</ol>
</li>
<li>增强方式：当前端口在计算同步标志位时计算根端口。<ol>
<li>上游设备发送Proposal报文，请求进行快速迁移，下游设备接收到后，把与上游设备相连的端口设置为根端口，并阻塞所有非边缘端口。</li>
<li>上游设备<strong>继续发送Agreement报文</strong>，下游设备接收到后，根端口<strong>才</strong>转为Forwarding状态。</li>
<li>下游设备回应Agreement报文，上游设备接收到后，把与下游设备相连的端口设置为指定端口，指定端口进入Forwarding状态。</li>
</ol>
</li>
</ul>
<blockquote>
<p>在运行生成树的通信网络中，如果华为公司的数据通信设备与其他厂商设备混合组网，可能会因为与其他厂商设备的Proposal&#x2F;Agreement机制不同导致互通失败。</p>
<p>需要根据其他厂商设备的Proposal&#x2F;Agreement机制，选择端口使用增强的快速迁移机制还是普通的快速迁移机制。</p>
</blockquote>
<p>举个例子：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/388e125b1917fa60af952.png" alt="图4——P/A机制"></p>
<p>新链路连接成功后，P&#x2F;A机制协商过程如下：</p>
<ol>
<li>p0和p1两个端口马上都先成为指定端口，发送RST BPDU。</li>
<li>S2的p1口收到更优的RST BPDU，马上意识到自己将成为根端口，而不是指定端口，停止发送RST BPDU。</li>
<li>S1的p0进入Discarding状态，于是发送的RST BPDU中把Proposal和Agreement置1。</li>
<li>S2收到根桥发送来的携带Proposal的RST BPDU，开始将自己的所有端口进入sync变量置位——进入同步状态。</li>
<li>p2已经阻塞，状态不变；p4是边缘端口，不参与运算；所以只需要阻塞非边缘指定端口p3。</li>
<li>各端口同步后，p2、p3进入Discarding状态，p1进入Forwarding状态并向S1返回Agreement位置位的回应RST BPDU。</li>
<li>当S1判断出这是对刚刚发出的Proposal的回应，于是端口p0马上进入Forwarding状态。</li>
</ol>
<p>也就是在原来的基础上，进行了一次主动协商的过程，协商成功，就直接转入Forwarding状态，而不需要走原始的状态迁移。</p>
<p>这个协商过程中，为了防止其他的环路，会要求根端口以外的端口进入Discarding状态，让他们走原始的状态迁移；当然，如果有其他的设备与之进行P&#x2F;A机制协商，也会参与快速迁移。</p>
<h2 id="RSTP中的保护机制"><a href="#RSTP中的保护机制" class="headerlink" title="RSTP中的保护机制"></a>RSTP中的保护机制</h2><blockquote>
<p>所有保护功能默认都是未开启的。</p>
<p>一般来说，只会给根桥配置根保护，给边缘端口配置BPDU保护，其他的很少使用。</p>
</blockquote>
<h3 id="BPDU保护"><a href="#BPDU保护" class="headerlink" title="BPDU保护"></a>BPDU保护</h3><p>交换机上通常将直接与用户终端（如PC机）或文件服务器等非交换设备相连的端口配置为边缘端口。</p>
<p>正常情况下，边缘端口不会收到RST BPDU。</p>
<p>但如果有人伪造RST BPDU恶意攻击交换机，当边缘端口接收到RST BPDU时，交换机会自动将边缘端口设置为非边缘端口，并重新进行生成树计算。</p>
<p>当攻击者发送的RST BPDU报文中的桥优先级高于现有网络中根桥优先级时会改变当前网络拓扑，可能会导致业务流量中断。</p>
<p>这是网络中一种简单的拒绝服务DoS（Denial of Service）攻击方式。</p>
<p>交换机上启动了BPDU保护功能后，如果边缘端口收到RST BPDU，边缘端口将被error-down，但是边缘端口属性不变，同时通知网管系统。交换机上会打印如下日志信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSTP/4/BPDU_PROTECTION:This edged-port [port-name] that enabled BPDU-Protection will be shutdown, because it received BPDU packet!</span><br></pre></td></tr></table></figure>

<h4 id="操作步骤："><a href="#操作步骤：" class="headerlink" title="操作步骤："></a>操作步骤：</h4><ol>
<li><p>执行命令<strong>system-view</strong>，进入系统视图。</p>
</li>
<li><p>执行命令<strong>stp bpdu-protection</strong>，配置交换设备边缘端口的BPDU保护功能。</p>
<p>默认情况下，交换设备的BPDU保护功能处于禁用状态。</p>
</li>
</ol>
<h4 id="后续处理"><a href="#后续处理" class="headerlink" title="后续处理"></a>后续处理</h4><p>如果用户希望被error-down的边缘端口可自动恢复，可通过配置使能端口自动恢复功能，并设置延迟时间。</p>
<p>即在系统视图下执行命令<strong>error-down auto-recovery</strong> <strong>cause bpdu-protection</strong> <strong>interval</strong> <em>interval-value</em></p>
<p>启用端口自动恢复为Up的功能，并设置端口自动恢复为Up的延时时间。使被关闭的端口经过延时时间后能够自动恢复。</p>
<p>配置时需要注意：</p>
<ul>
<li>默认不启用该功能，所以没有默认的延迟时间值。当用户配置该命令时，必须指定恢复延迟时间（<em>interval-value</em>）。</li>
<li>取值越小表示端口的管理状态自动恢复为Up的延迟时间越短，端口Up&#x2F;Down状态震荡频率越高。</li>
<li>取值越大表示端口的管理状态自动恢复为Up的延迟时间越长，端口流量中断时间越长。</li>
<li>自动恢复仅对配置<strong>error-down auto-recovery</strong>命令之后发生error-down的端口有效，对配置此命令之前已经error-down的端口不生效。</li>
</ul>
<h3 id="根保护"><a href="#根保护" class="headerlink" title="根保护"></a>根保护</h3><p>由于维护人员的错误配置或网络中的恶意攻击，网络中合法根桥有可能会收到优先级更高的RST BPDU，使得合法根桥失去根地位，从而引起网络拓扑结构的错误变动。</p>
<p>这种不合法的拓扑变化，会导致原来应该通过高速链路的流量被牵引到低速链路上，造成网络拥塞。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/475ca2e6601d064b574fc.png" alt="图5——RSTP根保护"></p>
<p>如图所示，DeviceA和DeviceB处于网络核心层，两者间的链路带宽为1000M，其他链路带宽均为100M。DeviceA为网络中的根桥，DeviceC处于接入层。正常情况下，DeviceB和DeviceC之间的链路被阻塞。</p>
<p>当DeviceD新接入DeviceC时，如果DeviceD的桥优先级高于DeviceA，此时DeviceD会被选举为新的根桥，两个核心交换机DeviceA和DeviceB之间的千兆链路被阻塞，这会导致VLAN中的流量都通过两条100M链路传输，可能会引起网络拥塞及流量丢失。</p>
<p>此时可以在DeviceC连接DeviceD的端口上，配置根保护。<strong>对于启用Root保护功能的指定端口，其端口角色只能保持为指定端口。</strong></p>
<p>一旦启用Root保护功能的指定端口收到优先级更高的RST BPDU时，端口状态将进入Discarding状态，不再转发报文。</p>
<p>在经过一段时间（通常为两倍的Forward Delay），如果端口一直没有再收到优先级较高的RST BPDU，端口会自动恢复到正常的Forwarding状态。</p>
<h4 id="操作步骤：-1"><a href="#操作步骤：-1" class="headerlink" title="操作步骤："></a>操作步骤：</h4><ol>
<li><p>执行命令<strong>system-view</strong>，进入系统视图。</p>
</li>
<li><p>执行命令<strong>interface</strong> <em>interface-type interface-number</em>，进入参与生成树协议计算的接口视图。 </p>
</li>
<li><p>执行命令<strong>stp root-protection</strong>，配置交换设备的Root保护功能。</p>
<p>默认情况下，端口的Root保护功能处于去使能状态。当端口的角色是指定端口时，配置的Root保护功能才生效。配置了根保护的端口，不可以配置环路保护。</p>
</li>
</ol>
<h3 id="环路保护"><a href="#环路保护" class="headerlink" title="环路保护"></a>环路保护</h3><p>在运行RSTP协议的网络中，根端口和其他阻塞端口状态是依靠不断接收来自上游交换设备的RST BPDU维持。</p>
<p>当由于链路拥塞或者单向链路故障导致这些端口收不到来自上游交换设备的RST BPDU时，此时交换设备会重新选择根端口。</p>
<p>原先的根端口会转变为指定端口，而原先的阻塞端口会迁移到转发状态，从而造成交换网络中可能产生环路。</p>
<p>当链路发生拥塞时，由于根端口在超时时间内收不到来自上游设备的BPDU报文，Alternate端口放开转变成了根端口，根端口转变成指定端口，从而形成了环路。</p>
<p>在启动了环路保护功能后，如果根端口或Alternate端口长时间收不到来自上游设备的BPDU报文时，则向网管发出通知信息（此时根端口会进入Discarding状态，角色切换为指定端口），而Alternate端口则会一直保持在阻塞状态（角色也会切换为指定端口），不转发报文，从而不会在网络中形成环路。直到链路不再拥塞或单向链路故障恢复，端口重新收到BPDU报文进行协商，并恢复到链路拥塞或者单向链路故障前的角色和状态。</p>
<p>交换机上会打印如下日志信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSTP/4/LOOP_GUARD:MSTP process [process-id] Instance[instance-id]&#x27;s LOOP-Protection port [port-name] did not receive message in prescriptive time!</span><br></pre></td></tr></table></figure>

<blockquote>
<p>环路保护功能只能在根端口或Alternate端口上配置生效。</p>
</blockquote>
<h4 id="操作步骤：-2"><a href="#操作步骤：-2" class="headerlink" title="操作步骤："></a>操作步骤：</h4><ol>
<li><p>执行命令<strong>system-view</strong>，进入系统视图。</p>
</li>
<li><p>执行命令<strong>interface</strong> <em>interface-type interface-number</em>，进入参与生成树协议计算的接口视图。 </p>
</li>
<li><p>执行命令<strong>stp loop-protection</strong>，配置交换设备根端口或Alternate端口的环路保护功能。</p>
<p>默认情况下，端口的环路保护功能处于关闭状态。</p>
</li>
</ol>
<h3 id="防TC-BPDU攻击"><a href="#防TC-BPDU攻击" class="headerlink" title="防TC-BPDU攻击"></a>防TC-BPDU攻击</h3><p>交换设备在接收到TC BPDU报文后，会执行MAC地址表项和ARP表项的删除操作。</p>
<p>如果有人伪造TC BPDU报文恶意攻击交换设备时，交换设备短时间内会收到很多TC BPDU报文，频繁的删除操作会给设备造成很大的负担，给网络的稳定带来很大隐患。</p>
<p>启用防TC-BPDU报文攻击功能后，在单位时间内，交换设备处理TC BPDU报文的次数可配置。</p>
<p>如果在单位时间内，交换设备在收到TC BPDU报文数量大于配置的阈值，那么设备只会处理阈值指定的次数。</p>
<p>对于其他超出阈值的TC BPDU报文，定时器到期后设备只对其统一处理一次。</p>
<p>这样可以避免频繁的删除MAC地址表项和ARP表项，从而达到保护设备的目的。</p>
<h4 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h4><ol>
<li><p>执行命令<strong>system-view</strong>，进入系统视图。</p>
</li>
<li><p>执行命令<strong>stp tc-protection interval</strong> <em>interval-value</em>，配置设备处理阈值指定数量的拓扑变化报文所需的时间。</p>
<p>默认情况下，设备处理最大数量的拓扑变化报文所需的时间是Hello Time。</p>
</li>
<li><p>执行命令<strong>stp tc-protection threshold</strong> <em>threshold</em>，配置交换设备在收到TC类型BPDU报文后，单位时间内，处理TC类型BPDU报文并立即刷新转发表项的阈值。</p>
<p>默认情况下，设备在指定时间内处理拓扑变化报文的最大数量是1。</p>
<p>配置后，在<strong>stp tc-protection interval</strong>指定的时间内，设备只会处理<strong>stp tc-protection threshold</strong>指定数量的拓扑变化报文，对于其他的报文会延迟处理，所以可能会影响生成树的收敛速度。例如，时间设定为10秒，阈值设定为5，则设备收到拓扑变化报文后，在10秒内只会处理最开始收到的5个拓扑变化报文，对于后面收到的报文则会等10秒超时后再统一处理。</p>
</li>
</ol>
<h2 id="RSTP配置"><a href="#RSTP配置" class="headerlink" title="RSTP配置"></a>RSTP配置</h2><p>STP的配置命令在RSTP这边基本都能使用，所以不重复介绍。</p>
<blockquote>
<p>注意，华为交换机默认为MSTP，需要使用命令stp mode rstp切换为RSTP，后续命令介绍都是在RSTP模式下的。</p>
<p>保护功能的配置在上节介绍了，也不重复了。</p>
</blockquote>
<h3 id="边缘端口"><a href="#边缘端口" class="headerlink" title="边缘端口"></a>边缘端口</h3><p>在RSTP里面，如果某一个指定端口位于整个网络的边缘，即不再与其他交换设备连接，而是直接与终端设备（PC）直连，这种端口叫做边缘端口。</p>
<p>我们可以手动将满足条件的端口配置为边缘端口，边缘端口不参与RSTP运算，可以由Disable直接转到Forwarding状态，且不经历时延，就像在端口上将STP禁用。</p>
<p><strong>但是一旦边缘端口收到配置BPDU，就丧失了边缘端口属性，成为普通STP端口，并重新进行生成树计算，从而引起网络震荡。</strong></p>
<p>因此可以启用边缘端口的BPDU报文过滤功能，使边缘端口不处理、不发送BPDU报文。</p>
<p>不过启用过滤后，端口将不处理、不发送BPDU报文。该端口将无法成功与对端设备直连端口协商STP协议状态。</p>
<blockquote>
<p>除了启用过滤，也可以启用BPDU保护功能。</p>
</blockquote>
<h4 id="操作步骤：-3"><a href="#操作步骤：-3" class="headerlink" title="操作步骤："></a>操作步骤：</h4><p>在接口模式下配置边缘端口和BPDU报文过滤功能：</p>
<ol>
<li><p>执行命令<strong>system-view</strong>，进入系统视图。</p>
</li>
<li><p>执行命令<strong>interface</strong> <em>interface-type interface-number</em>，进入参与生成树协议计算的以太接口视图。</p>
</li>
<li><p>执行命令<strong>stp edged-port</strong> <strong>enable</strong>，将端口配置成边缘端口。</p>
<p>默认情况下，设备的所有端口为非边缘端口。</p>
</li>
<li><p>执行命令<strong>stp bpdu-filter</strong> <strong>enable</strong>，配置当前端口为BPDU filter端口，过滤所有BPDU报文。</p>
<p>默认情况下，设备的所有端口为非BPDU filter端口。</p>
</li>
</ol>
<h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><p>启用生成树协议后，默认启用边缘端口自动探测功能，当端口在（2 × Hello Timer + 1）秒的时间内收不到BPDU报文，会自动设置为边缘端口。</p>
<p>如果在接口视图下配置了<strong>stp edged-port enable</strong>或<strong>stp edged-port disable</strong>或者在系统视图下配置了<strong>stp edged-port default</strong>，边缘端口自动探测功能就不生效了。</p>
<blockquote>
<p>分别是配置为边缘端口，配置为非边缘端口，以及全局配置该设备上所有的接口为边缘端口</p>
</blockquote>
<h3 id="配置RSTP超时时间"><a href="#配置RSTP超时时间" class="headerlink" title="配置RSTP超时时间"></a>配置RSTP超时时间</h3><p>在运行生成树算法的网络中，如果设备在配置的超时时间内没有收到上游设备发送的BPDU，就认为上游设备已经出现故障，本设备会重新进行生成树计算。</p>
<p>由于上游设备繁忙，有时设备在较长的时间内收不到上游设备发送的BPDU。在这种情况下一般不应该重新进行生成树计算，因此，在稳定的网络中，可以配置超时时间，以减少网络资源的浪费。</p>
<p>如果设备在超时时间（超时时间＝Hello Time × 3 × Timer Factor）内没有收到上游设备发送的BPDU，则生成树会重新进行计算。</p>
<h4 id="操作步骤：-4"><a href="#操作步骤：-4" class="headerlink" title="操作步骤："></a>操作步骤：</h4><ol>
<li><p>执行命令<strong>system-view</strong>，进入系统视图。</p>
</li>
<li><p>执行命令<strong>stp timer-factor</strong> <em>factor</em>，配置未收到上游的BPDU就重新开始生成树计算的超时时间。</p>
<p>默认情况下，设备未收到上游的BPDU就重新开始生成树计算的超时时间是Hello Timer的9倍。</p>
</li>
</ol>
<h3 id="配置P-A机制的迁移方式"><a href="#配置P-A机制的迁移方式" class="headerlink" title="配置P&#x2F;A机制的迁移方式"></a>配置P&#x2F;A机制的迁移方式</h3><p>迁移方式分普通与增强，并不兼容；华为设备默认使用增强方式，如果与其他采用普通方式的交换机连接在一起，该链路中P&#x2F;A机制会失效。（但不会影响网络，只是失去了P&#x2F;A机制带来的快速状态迁移，转而走原始的状态迁移。）</p>
<h4 id="操作步骤：-5"><a href="#操作步骤：-5" class="headerlink" title="操作步骤："></a>操作步骤：</h4><ol>
<li><p>执行命令<strong>system-view</strong>，进入系统视图。</p>
</li>
<li><p>执行命令<strong>interface</strong> <em>interface-type interface-number</em>，进入参与生成树协议计算的接口视图。 </p>
</li>
<li><p>执行命令<strong>stp no-agreement-check</strong>，配置端口使用普通的快速迁移方式。</p>
<p>默认情况下，端口使用增强的快速迁移机制。</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://magiku.github.io">Magiku</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://magiku.github.io/2024/01/03/%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AE%E4%B9%8BSTP%E4%B8%8ERSTP/">https://magiku.github.io/2024/01/03/%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AE%E4%B9%8BSTP%E4%B8%8ERSTP/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，转载请注明出处！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C/">网络</a><a class="post-meta__tags" href="/tags/STP/">STP</a><a class="post-meta__tags" href="/tags/RSTP/">RSTP</a></div><div class="post_share"><div class="social-share" data-image="https://c4893f9d.telegraph-image-713.pages.dev/file/dcb11262f483239ffc471.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/11/%E6%96%87%E5%AD%97%E7%9A%84%E5%A4%B1%E7%9C%9F/" title="文字的失真——人际交往中的语言冲突"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">文字的失真——人际交往中的语言冲突</div></div></a></div><div class="next-post pull-right"><a href="/2023/12/22/%E4%BA%A4%E6%8D%A2%E4%B8%AD%E7%9A%84%E5%A4%9A%E9%93%BE%E8%B7%AF%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E7%8E%AF%E8%B7%AF%E3%80%81%E5%B9%BF%E6%92%AD%E9%A3%8E%E6%9A%B4%E3%80%81STP%E3%80%81%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88/" title="交换中的多链路问题——环路、广播风暴、链路聚合"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">交换中的多链路问题——环路、广播风暴、链路聚合</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/10/19/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/" title="【科普】计算机网络概述"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-19</div><div class="title">【科普】计算机网络概述</div></div></a></div><div><a href="/2023/12/11/%E3%80%90%E4%BA%A4%E6%8D%A2%E5%9F%BA%E7%A1%80%E3%80%91vlan%E3%80%81%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E3%80%81vlanif/" title="【交换基础】vlan、接口类型、vlanif"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-11</div><div class="title">【交换基础】vlan、接口类型、vlanif</div></div></a></div><div><a href="/2023/12/22/%E4%BA%A4%E6%8D%A2%E4%B8%AD%E7%9A%84%E5%A4%9A%E9%93%BE%E8%B7%AF%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E7%8E%AF%E8%B7%AF%E3%80%81%E5%B9%BF%E6%92%AD%E9%A3%8E%E6%9A%B4%E3%80%81STP%E3%80%81%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88/" title="交换中的多链路问题——环路、广播风暴、链路聚合"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-22</div><div class="title">交换中的多链路问题——环路、广播风暴、链路聚合</div></div></a></div><div><a href="/2024/06/04/%E3%80%90%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80%E3%80%91%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E3%80%81RIP%E5%8D%8F%E8%AE%AE/" title="【路由基础】静态路由、RIP协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-04</div><div class="title">【路由基础】静态路由、RIP协议</div></div></a></div><div><a href="/2024/06/28/%E3%80%90%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B11%E3%80%91ospf%E8%AF%A6%E8%A7%A3/" title="【动态路由1】ospf详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-28</div><div class="title">【动态路由1】ospf详解</div></div></a></div><div><a href="/2024/06/19/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%EF%BC%88%E8%BD%AF%E4%BB%B6%E5%90%91%EF%BC%89%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" title="【科普】（软件向）网络运维工具的介绍与使用技巧"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-19</div><div class="title">【科普】（软件向）网络运维工具的介绍与使用技巧</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/dcb11262f483239ffc471.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Magiku</div><div class="author-info__description">个人博客，用于记录知识库。<br>希望这些笔记能对你有所帮助！<br>要是有什么需要交流的，欢迎联系我~</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" href="/about/"><i class="fas fa-heart"></i><span>about</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://c4893f9d.telegraph-image-713.pages.dev/file/5fc03bf783d0242724fb7.png" target="_blank" title="QQ"><i class="fab fa-qq" style="color: #6899ee;"></i></a><a class="social-icon" href="https://c4893f9d.telegraph-image-713.pages.dev/file/7fbd32e8ba0698d529856.png" target="_blank" title="微信"><i class="fab fa-weixin" style="color: #44d55c;"></i></a><a class="social-icon" href="https://space.bilibili.com/39293027" target="_blank" title="哔哩哔哩"><i class="fab fa-bilibili" style="color: #e3d9;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#STP%EF%BC%88%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AE%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">STP（生成树协议）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#STP%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">STP的基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BPDU%EF%BC%88Bridge-Protocol-Data-Unit%EF%BC%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">BPDU（Bridge Protocol Data Unit）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%A1%A5%EF%BC%88Root-Bridge%EF%BC%89"><span class="toc-number">1.1.2.</span> <span class="toc-text">根桥（Root Bridge）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E5%BC%80%E9%94%80%EF%BC%88Path-Cost%EF%BC%89"><span class="toc-number">1.1.3.</span> <span class="toc-text">路径开销（Path Cost）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E7%AB%AF%E5%8F%A3%EF%BC%88Root-Port%EF%BC%89%E5%92%8C%E6%8C%87%E5%AE%9A%E7%AB%AF%E5%8F%A3%EF%BC%88Designated-Port%EF%BC%89"><span class="toc-number">1.1.4.</span> <span class="toc-text">根端口（Root Port）和指定端口（Designated Port）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STP%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">STP原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E7%94%A8%E5%88%B0%E7%A8%B3%E5%AE%9A%E9%98%B6%E6%AE%B5"><span class="toc-number">1.2.1.</span> <span class="toc-text">启用到稳定阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%B3%E5%AE%9A%E5%90%8E%E7%9A%84%E7%BB%B4%E6%8A%A4%E9%98%B6%E6%AE%B5"><span class="toc-number">1.2.2.</span> <span class="toc-text">稳定后的维护阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E4%B8%BE%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.2.3.</span> <span class="toc-text">选举优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E6%A1%A5%E7%9A%84%E9%80%89%E4%B8%BE"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">根桥的选举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E7%AB%AF%E5%8F%A3%E7%9A%84%E9%80%89%E4%B8%BE"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">根端口的选举</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E9%94%80"><span class="toc-number">1.2.3.2.1.</span> <span class="toc-text">开销</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E7%AB%AFBID"><span class="toc-number">1.2.3.2.2.</span> <span class="toc-text">对端BID</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E7%AB%AFPID"><span class="toc-number">1.2.3.2.3.</span> <span class="toc-text">对端PID</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%AC%E7%AB%AFPID"><span class="toc-number">1.2.3.2.4.</span> <span class="toc-text">本端PID</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E7%AB%AF%E5%8F%A3-%E9%98%BB%E5%A1%9E%E7%AB%AF%E5%8F%A3%E7%9A%84%E9%80%89%E4%B8%BE"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">指定端口&#x2F;阻塞端口的选举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E7%99%BD%E4%BA%86%EF%BC%8C%E9%80%89%E4%B8%BE%E7%9A%84%E5%B0%B1%E6%98%AF%E4%B8%BA%E4%BA%86%E4%BC%A0%E9%80%92%E6%9C%80%E5%A5%BD%E7%9A%84BPDU"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">说白了，选举的就是为了传递最好的BPDU</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STP%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E6%97%B6%E9%97%B4"><span class="toc-number">1.2.4.</span> <span class="toc-text">STP中的几个时间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STP%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">1.3.</span> <span class="toc-text">STP的配置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RSTP"><span class="toc-number">2.</span> <span class="toc-text">RSTP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#STP%E7%9A%84%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84"><span class="toc-number">2.1.</span> <span class="toc-text">STP的不足之处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RSTP%E5%AF%B9STP%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">2.2.</span> <span class="toc-text">RSTP对STP的改进</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%AB%AF%E5%8F%A3%E8%A7%92%E8%89%B2%E7%9A%84%E5%A2%9E%E8%A1%A5%EF%BC%8C%E7%AE%80%E5%8C%96%E4%BA%86%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E9%83%A8%E7%BD%B2%E3%80%82"><span class="toc-number">2.2.1.</span> <span class="toc-text">通过端口角色的增补，简化了生成树协议的理解及部署。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E7%8A%B6%E6%80%81%E7%9A%84%E9%87%8D%E6%96%B0%E5%88%92%E5%88%86"><span class="toc-number">2.2.2.</span> <span class="toc-text">端口状态的重新划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEBPDU%E7%9A%84%E5%A4%84%E7%90%86%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96"><span class="toc-number">2.2.3.</span> <span class="toc-text">配置BPDU的处理发生变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%94%B6%E6%95%9B"><span class="toc-number">2.2.4.</span> <span class="toc-text">快速收敛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">2.2.5.</span> <span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RST-BPDU"><span class="toc-number">2.3.</span> <span class="toc-text">RST BPDU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proposal-Agreement%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.</span> <span class="toc-text">Proposal&#x2F;Agreement机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Proposal-Agreement%E6%9C%BA%E5%88%B6%E8%BF%87%E7%A8%8B%E5%8E%9F%E7%90%86"><span class="toc-number">2.4.1.</span> <span class="toc-text">Proposal&#x2F;Agreement机制过程原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RSTP%E4%B8%AD%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">2.5.</span> <span class="toc-text">RSTP中的保护机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BPDU%E4%BF%9D%E6%8A%A4"><span class="toc-number">2.5.1.</span> <span class="toc-text">BPDU保护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-number">2.5.1.1.</span> <span class="toc-text">操作步骤：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E7%BB%AD%E5%A4%84%E7%90%86"><span class="toc-number">2.5.1.2.</span> <span class="toc-text">后续处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E4%BF%9D%E6%8A%A4"><span class="toc-number">2.5.2.</span> <span class="toc-text">根保护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4%EF%BC%9A-1"><span class="toc-number">2.5.2.1.</span> <span class="toc-text">操作步骤：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E8%B7%AF%E4%BF%9D%E6%8A%A4"><span class="toc-number">2.5.3.</span> <span class="toc-text">环路保护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4%EF%BC%9A-2"><span class="toc-number">2.5.3.1.</span> <span class="toc-text">操作步骤：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2TC-BPDU%E6%94%BB%E5%87%BB"><span class="toc-number">2.5.4.</span> <span class="toc-text">防TC-BPDU攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.5.4.1.</span> <span class="toc-text">操作步骤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RSTP%E9%85%8D%E7%BD%AE"><span class="toc-number">2.6.</span> <span class="toc-text">RSTP配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%B9%E7%BC%98%E7%AB%AF%E5%8F%A3"><span class="toc-number">2.6.1.</span> <span class="toc-text">边缘端口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4%EF%BC%9A-3"><span class="toc-number">2.6.1.1.</span> <span class="toc-text">操作步骤：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E"><span class="toc-number">2.6.1.2.</span> <span class="toc-text">补充说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AERSTP%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4"><span class="toc-number">2.6.2.</span> <span class="toc-text">配置RSTP超时时间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4%EF%BC%9A-4"><span class="toc-number">2.6.2.1.</span> <span class="toc-text">操作步骤：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEP-A%E6%9C%BA%E5%88%B6%E7%9A%84%E8%BF%81%E7%A7%BB%E6%96%B9%E5%BC%8F"><span class="toc-number">2.6.3.</span> <span class="toc-text">配置P&#x2F;A机制的迁移方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4%EF%BC%9A-5"><span class="toc-number">2.6.3.1.</span> <span class="toc-text">操作步骤：</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Magiku</div><div class="footer_custom_text"></p></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'd55e9307ca605124a542',
      clientSecret: '73a85d39b9bda1aa0f24ac51ea5a9504edf02277',
      repo: 'magiku.github.io',
      owner: 'magiku',
      admin: ['magiku'],
      id: '850f8091672234895070c02a61b379d9',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.textContent= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://magiku.github.io/categories/计算机网络/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 计算机网络 (10)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://magiku.github.io/categories/个人杂谈/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 磨叽墨迹 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://magiku.github.io/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.8/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = '39b2c1fede67489eb9265b983874c66d';
  var gaud_map_key = '84b1f52230bfdc06111b20984a0b04d9';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.324587,23.106574';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.8/lib/clock.min.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1s');
    arr[i].setAttribute('data-wow-delay', '0.5s');
    arr[i].setAttribute('data-wow-offset', '0');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>
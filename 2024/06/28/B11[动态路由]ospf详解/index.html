<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>B11【动态路由】ospf详解 | Magiku's药剂屋</title><meta name="author" content="Magiku"><meta name="copyright" content="Magiku"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文将介绍OSPF这一用于淘汰RIP的链路状态路由协议。">
<meta property="og:type" content="article">
<meta property="og:title" content="B11【动态路由】ospf详解">
<meta property="og:url" content="https://magiku.github.io/2024/06/28/B11[%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1]ospf%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="Magiku&#39;s药剂屋">
<meta property="og:description" content="本文将介绍OSPF这一用于淘汰RIP的链路状态路由协议。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://c4893f9d.telegraph-image-713.pages.dev/file/dcb11262f483239ffc471.png">
<meta property="article:published_time" content="2024-06-28T14:25:35.000Z">
<meta property="article:modified_time" content="2024-06-28T14:25:35.000Z">
<meta property="article:author" content="Magiku">
<meta property="article:tag" content="网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://c4893f9d.telegraph-image-713.pages.dev/file/dcb11262f483239ffc471.png"><link rel="shortcut icon" href="https://telegraph-image-713.pages.dev/file/35fde8abe3ef661685f2b.png"><link rel="canonical" href="https://magiku.github.io/2024/06/28/B11[%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1]ospf%E8%AF%A6%E8%A7%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'B11【动态路由】ospf详解',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-28 22:25:35'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.8/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/image/loading.gif" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/dcb11262f483239ffc471.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/summarize/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Magiku's药剂屋"><span class="site-name">Magiku's药剂屋</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/summarize/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">B11【动态路由】ospf详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-28T14:25:35.000Z" title="发表于 2024-06-28 22:25:35">2024-06-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-28T14:25:35.000Z" title="更新于 2024-06-28 22:25:35">2024-06-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>OSPF开放式最短路径优先（Open Shortest Path First）是IETF组织开发的一个基于<strong>链路状态</strong>的内部网关协议。本文将介绍的是OSPF v2版本。除此之外还有一个v3版本，其适用于IPv6环境。</p>
<p>上一篇我们讲过的RIP是基于距离矢量算法的路由协议，存在着收敛慢、路由环路、可扩展性差等问题。</p>
<p>OSPF作为基于链路状态的协议，能够解决RIP所面临的诸多问题，<strong>目前RIP正在被OSPF淘汰</strong>。</p>
<ul>
<li>以运行RIP为例的距离矢量路由协议的路由器是依靠周期性的泛洪自己的路由表，每台路由器都从相邻路由器学习路由，它们不清楚网络的拓扑结构，只是简单的知道前往某个网段应该从那里走，走多远（出接口是哪、跳数多少）。</li>
<li>而运行以OSPF为例的链路状态路由协议的路由器则清楚整个网络拓扑结构，并以此计算规划出路线，从而使得路由不易环路。它们之间会先建立邻居关系，再交换链路状态信息，它们并不交换路由信息。路由信息只由自己收集链路状态信息后计算得到。</li>
</ul>
<blockquote>
<p>与其说让OSPF与RIP作比较来进行学习，我认为借助STP的知识来学习会更得心应手。不过一开始还是先跟RIP比较一下，之后介绍原理的时候我们就可以试着跟STP的原理对比一下。</p>
</blockquote>
<p>因此，在介绍OSPF之前，我们就得清楚什么是链路状态。</p>
<h1 id="链路状态"><a href="#链路状态" class="headerlink" title="链路状态"></a>链路状态</h1><p>链路状态路由协议则是使用一些特殊的信息描述网络的拓扑结构与网段信息，这些信息称为链路状态信息（Link State）。</p>
<p>这些信息会被存放于链路状态数据库LSDB（Link State Database）中，LSDB可以被视为对整个网络拓扑结构以及网段信息的描绘，LSDB同步后，所有路由器拥有对网络的一致认知。</p>
<p>接下来路由器都会独立进行SPF(shortest path first)最短路径优先算法，以得到一颗无环的最短路径树。</p>
<p>这棵树以自己为根，并且可以到达网络的各个角落，最终路由器将基于这棵树产生路由，并加载到路由表中。</p>
<p><strong>在OSPF中，这些链路状态信息被称为LSA</strong>（Link-State Advertisement,链路状态通告），OSPF定义了多种LSA类型，我们后续会介绍学习每种LSA的用途。</p>
<p>一般来说，我们可以认为一台路由器a发送给路由器b的LSA中包含了<em>网段</em>，<em>发现该网段的路由器</em>，<em>到达该目标网段的接口IP</em>。</p>
<blockquote>
<p>似乎一时间无法理解这与rip协议这种距离矢量协议直接传递的路由有什么不同。</p>
<p>解释一下，<strong><em>“ 发现该网段的路由器 ”</em> 不一定是路由器a，可以是其他路由器</strong>，在rip中是没有这个信息。</p>
<p>而<em>”到达该目标网段的接口IP“</em> 则是路由器a与路由器b相连的接口的IP，这与rip中传递的路由信息的下一跳是一个意思。</p>
</blockquote>
<p>实际lsa中不止包含以上三个信息，还有其他信息，这些信息集合起来就为路由器描绘整个网络结构提供了充分条件。</p>
<h1 id="ospf的基础原理"><a href="#ospf的基础原理" class="headerlink" title="ospf的基础原理"></a>ospf的基础原理</h1><p>我们先粗略的过一遍ospf的原理，再不断扩宽框架，有一个完整框架之后再由浅入深。</p>
<blockquote>
<p>OSPF适用于多种网络类型中（点对点、点对多点、多点对多点），本文未做特别说明的情况下，默认为介绍在多点对多点的网络（常见的以太网）下的情景。</p>
</blockquote>
<h2 id="原理简述"><a href="#原理简述" class="headerlink" title="原理简述"></a>原理简述</h2><p> OSPF 的工作原理简述：</p>
<ol>
<li><p><strong>邻居发现</strong>：OSPF 路由器通过发送 Hello 报文来发现相邻的路由器。当两台路由器在相互发送 Hello 报文确认彼此可达时，它们就成为邻居。</p>
</li>
<li><p><strong>链路状态广播</strong>：一旦建立邻居关系，路由器将定期发送链路状态更新报文（LSU），其中包含本地路由器所知道的网络拓扑信息（LSA）。</p>
</li>
<li><p><strong>路由计算</strong>：收到 LSU 报文后，每台路由器将更新其链路状态数据库（LSDB），并使用 Dijkstra 算法计算出最短路径树（SPF Tree），确定到达目的网络的最佳路径。</p>
</li>
<li><p><strong>路由表生成</strong>：根据 SPF Tree 计算结果，每台路由器生成自己的路由表，记录到达各个目的网络的最佳路径和下一跳信息。</p>
</li>
<li><p><strong>路由更新</strong>：如果网络拓扑发生变化，比如链路断开或恢复，路由器将重新计算最短路径树，并将这些链路状态信息的更新通过 LSU 报文广播给相邻路由器，以便网络中的所有路由器都能及时了解变化。</p>
</li>
</ol>
<blockquote>
<p>上述提到的广播并不是真正严格意义上的<em>广播（目标地址全1）</em>，OSPF是通过<strong>组播</strong>的方式进行通信的。</p>
</blockquote>
<h2 id="DR、router-id"><a href="#DR、router-id" class="headerlink" title="DR、router-id"></a>DR、router-id</h2><p>但如果每两台路由器都进行完整的LSA传递（包括后续的定期报文与更新报文），那么对网络资源是不小的占用。为此，OSPF中引入了类似于STP根桥的主备机制；同时为了标识路由器，也引入了类似于STP桥id的概念。</p>
<ul>
<li><strong>OSPF定义了<em>指定路由器DR</em>和<em>备份指定路由器BDR</em>。</strong></li>
</ul>
<blockquote>
<p>通过选举产生DR（Designated Router）后，所有路由器都只将信息发送给DR，由DR将网络链路状态LSA广播出去。如果DR由于某种故障而失效，则网络中的路由器必须重新选举DR，并与新的DR同步。这需要较长的时间，在这段时间内，路由的计算有可能是不正确的。</p>
<p>为了能够缩短这个过程，OSPF提出了BDR（Backup Designated Router）的概念。BDR是对DR的一个备份，在选举DR的同时也选举出BDR。当DR失效后，BDR会立即成为DR。由于不需要重新选举，并且关系已建立，所以这个过程非常短暂，这时还需要再重新选举出一个新的BDR，虽然一样需要较长的时间，但此时已经有新DR在工作了，并不会影响网络通信。</p>
</blockquote>
<ul>
<li><strong>OSPF定义了Router-ID (Router Identification，路由器标识)。</strong></li>
</ul>
<blockquote>
<p>router-id是一个32bit长度的数值，通常使用点分十进制表示（与IPv4地址一样），用于一个OSPF区域内表示唯一的一台路由器。也就是说router-id不能重复，冲突会导致无法建立关系。</p>
<p>一般router-id会自动根据路由器已配置的ip地址选定；但由于router-id不能重复，且与STP中的桥id类似，会影响<strong>根</strong>的选举，所以推荐手动配置router-id。</p>
</blockquote>
<ul>
<li>OSPF中DR&#x2F;BDR的选举规则</li>
</ul>
<blockquote>
<p>STP选举根桥的规则是先比较优先级值，优先级值一样，再比较mac。</p>
<p>OSPF与之类似，也是先比较优先级值，不过后比较的不是mac值而是router-id。</p>
<p>当处于同一网段的两台路由器同时宣布自己是DR时，DR优先级高者胜出。</p>
<p>如果优先级相等，则Router ID大者胜出。如果一台路由器的优先级为0，则它不会被选举为DR或BDR。</p>
</blockquote>
<ul>
<li>DR的选举不具备抢占性，当网络中有设备已经是DR的情况下，新接入的设备即便优先级更高，也还是认之前的DR路由器。</li>
</ul>
<h2 id="报文发送方式"><a href="#报文发送方式" class="headerlink" title="报文发送方式"></a>报文发送方式</h2><p>OSPF协议报文封装于IP协议报文中，协议号89。OSPF常使用两个组播地址进行数据通信。（目的地址）</p>
<ul>
<li>224.0.0.5：该组播地址指向所有OSPF路由器。</li>
<li>224.0.0.6：该组播地址指向DR&#x2F;BDR路由器。</li>
</ul>
<p>举个例子，在OSPF关系稳定后，普通OSPF路由器向DR发布链路更新报文使用224.0.0.6地址，而DR周期性的向所有路由发布定期报文或更新报文就采用224.0.0.5的地址</p>
<blockquote>
<p>不使用广播地址的原因就是为了不影响其他的非OSPF设备。而不使用同一个组播地址的原因则是为了上一节说的DR机制。</p>
</blockquote>
<p>注意，因为OSPF是使用组播地址进行通信，<strong>组播地址也可以算作一种广播，是会被网段隔离的，无法跨网段传输</strong>。因此选举DR与BDR，只能在一个网段内进行。</p>
<p>因此，<strong>在OSPF中，每个网段都会选举DR&#x2F;BDR</strong>，也就是说总体上看，可能会出现多个DR。</p>
<h2 id="邻居与邻接关系"><a href="#邻居与邻接关系" class="headerlink" title="邻居与邻接关系"></a>邻居与邻接关系</h2><p>我们一般会根据是否发送后续LSA更新来判断两台OSPF路由器是处于邻居还是邻接关系。</p>
<p>邻居关系是指两台路由器之间都能基于OSPF进行通信，也就是都拥有对方的信息（router-id）</p>
<p>而邻接关系是值两台路由器之间会进行LSA的交换并且LSDB最终都保持相同。</p>
<p>一般一个OSPF区域中，所有路由器两两之间都处于邻居关系；与DR以及BDR之间则处于邻接关系。</p>
<blockquote>
<p>事实上，也正是设定了DR、BDR的机制后才有了邻居与邻接的区分，否则邻居关系只是一个过程罢了。</p>
</blockquote>
<h3 id="邻居表"><a href="#邻居表" class="headerlink" title="邻居表"></a>邻居表</h3><p>一个路由器的接口激活OSPF后，该接口将会周期性的发送OSPF hello报文。</p>
<p>当OSPF接口收到hello报文，也就是发现邻居后，该hello报文中的信息将会被写入到路由器的OSPF邻居表中。</p>
<p>在邻居表中我们就可以看到“邻居”是处于邻居关系还是邻接关系。</p>
<blockquote>
<p> 有关hello报文的内容稍后介绍。</p>
</blockquote>
<h2 id="OSPF域"><a href="#OSPF域" class="headerlink" title="OSPF域"></a>OSPF域</h2><p>现在我们知道<strong>OSPF至少会维护三张数据表</strong>，分别是存放LSA信息的LSDB表、存放邻居信息的邻居表、存放计算得到的路由信息的路由表。</p>
<p>如果一个OSPF进程中存在十几台路由器、上百个网段，基于LSDB必须全路由器同步的机制，那么每台路由器维护的LSDB表将会很大，而根据LSDB计算而来的路由表也小不了。如果路由器数量更多，那么会更加庞大，同步这些表信息则会占用大量的网络资源，根据如此庞大的表信息进行计算也会消耗大量的设备性能。</p>
<p>因此，<strong>OSPF引入了区域的概念（Area</strong>），每个区域内部维护自己LSDB表，LSA的泛洪限制在区域内，避免对区域外部造成影响。</p>
<p>处于区域之间的路由器则额外负责进行LSA的整合，为连接的两个区域发布聚合的信息，以保证两个区域之间仍可进行通信。</p>
<p>但为了避免路由环路，所以设立了骨干区域（中心区域），只有<em>一侧处于骨干区域的路由器</em> 才拥有发布跨区域LSA的权限。</p>
<p>因此，每个区域都必须与骨干区域相连，否则没有<em>一侧处于骨干区域的路由器</em> 的帮助，缺少其他区域的LSA信息，则该区域无法与外界通信，成为一座“孤岛”。</p>
<blockquote>
<p>似乎有点抽象，我们比喻一下。</p>
<p>让快递小哥记忆全国所有城市的街道信息、楼栋信息这很难。</p>
<p>实际快递小哥只需要知道他负责区域的详细地理信息即可，超过他负责范围的快递件，他就拿回站点。</p>
<p>该快递件由站点直接发送给本市的分拣中心，在这里被发到转运中心。</p>
<p>由转运中心发往目标城市的分拣中心，最后再通过该城市的站点与快递小哥送达收件人手中。</p>
</blockquote>
<h3 id="区域的格式"><a href="#区域的格式" class="headerlink" title="区域的格式"></a>区域的格式</h3><p>Area-id与router-id一样，也是32bit的按点分十进制表示的数，例如：area0.0.0.1。</p>
<p>但实际上我们更常用完全的十进制来表示，例如area0.0.0.1写为area1，area0.0.1.0写为area256。</p>
<p><strong>骨干区域为area0.0.0.0也就是area0。</strong></p>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>DR和BDR的选举是在每个OSPF区域上进行的，而不是在整个OSPF进程中进行的。这意味着在一个OSPF进程中可能存在多个DR和BDR。</p>
<h2 id="OSPF路由器的角色"><a href="#OSPF路由器的角色" class="headerlink" title="OSPF路由器的角色"></a>OSPF路由器的角色</h2><p>了解了以上的各种概念后，我们就可以来介绍一下OSPF中路由器一共有哪些角色。（除开表示根的DR与BDR）</p>
<blockquote>
<p>虽然会叫某某OSPF路由器，但请记住所有的协议进程都是以接口为主来运行的。</p>
</blockquote>
<ul>
<li><p>内部路由器(Internal Router，<strong>IR</strong>)：所有接口都接入同一个OSPF区域的路由器。</p>
</li>
<li><p>区域边界路由器(Area Border Router，<strong>ABR</strong>)：接入多个区域的路由器且至少一个接口在Area0中激活的路由器。<strong>ABR负责在区域之间传递路由信息，因此ABR必须连接到Area0，并同时连接着其他区域。</strong></p>
</li>
<li><p>骨干路由器(Backbone Router，<strong>BR</strong>)：接入Area0的路由器。ABR也是骨干路由器。</p>
</li>
<li><p>AS边界路由器 (AS Boundary Router，<strong>ASBR</strong>)：ASBR将OSPF域外的路由引入本域，使得外部路由在整个OSPF 域内传递。</p>
<p>比如说一台路由器除了接入OSPF网络，它还接入了一个RIP网络，如果它将自己路由表中通过RIP学习到的路由重分发到了OSPF 中，那它就是ASBR。（是先干了这事，它才成为ASBR）</p>
<p>并不是同时运行多种路由协议的OSPF路由器就一定是ASBR，<strong>ASBR一定是将外部路由重分发到OSPF，或者执行了路由重分发操作的路由器。</strong></p>
</li>
</ul>
<blockquote>
<p>虽然BR、ABR、ASBR这三者看起来都带了“BR”的名头，但它们并不是同一个意思。（所以标注了英文全称）</p>
<p>实际IR并没有什么特别的用途，只需记忆其他三个角色即可。</p>
</blockquote>
<p><img src= "/image/loading.gif" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/49b5393707524f8e5d699.png" alt="一图展示区域与路由器类型"></p>
<h2 id="LSA类型1-5"><a href="#LSA类型1-5" class="headerlink" title="LSA类型1-5"></a>LSA类型1-5</h2><p>正因为OSPF划分了区域，并设计了ABR与ASBR的机制，因此我们可以为各路由器间发布的LSA进行一个分类。（实际后续还有其他类型，我们由浅到深慢慢展开介绍。）</p>
<blockquote>
<p>我们一般直接使用“类型几”这个称呼，几乎不使用完整的全称。</p>
</blockquote>
<table>
<thead>
<tr>
<th>LSA类型</th>
<th>LSA作用</th>
</tr>
</thead>
<tbody><tr>
<td>Router-LSA（Type1）</td>
<td>每个设备都会产生，描述了设备的链路状态和开销，在所属的区域内传播。</td>
</tr>
<tr>
<td>Network-LSA（Type2）</td>
<td>由DR产生，描述本网段的链路状态，在所属的区域内传播。（相当于DR对区域内所有路由器信息的汇总）</td>
</tr>
<tr>
<td>Network-summary-LSA（Type3）</td>
<td>由ABR产生，描述区域内某个网段的路由，并通告给其他区域。</td>
</tr>
<tr>
<td>ASBR-summary-LSA（Type4）</td>
<td>由ABR产生，描述到ASBR的路由，通告给除ASBR所在区域的其他相关区域。</td>
</tr>
<tr>
<td>AS-external-LSA（Type5）</td>
<td>由ASBR产生，描述到AS外部的路由，通告到所有的区域。</td>
</tr>
</tbody></table>
<p>type-4也就是对于type-5的补充与售后，其他区域的路由器即便知道了到达ospf区域外的网段要通过ASBR，但它们不知道如何到达ASBR，就需要与ASBR同区域的ABR去传播到达该ASBR的路由信息。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们目前是粗略的过一遍基础概念原理，还不够理解的，不必在意，<strong>稍后会详细介绍</strong>。</p>
<p>总的来说：</p>
<ol>
<li>OSPF会进行区域划分，有一个骨干区域Area0，其他区域必须与骨干区域相连。</li>
<li>OSPF中会对每台路由器分配一个router-id用于标识路由器身份。</li>
<li>每个区域内会基于router-id选举DR负责对区域内LSA的统合更新。</li>
<li>区域内的路由器通过类型1与类型2的LSA完成区域内LSDB的同步。</li>
<li>骨干区域与区域之间通过ABR的类型3LSA进行跨区域的信息传递。</li>
<li>如果某一台路由器连接了其他网络，并将该网络的路由信息引入到OSPF中，它会发布类型5的LSA告知其他路由器，同时它就宣布自己是一台ASBR。（全体目光向我看齐，我宣布个事，我是ASBR，去这个外部网络就来找我嗷。）</li>
<li>与该路由器同处一区域的ABR会自行产生并传播一条类型4的LSA用于告知其他路由器如何到达这台ASBR。</li>
</ol>
<p>除此之外，OSPF还有其他还没有提到的知识点，我们稍后会以有什么需求，因此有什么解决方案的方式来一一展开讲解。</p>
<h1 id="OSPF的报文格式、邻居状态、邻居-邻接建立过程"><a href="#OSPF的报文格式、邻居状态、邻居-邻接建立过程" class="headerlink" title="OSPF的报文格式、邻居状态、邻居&#x2F;邻接建立过程"></a>OSPF的报文格式、邻居状态、邻居&#x2F;邻接建立过程</h1><h2 id="OSPF的报文类型"><a href="#OSPF的报文类型" class="headerlink" title="OSPF的报文类型"></a>OSPF的报文类型</h2><table>
<thead>
<tr>
<th>报文类型</th>
<th>报文作用</th>
</tr>
</thead>
<tbody><tr>
<td>Hello报文</td>
<td>周期性发送，用来发现和维持OSPF邻居关系。</td>
</tr>
<tr>
<td>DD报文（Database <strong>Description</strong> packet）</td>
<td>描述本地LSDB（Link State Database）的摘要信息，用于两台设备进行数据库同步。</td>
</tr>
<tr>
<td>LSR报文（Link State <strong>Request</strong> packet）</td>
<td>用于向对方请求所需的LSA。设备只有在OSPF邻居双方成功交换DD报文后才会向对方发出LSR报文。</td>
</tr>
<tr>
<td>LSU报文（Link State <strong>Update</strong> packet）</td>
<td>用于向对方发送其所需要的LSA。</td>
</tr>
<tr>
<td>LSAck报文（Link State <strong>Acknowledgment</strong> packet）</td>
<td>用来对收到的LSA进行确认。</td>
</tr>
</tbody></table>
<blockquote>
<p>LSA是链路状态信息，是报文内部的信息，注意不要混淆了名称。</p>
</blockquote>
<h2 id="OSPF的邻居状态"><a href="#OSPF的邻居状态" class="headerlink" title="OSPF的邻居状态"></a>OSPF的邻居状态</h2><p>OSPF的邻居共有8种状态，分别是：Down、Attempt、Init、2-way、Exstart、Exchange、Loading、Full。</p>
<ul>
<li><strong>Down</strong>：邻居会话的初始阶段，或者是没有在邻居失效时间间隔内收到来自邻居路由器的Hello数据包。</li>
<li>Attempt：该状态仅发生在非广播的多路网络中（帧中继那一类，但基本被淘汰了），表明对端在邻居失效时间间隔（dead interval）超时前仍然没有回复Hello报文。此时路由器依然每发送轮询Hello报文的时间间隔（poll interval）向对端发送Hello报文。</li>
<li><strong>Init</strong>：收到Hello报文后状态为Init。</li>
<li><strong>2-way</strong>：<strong>收到的Hello报文中包含有自己的Router ID，则状态为2-way</strong>；<strong>如果不需要形成邻接关系则邻居状态机就停留在此状态，否则进入Exstart状态。</strong></li>
<li><strong>Exstart</strong>：开始协商主从关系，并确定DD的序列号，此时状态为Exstart。</li>
<li><strong>Exchange</strong>：主从关系协商完毕后开始交换DD报文，此时状态为Exchange。</li>
<li><strong>Loading</strong>：DD报文交换完成即Exchange done，此时状态为Loading。</li>
<li><strong>Full</strong>：LSR重传列表为空，此时状态为Full。full也表示邻接关系建立完毕。</li>
</ul>
<h2 id="建立邻居关系"><a href="#建立邻居关系" class="headerlink" title="建立邻居关系"></a>建立邻居关系</h2><p>如图所示为路由器R1与路由器R2的邻居关系建立过程。其中路由器R1的router-id为1.1.1.1，路由器R2的router-id为2.2.2.2。</p>
<img src= "/image/loading.gif" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/81c89f47a43e6a4fb40f1.png" style="zoom: 67%;" />



<ol>
<li><p>R1的一个连接到广播类型网络的接口上激活了OSPF协议，并发送了一个Hello报文（目的地址使用组播地址224.0.0.5；源地址为接口IP：10.1.12.1）</p>
<p>同时该报文内包含了router-id（指代发送人），区域id，<strong>网络掩码（与源ip结合起来得到该接口的网段）</strong>，OSPF的一些定时器，以及最重要的<strong>已发现邻居列表</strong>。（当前未发现，则为空）。</p>
</li>
<li><p>R2收到R1发送的Hello报文后，学习到R1的router-id，计入进邻居表中，同时对外发布hello报文，并且在报文中的Neighbors Seen字段中填入R1的Router ID（Neighbors Seen&#x3D;1.1.1.1），表示我知道有你这个邻居了，然后R2邻居状态机置为Init。</p>
</li>
<li><p>当R1收到R2回应的Hello报文，因报文内的邻居列表有自己的router-id，于是将邻居状态机置为2-way状态，同时也因为学习到了R2的id，会对外再发送一个更新的hello报文。</p>
<p>R2收到R1发送的最新Hello报文后，在报文内也发现了自己router-id，也将邻居状态机置为2-way状态</p>
</li>
</ol>
<blockquote>
<p>总结一下：收到hello报文，报文内没有自己的router-id，则状态为int；收到hello报文，报文内有自己的router-id，则状态为2-way。</p>
<p>这两个状态并不是连续的，上图中，RouterA的状态就是从Dowm直接过渡到2-way。</p>
</blockquote>
<p>除开router-id，hello报文内的其他信息是构建邻居关系的重要条件；区域id、网段（源ip与掩码计算得出）、hello间隔、失效间隔哪怕有一项不相同，也无法构建邻居关系。</p>
<p>另外，当两台路由器构建完毕邻居关系（都标记为“2-way”状态），将会开始DR&#x2F;BDR的选举。</p>
<h2 id="建立邻接关系"><a href="#建立邻接关系" class="headerlink" title="建立邻接关系"></a>建立邻接关系</h2><p>当路由器确定好DR&#x2F;BDR后，如果两台路由器之间都是非DR&#x2F;BDR，则关系停留在邻居。</p>
<p>如果其中一台路由器为DR&#x2F;BDR，则会交换LSA信息，最终发展为邻接关系。</p>
<blockquote>
<p>此过程是以单播的形式进行交互，不采用OSPF默认的组播地址。</p>
</blockquote>
<p>在交换LSA之前，路由器之间会协商主&#x2F;从关系，然后先交换简要的LSA信息，待确定需要LSA信息后，会请求对方给出该简要信息的全部完整信息。</p>
<blockquote>
<p>为了提高发送的效率，R1和R2首先了解对端数据库中哪些LSA是需要更新的，如果某一条LSA在LSDB中已经存在，就不再需要请求更新了。</p>
<p>为了达到这个目的，R1和R2先发送DD报文，DD报文中包含了对LSDB中LSA的摘要描述（每一条摘要可以唯一标识一条LSA）。</p>
<p>为了保证在传输的过程中报文传输的可靠性，在DD报文的发送过程中需要确定双方的主从关系，作为Master的一方定义一个序列号Seq，每发送一个新的DD报文将Seq加一，作为Slave的一方，每次发送DD报文时使用接收到的上一个Master的DD报文中的Seq。（类似TCP的机制）</p>
</blockquote>
<img src= "/image/loading.gif" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/964bf40ddc36f5592ef84.png" style="zoom:67%;" />

<ol>
<li><p>R1首先发送一个DD报文，宣称自己是Master（MS&#x3D;1），并规定序列号Seq&#x3D;X（图中假定为200）.</p>
<p>I&#x3D;1表示这是第一个的DD报文，报文中并不包含LSA的摘要，只是为了协商主从关系。</p>
<p>M&#x3D;1说明这不是最后一个报文，后续还有DD报文要发送。</p>
</li>
<li><p>R2在收到R1的DD报文后，将R1的邻居状态机改为Exstart，并且回应了一个DD报文（该报文中同样不包含LSA的摘要信息）。</p>
<p>由于R2的router-id较大，所以在报文中R2认为自己是Master，并且重新规定了序列号Seq&#x3D;Y（图中假定为300）。</p>
</li>
<li><p>R1收到报文后，同意了R2为Master，并将R2的邻居状态机改为Exchange。</p>
<p>R1使用R2的序列号Seq&#x3D;300来发送新的DD报文，该报文开始正式地传送LSA的摘要。</p>
<p>在报文中R1将MS&#x3D;0，说明自己是Slave。</p>
</li>
<li><p>R2收到报文后，将R1的邻居状态机改为Exchange，并发送新的DD报文开始描述自己的LSA摘要，此时R2将报文的序列号改为Seq&#x3D;300+1。</p>
</li>
<li><p>如果双方的LSDB包含的LSA信息数量很多，一条DD报文无法简述完毕，则会重复以上的交互，即：master路由器R2将DD序列号逐次加一，发送新的DD报文；slave路由器R1则使用前者的DD序列号发送自己的DD报文。</p>
</li>
</ol>
<img src= "/image/loading.gif" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/a2db7359b0f999f800bcc.png" style="zoom:67%;" />

<ol>
<li><p>当R1将把自己的<em>LSA摘要</em> 都发送完毕，也就是发送最后一个DD报文时，会将M比特位设置位0，表示这是最后一个DD报文。</p>
</li>
<li><p>R2收到R1的最后一个DD报文的时候，恰好也是要发送最后一个报文了，同样将M比特位设置位0。</p>
</li>
<li><p>R1收到R2的最后一个<em>序列号为309</em> 的DD报文后，即便它已经没有<em>LSA摘要</em> 需要发布了，但它仍需要对R2的报文进行回复确认（DD序列号相同即为确认），则它会向R2发送一个空的序号为309的DD报文。</p>
</li>
<li><p>R1发送完毕DD报文且收到R2的最后一个DD报文后，就会开始查看R2的<em>LSA摘要</em>，R1发现其中有许多LSA是自己没有的，将邻居状态机改为Loading状态。</p>
<p>R1发送LSR报文向R2请求更新LSA。</p>
</li>
<li><p>R2用LSU报文来回应R1的请求。</p>
</li>
<li><p>同样的，如果R2需要向R1请求LSA，也会发送LSR报文。</p>
</li>
<li><p>R1收到R2的LSU报文后，发送LSAck报文确认。收到R2的LSR请求则发送LSU报文。</p>
</li>
</ol>
<p>上述过程持续到R1&#x2F;R2发现已经没有LSA需要向对方请求，同时R1&#x2F;R2会将邻居状态机改为Full状态。</p>
<p>当R1与R2都将对方设置为Full状态，此时邻接关系建立完成。</p>
<h1 id="OSPF的度量值——cost"><a href="#OSPF的度量值——cost" class="headerlink" title="OSPF的度量值——cost"></a>OSPF的度量值——cost</h1><p>每种路由协议对度量值的规定是不同的，RIP是采用跳数，而在OSPF中，是使用cost（开销、代价）作为路由度量值。</p>
<p>cost值越小，则路由越优，其含义是走该路由所需的开销&#x2F;代价&#x2F;成本最低。</p>
<p>这个东西与STP协议中计算到根桥的路径开销值是差不多的概念。</p>
<p>在STP里，链路开销是按链路带宽给一个固定值。</p>
<p>而在ospf里，链路开销cost是用一个带宽参考值除以链路带宽得到的，如果值小于1则计为1。</p>
<p>为了让路由器能分清千兆、万兆的链路，所以会将带宽参考值设置的大一些，以避免千兆与万兆的cost值计算出来都为1。</p>
<h1 id="特殊区域（末梢区域）"><a href="#特殊区域（末梢区域）" class="headerlink" title="特殊区域（末梢区域）"></a>特殊区域（末梢区域）</h1><p>ospf使用了区域的划分来限制LSA在网络中的泛洪，减小路由器内部表的规模，但我们还可以更进一步。</p>
<h2 id="Stub-Area-（末梢区域）"><a href="#Stub-Area-（末梢区域）" class="headerlink" title="Stub Area （末梢区域）"></a>Stub Area （末梢区域）</h2><p>当一个<strong>非area0</strong>的普通区域只有一个出口（也就是只有一个ABR），那么该区域就可以被配置为Stub区域。</p>
<p>当一个区域被配置为Stub区域，这个区域的ABR会拦截type-5 LSA（指向外部网络的路由）。同时，该ABR会以type-3 LSA的形式发布一条默认路由，让区域内路由器学习。</p>
<blockquote>
<p>当然，发布的还是LSA，只是该LSA内的信息会被计算为默认路由。</p>
<p>另外既然拦截了type-5，那么type-4也没有存在意义，因此也会一并拦截。</p>
</blockquote>
<p>也就是说，这台ABR作为唯一出口，那么其他路由器访问外部网络直接默认指向它就可以，不需要拥有指定网段的路由，反正最后也是要经过它。这样就缩小了LSA与路由表项模。</p>
<h2 id="Totally-Stub-Area（完全末梢区域）"><a href="#Totally-Stub-Area（完全末梢区域）" class="headerlink" title="Totally Stub Area（完全末梢区域）"></a>Totally Stub Area（完全末梢区域）</h2><p><strong>在stub区域的基础上</strong>，因为只有一个出口，那么我们很简单就可以想到，包括前往其他区域的路由也都是经过这个出口，那么也可以在本区域取消到其他区域的信息。</p>
<p>为此就提出了完全末梢区域，该区域的ABR会将区域路由也一并拦截，只发布一条type-3LSA——描述指向自己的默认路由给区域内的路由器。</p>
<p>这样一来，该区域内仅存在type-1与type-2、以及唯一一条type-3的LSA。</p>
<h2 id="NSSA-Not-So-Stubby-Area，非完全末梢区域"><a href="#NSSA-Not-So-Stubby-Area，非完全末梢区域" class="headerlink" title="NSSA (Not-So-Stubby Area，非完全末梢区域)"></a>NSSA (Not-So-Stubby Area，非完全末梢区域)</h2><p>不管是普通的Stub区域还是Totally Stub区域，都是会拦截type-4与type-5的LSA。</p>
<p>但假设该末梢区域内某台路由直接连接着一个外部网络（比如RIP网络），那么与该路由器同属于一个ospf网络的其他区域路由器就无法学习到该外部RIP网络，因为相关的LSA被拦截了。</p>
<p>如果要传递出去，那只能取消了末梢区域，可我们又想保留限制其他区域传来外部路由，有没有什么办法呢。</p>
<p>NSSA，非完全末梢区域就是为了解决这种情况出现的。</p>
<p>在NSSA中，启用了一种新的LSA类型，type-7：NSSA LSA。该类型LSA由ASBR产生，描述到AS外部的路由，仅在NSSA区域内传播。</p>
<p>而该区域的ABR会将该type-7LSA转化为type-5LSA再发送给其他区域，以便该描述外部路由的链路信息能在整个OSPF网络中通告。</p>
<h2 id="Totally-NSSA"><a href="#Totally-NSSA" class="headerlink" title="Totally NSSA"></a>Totally NSSA</h2><p>NSSA对标的是普通Stub区域，其并不拦截type-3LSA。如果需要像Totally Stub区域一样，拦截type-3LSA，就可以配置为Totally NSSA区域。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>区域与其可允许出现的LSA类型：</p>
<table>
<thead>
<tr>
<th></th>
<th>type-1</th>
<th>type-2</th>
<th>type-3</th>
<th>type-4</th>
<th>type-5</th>
<th>type-7</th>
</tr>
</thead>
<tbody><tr>
<td>常规区域</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>Stub区域</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>Totally Stub区域</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>NSSA</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>Totally NSSA</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
</tbody></table>
<blockquote>
<p>两个Totally区域禁用type-3区域后，会由ABR发布一条type-3的描述指向自己的默认路由的LSA。全区域内仅存在这一条type-3LSA信息。</p>
</blockquote>
<h1 id="OSPF的维护"><a href="#OSPF的维护" class="headerlink" title="OSPF的维护"></a>OSPF的维护</h1><p>一般来说，OSPF中的路由器会周期性的发布hello报文以及时发现邻居以及表示自身还存活着。</p>
<p>当路由器在规定的失效时间内还没有收到邻居的周期性hello报文，则会认为邻居挂了。（失效时间能在hello报文中查看）</p>
<p>当路由器会在发现网络拓扑发生变更时，像RIPv2那样触发更新，发布LSU报文给DR，以便网络更快地收敛。</p>
<h1 id="LSA详解"><a href="#LSA详解" class="headerlink" title="LSA详解"></a>LSA详解</h1><p>先简单过一遍各种类型的名称与作用：</p>
<table>
<thead>
<tr>
<th>LSA类型</th>
<th>LSA作用</th>
</tr>
</thead>
<tbody><tr>
<td>Router-LSA（Type1）</td>
<td>每个设备都会产生，描述了设备的链路状态和开销，在所属的区域内传播。</td>
</tr>
<tr>
<td>Network-LSA（Type2）</td>
<td>由DR产生，描述本网段的链路状态，在所属的区域内传播。（相当于DR对区域内所有路由器信息的汇总）</td>
</tr>
<tr>
<td>Network-summary-LSA（Type3）</td>
<td>由ABR产生，描述区域内某个网段的路由，并通告给其他区域。</td>
</tr>
<tr>
<td>ASBR-summary-LSA（Type4）</td>
<td>由ABR产生，描述到ASBR的路由，通告给除ASBR所在区域的其他相关区域。</td>
</tr>
<tr>
<td>AS-external-LSA（Type5）</td>
<td>由ASBR产生，描述到AS外部的路由，通告到所有的区域。</td>
</tr>
<tr>
<td>NSSA-LSA（Type7）</td>
<td>仅用于NSSA区域，由该区域的ASBR产生，用于描述到AS外部的路由，仅通告给该区域。</td>
</tr>
</tbody></table>
<p>虽然我们总是说成发送一个type-*的报文，但实际呢，我们回忆一下邻接关系的报文交互，<strong>LSA信息是通过LSU报文传递的</strong>。</p>
<img src= "/image/loading.gif" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/627a02faee9f1cd93d917.png" style="zoom:80%;" />

<p>其中，LSA的头部格式如下图所示：</p>
<img src= "/image/loading.gif" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/85521da41d930c3d800d0.png" style="zoom:80%;" />

<p>需要关注的是以下三个字段，这三个字段唯一的标识一个LSA：</p>
<ul>
<li>链路状态类型（Link-State Type）：指示本条LSA的类型。</li>
<li>链路状态ID（Link-State ID）：LSA的标识。不同类型的LSA对该字段的定义不同。</li>
<li>通告路由器（Advertising Router）：产生该条LSA的路由器的router-id。</li>
</ul>
<blockquote>
<p>如果有两条LSA的这三个字段都一样，这表明这是同一条LSA，但他们肯定有新旧之分。而链路状态序列号、校验和、老化时间这三个字段就是为了判断LSA的“新鲜程度”。</p>
</blockquote>
<p>接下来我们以下面这个网络拓扑为基础，详细的介绍每种LSA。请注意，我们要讲的是一个LSU报文中的数据内容里的LSA内的数据部分；也就是默认剥离了LSU的包头，LSA的头部。（有点绕口，在看一下上面的图理解一下。）</p>
<p><img src= "/image/loading.gif" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/9d21f2b585b7bd9964316.png"></p>
<blockquote>
<p>设定R3为area 0的DR。</p>
</blockquote>
<h2 id="type-1-LSA"><a href="#type-1-LSA" class="headerlink" title="type-1 LSA"></a>type-1 LSA</h2><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><img src= "/image/loading.gif" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/653fc670928be51ea1a85.png" style="zoom: 80%;" />

<p>对于Router LSA，也就是type-1LSA，其LSA头部中的”链路状态类型“字段的值为1，”<strong>链路状态ID</strong>“字段的值为产生该LSA的路由器router-id。</p>
<p>除开LSA的头部信息，type-1 LSA包含的数据部分的内容（红框）如下：</p>
<blockquote>
<ul>
<li><p>**V 位(Virtual Link Endpoint Bit)**：如果该比特位被设置为 1，则表示该路由器为 Virtual Link（虚链路）的端点。 </p>
</li>
<li><p>**E 位(External Bit)**：如果 E 比特位被设置为 1，则表示该路由器为 ASBR。 在 Stub区域中，不允许出现E比特位被设置为1的Type-1 LSA，因此Stub区域内不允许出现ASBR。</p>
</li>
<li><p>**B 位(Border Bit)**：如果 B 比特位被设置为 1，则表示该路由器为两个区域的边界路由器（即使该路由器为连接Area0），字母 B 意为 Border(边界)。</p>
</li>
<li><p>**链路数量(Links Number)**：该 Type-1 LSA 所描述的 Link(链路)数量。 </p>
<p>我们已经知道每台路由器都会产生 Type-1 LSA，而且该 LSA 描述了路由器直连接口的状况和 Cost 值，实际上路由器正是采用包含在Type-1 LSA中的Link来描述直连接口的。</p>
<p> “链路数量”字段指明在该Type-1 LSA中，包含了几条Link。 每条Link均包含“链路类型”、 “链路ID” 、”链路数据”以及“度量值”这几个关键信息。 路由器可能会采用一个或者多个Link 来描述某个接口。 </p>
</li>
<li><p>**链路类型(Link Type)**：本条 Link 的类型值，该值与 Link 的类型相关。 OSPF定义了多种链路类型,这些链路类型与接口的网络类型也是有关的。下表中罗列了 OSPF 定义的各种链路类型及对应的链路ID、链路数据的描述。</p>
<table>
<thead>
<tr>
<th>链路类型</th>
<th>描述</th>
<th>链路ID</th>
<th>链路数据</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>点对点协议的方式<br />连接到另一台路由器</td>
<td>对端路由器的<br />router-id</td>
<td>产生该LSA的接口IP地址</td>
</tr>
<tr>
<td>2</td>
<td>多路访问的方式（比如以太网）<br />连接到一个传输网络</td>
<td>区域内DR的<br />接口IP地址</td>
<td>产生该LSA的接口IP地址</td>
</tr>
<tr>
<td>3</td>
<td>连接到一个末梢网络<br />（该接口没有连接其他OSPF路由器）</td>
<td>网络地址（网段）</td>
<td>子网掩码</td>
</tr>
<tr>
<td>4</td>
<td>虚链路</td>
<td>对端路由器的<br />router-id</td>
<td>产生该LSA的接口IP地址</td>
</tr>
</tbody></table>
</li>
<li><p>**链路ID(Link ID)**：Link 的标识,不同的链路类型,对链路 ID 值的定义是不同的。</p>
</li>
<li><p>**链路数据(Link Data)**：不同的链路类型对链路数据的定义是不同的。</p>
</li>
<li><p>**度量值(Metric)**：Cost 值。</p>
</li>
<li><p>TOS相关字段是ospf v1版本遗留下来的，为了做兼容，所以没有删除，目前已经不再使用了，因此可以忽略。（其他LSA内也有该字段，之后不再重复说明了）</p>
</li>
</ul>
</blockquote>
<h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>网络中的每台路由器都会产生type-1 LSA。</p>
<h4 id="以R1为例："><a href="#以R1为例：" class="headerlink" title="以R1为例："></a>以R1为例：</h4><p><img src= "/image/loading.gif" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/95f1b79af02d7815226e7.png"></p>
<p>其在GE0&#x2F;0&#x2F;0与GE0&#x2F;0&#x2F;1口启用了OSPF，因此它会产生一个用于描述这两个接口状况的type-1 LSA，并将该LSA泛洪到所在区域内。</p>
<ul>
<li><p>接口GE0&#x2F;0&#x2F;0连接的是以太网，ip为192.168.123.1&#x2F;24，该接口上有其他OSPF邻居（R2、R3）。因此描述该接口的关键信息为：链路类型&#x3D;2，链路ID&#x3D;192.168.123.3（R3为DR），链路数据&#x3D;192.168.123.1，度量值&#x3D;1（GE口表示千兆以太网）。</p>
</li>
<li><p>接口GE0&#x2F;0&#x2F;1连接的是以太网，ip为192.168.1.254&#x2F;24，该接口上没有其他OSPF邻居，属于一个末梢网络。因此描述该接口的关键信息为：链路类型&#x3D;3，链路ID&#x3D;192.168.1.0，链路数据&#x3D;255.255.255.0，度量值&#x3D;1（GE口表示千兆以太网）。</p>
</li>
<li><p>使用 <strong>display ospf Isdb router</strong> 命令可以查看 LSDB 中的 Type-1 LSA。</p>
<p>如果在该命令后再增加 <strong>originate-router</strong> 关键字则可以查看指定的 OSPF 路由器（填入router-id）产生的 Type-1 LSA。</p>
</li>
</ul>
<p>例如查看R1的type-1 LSA：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[R1]dis ospf lsdb router originate-router 1.1.1.1</span><br><span class="line"></span><br><span class="line">	 OSPF Process 1 with Router ID 1.1.1.1</span><br><span class="line">		         Area: 0.0.0.0</span><br><span class="line">		 Link State Database </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Type      : Router</span><br><span class="line">  Ls id     : 1.1.1.1</span><br><span class="line">  Adv rtr   : 1.1.1.1  </span><br><span class="line">  Ls age    : 0 </span><br><span class="line">  Len       : 48 </span><br><span class="line">  Options   :  E  </span><br><span class="line">  seq#      : 80000006 </span><br><span class="line">  chksum    : 0x19e3</span><br><span class="line">  Link count: 2</span><br><span class="line">   * Link ID: 192.168.123.3 </span><br><span class="line">     Data   : 192.168.123.1 </span><br><span class="line">     Link Type: TransNet     </span><br><span class="line">     Metric : 1</span><br><span class="line">   * Link ID: 192.168.1.0  </span><br><span class="line">     Data   : 255.255.255.0 </span><br><span class="line">     Link Type: StubNet      </span><br><span class="line">     Metric : 1 </span><br><span class="line">     Priority : Low</span><br></pre></td></tr></table></figure>

<p>可以看到其中包含了两条link，信息就是我们前面分析过的。</p>
<h4 id="以R3为例："><a href="#以R3为例：" class="headerlink" title="以R3为例："></a>以R3为例：</h4><p><img src= "/image/loading.gif" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/6289d5482ce798368cb00.png"></p>
<p>R3两个接口分别处于area0与area1，因为规定type-1 LSA只能在区域内传播，因此R3会产生两个type-1 LSA。</p>
<p>描述GE0&#x2F;0&#x2F;0接口的LSA在area0内传播，描述S1&#x2F;0&#x2F;0接口的LSA在area1内传播。</p>
<p>我们主要看area1的这个LSU报文，其中的LSA包含了两条link信息。</p>
<blockquote>
<p>其中一条link的链路类型&#x3D;1（表示点对点协议网络），链路ID&#x3D;4.4.4.4（对端路由器id），链路数据&#x3D;192.168.34.3（本端接口ip），度量值&#x3D;48（华为的串口默认速率计算过来就是48）。</p>
<p>另一条link的链路类型&#x3D;3，链路ID&#x3D;192.168.34.0，链路数据&#x3D;255.255.255.0，度量值&#x3D;48。</p>
</blockquote>
<p>之所以使用两条link信息来描述，是为了帮助其他路由器绘制网络拓扑：</p>
<blockquote>
<p>第一条link用于告诉该串口对端设备的id与ip地址，第二条link是告诉该链路的网段是多少。</p>
<p>第一条只能说明ip地址，缺少掩码去推导网段。</p>
<p>而如果只使用第二条又不能告诉其他路由器这是点对点通信链路。</p>
</blockquote>
<p>我们也查看一下R3的type-1 LSA详细信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[R3]dis ospf lsdb router originate-router o 3.3.3.3</span><br><span class="line"></span><br><span class="line">	 OSPF Process 1 with Router ID 3.3.3.3</span><br><span class="line">		         Area: 0.0.0.0</span><br><span class="line">		 Link State Database </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Type      : Router</span><br><span class="line">  Ls id     : 3.3.3.3</span><br><span class="line">  Adv rtr   : 3.3.3.3  </span><br><span class="line">  Ls age    : 68 </span><br><span class="line">  Len       : 36 </span><br><span class="line">  Options   :  ABR  E  </span><br><span class="line">  seq#      : 80000008 </span><br><span class="line">  chksum    : 0x7de5</span><br><span class="line">  Link count: 1</span><br><span class="line">   * Link ID: 192.168.123.3 </span><br><span class="line">     Data   : 192.168.123.3 </span><br><span class="line">     Link Type: TransNet     </span><br><span class="line">     Metric : 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		         Area: 0.0.0.1</span><br><span class="line">		 Link State Database </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Type      : Router</span><br><span class="line">  Ls id     : 3.3.3.3</span><br><span class="line">  Adv rtr   : 3.3.3.3  </span><br><span class="line">  Ls age    : 25 </span><br><span class="line">  Len       : 48 </span><br><span class="line">  Options   :  ABR  E  </span><br><span class="line">  seq#      : 80000002 </span><br><span class="line">  chksum    : 0x2878</span><br><span class="line">  Link count: 2</span><br><span class="line">   * Link ID: 4.4.4.4      </span><br><span class="line">     Data   : 192.168.34.3 </span><br><span class="line">     Link Type: P-2-P        </span><br><span class="line">     Metric : 48</span><br><span class="line">   * Link ID: 192.168.34.0 </span><br><span class="line">     Data   : 255.255.255.0 </span><br><span class="line">     Link Type: StubNet      </span><br><span class="line">     Metric : 48 </span><br><span class="line">     Priority : Low</span><br></pre></td></tr></table></figure>

<h2 id="type-2-LSA"><a href="#type-2-LSA" class="headerlink" title="type-2 LSA"></a>type-2 LSA</h2><p>在type-1 LSA中，描述传输网络的链路类型的link信息内仅含有接口ip地址，并没有子网掩码，也因此不知道有多少路由器是在同一网段上。</p>
<p>因此就需要使用到type-2 LSA了。</p>
<p>OSPF的机制里，每个网段的路由器都会自行选举DR，未成为DR的路由器与DR构建邻接关系，并且邻居建立过程中的hello报文就包含了子网掩码的信息。因此对于DR来说，它清楚自己所处的网段以及与它相连的所有同网段路由器的接口ip地址与router-id。</p>
<p>所以，直接规定type-2 LSA由DR来产生并通告出去。</p>
<blockquote>
<p>实际上，type-1的LSA也是经由DR来泛洪传播的。</p>
<p>R1的type-1LSA不会直接发给R2，而是发送给由身为DR的R3（使用224.0.0.6的组播地址）；之后R3与R2再进行LSA的更新（使用224.0.0.5的组播地址）。</p>
</blockquote>
<h3 id="报文格式-1"><a href="#报文格式-1" class="headerlink" title="报文格式"></a>报文格式</h3><img src= "/image/loading.gif" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/9e1687d25469a6ccaa167.png" style="zoom:80%;" />

<p>在Type-2 LSA中，LSA头部中的“链路状态类型”字段的值为2，<strong>“链路状态ID”字段的值为产生这个Type-2 LSA的DR的接口ip地址。</strong></p>
<p>除开LSA的头部信息，Type-2 LSA包含的数据部分的内容（红框）如下：</p>
<blockquote>
<ul>
<li><p>**网络掩码(Network Mask)**：该接口所连网络的网络掩码。</p>
</li>
<li><p><strong>相连的路由器(Attached Router)的 Router-ID</strong>：连接到该网络的路由器的 Router-ID。</p>
<p>如果有多台路由器接入该网络，则使用多个字段描述。(至少包含了DR 自己的 Router-ID、以及与该 DR 建立了邻接关系的邻居的 Router-ID)</p>
</li>
</ul>
</blockquote>
<p><strong>在OSPF中，因为使用的是组播地址，无法跨网段传输，所以每个网段都会选举DR。</strong></p>
<p><strong>因此仅需要在LSA头部信息里写明了该网段的DR的ip地址，再配合LSA数据部分的子网掩码，就可以得到网段了。</strong></p>
<h3 id="举例说明-1"><a href="#举例说明-1" class="headerlink" title="举例说明"></a>举例说明</h3><p>我们先给之前的拓扑多加一台R5：192.168.15.5 &#x2F;24 连接在R1右侧。</p>
<p>也就是说area0中存在了两个网段，而R1同时连接了这两个网段。</p>
<p><img src= "/image/loading.gif" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/7c0e0882b85b466188554.png"></p>
<p>这次我们先直接查看LSDB表跟邻居表，以R1为视角：</p>
<blockquote>
<p>在R1上输入<strong>display ospf peer</strong> 检查邻居信息。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[R1]display ospf peer </span><br><span class="line"></span><br><span class="line">	 OSPF Process 1 with Router ID 1.1.1.1</span><br><span class="line">		 Neighbors </span><br><span class="line"></span><br><span class="line"> Area 0.0.0.0 interface 192.168.123.1(GigabitEthernet0/0/0)&#x27;s neighbors</span><br><span class="line"> Router ID: 2.2.2.2          Address: 192.168.123.2   </span><br><span class="line">   State: Full  Mode:Nbr is  Master  Priority: 1</span><br><span class="line">   DR: 192.168.123.3  BDR: 192.168.123.2  MTU: 0    </span><br><span class="line">   Dead timer due in 36  sec </span><br><span class="line">   Retrans timer interval: 5 </span><br><span class="line">   Neighbor is up for 00:09:26     </span><br><span class="line">   Authentication Sequence: [ 0 ] </span><br><span class="line"></span><br><span class="line"> Router ID: 3.3.3.3          Address: 192.168.123.3   </span><br><span class="line">   State: Full  Mode:Nbr is  Master  Priority: 1</span><br><span class="line">   DR: 192.168.123.3  BDR: 192.168.123.2  MTU: 0    </span><br><span class="line">   Dead timer due in 38  sec </span><br><span class="line">   Retrans timer interval: 0 </span><br><span class="line">   Neighbor is up for 00:09:30     </span><br><span class="line">   Authentication Sequence: [ 0 ] </span><br><span class="line"></span><br><span class="line">		 Neighbors </span><br><span class="line"></span><br><span class="line"> Area 0.0.0.0 interface 192.168.15.1(GigabitEthernet0/0/2)&#x27;s neighbors</span><br><span class="line"> Router ID: 5.5.5.5          Address: 192.168.15.5    </span><br><span class="line">   State: Full  Mode:Nbr is  Master  Priority: 1</span><br><span class="line">   DR: 192.168.15.5  BDR: 192.168.15.1  MTU: 0    </span><br><span class="line">   Dead timer due in 37  sec </span><br><span class="line">   Retrans timer interval: 5 </span><br><span class="line">   Neighbor is up for 00:09:26     </span><br><span class="line">   Authentication Sequence: [ 0 ] </span><br></pre></td></tr></table></figure>

<p>可以看到R1邻居信息中分了两块【Neighbors 】：</p>
<ul>
<li>第一块里内容是R2与R3，其中DR: 192.168.123.3  BDR: 192.168.123.2。</li>
<li>第二块内容是R5，其中DR: 192.168.15.5  BDR: 192.168.15.1</li>
</ul>
<blockquote>
<p>查看type-2 LSA的命令为<strong>display ospf lsdb network</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[R1]display ospf lsdb network </span><br><span class="line"></span><br><span class="line">	 OSPF Process 1 with Router ID 1.1.1.1</span><br><span class="line">		         Area: 0.0.0.0</span><br><span class="line">		 Link State Database </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Type      : Network</span><br><span class="line">  Ls id     : 192.168.123.3</span><br><span class="line">  Adv rtr   : 3.3.3.3  </span><br><span class="line">  Ls age    : 380 </span><br><span class="line">  Len       : 36 </span><br><span class="line">  Options   :  E  </span><br><span class="line">  seq#      : 80000004 </span><br><span class="line">  chksum    : 0x281f</span><br><span class="line">  Net mask  : 255.255.255.0</span><br><span class="line">  Priority  : Low</span><br><span class="line">     Attached Router    3.3.3.3</span><br><span class="line">     Attached Router    1.1.1.1</span><br><span class="line">     Attached Router    2.2.2.2</span><br><span class="line"></span><br><span class="line">  Type      : Network</span><br><span class="line">  Ls id     : 192.168.15.5</span><br><span class="line">  Adv rtr   : 5.5.5.5  </span><br><span class="line">  Ls age    : 370 </span><br><span class="line">  Len       : 32 </span><br><span class="line">  Options   :  E  </span><br><span class="line">  seq#      : 80000007 </span><br><span class="line">  chksum    : 0x3278</span><br><span class="line">  Net mask  : 255.255.255.0</span><br><span class="line">  Priority  : Low</span><br><span class="line">     Attached Router    5.5.5.5</span><br><span class="line">     Attached Router    1.1.1.1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为存在两个DR，所以有两条type-2 LSA。</p>
<p>以第一条为例：</p>
<ul>
<li><p>Ls id : 192.168.123.3 —— 描述的该网段的DR的ip地址。</p>
</li>
<li><p>Net mask : 255.255.255.0 —— 描述该网段的子网掩码，配合上一条的ip地址即可得到网段地址。</p>
</li>
<li><p>Attached Router    3.3.3.3</p>
<p>Attached Router    1.1.1.1</p>
<p>Attached Router    2.2.2.2 —— 该网段内的ospf路由器的router-id。</p>
</li>
</ul>
<p>得益于type-1与type-2 LSA在区域内泛洪，区域内的路由器LSDB表都是完全一致的，OSPF路由器就能够描绘一个区域内的完整拓扑，并发现各个网段，最终准确的计算出到达各个网段的最佳路径。</p>
<h2 id="type-3-LSA"><a href="#type-3-LSA" class="headerlink" title="type-3 LSA"></a>type-3 LSA</h2><p>type-1与type-2解决了区域内的路由器计算，而要实现区域间路由的传递，就必须借助type-3 LSA。</p>
<p>type-3 LSA是为了解决区域间的路由问题，那么自然是由处于区域间的ABR来产生。</p>
<h3 id="报文格式-2"><a href="#报文格式-2" class="headerlink" title="报文格式"></a>报文格式</h3><blockquote>
<p>不再用红框标注了，深色的为固定的LSA头部，浅色的为指定类型的LSA内容。</p>
<p>同样的，非必要不会在附上LSA的简述拓扑图，相信经过两个LSA的讲解，应该能理解怎么看LSDB表里LSA信息。</p>
</blockquote>
<p>type-3 LSA是对区域内的type-1与type-2进行汇总归纳的LSA，其报文格式如下：</p>
<img src= "/image/loading.gif" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/83715f493faccd333dbd6.png" style="zoom:80%;" />

<p>在Type-3 LSA中，”<strong>链路状态ID</strong>”字段的值为区域间路由的<strong>目的网络地址</strong>，其他字段及其含义如下。</p>
<blockquote>
<ul>
<li>**网络掩码(Netmask)**：区域间路由的目的网络掩码。</li>
<li>**度量值(Metric)**：路由的 Cost。</li>
</ul>
</blockquote>
<h3 id="举例说明-2"><a href="#举例说明-2" class="headerlink" title="举例说明"></a>举例说明</h3><p>以R3为例，检查其LSDB中的type-3 LSA：</p>
<blockquote>
<p>命令：<strong>display ospf lsdb summary</strong> </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">[R3]display ospf lsdb summary </span><br><span class="line"></span><br><span class="line">	 OSPF Process 1 with Router ID 3.3.3.3</span><br><span class="line">	 </span><br><span class="line">		         Area: 0.0.0.0</span><br><span class="line">		 Link State Database </span><br><span class="line"></span><br><span class="line">  Type      : Sum-Net</span><br><span class="line">  Ls id     : 192.168.34.0</span><br><span class="line">  Adv rtr   : 3.3.3.3  </span><br><span class="line">  Ls age    : 21 </span><br><span class="line">  Len       : 28 </span><br><span class="line">  Options   :  E  </span><br><span class="line">  seq#      : 80000001 </span><br><span class="line">  chksum    : 0xc9cb</span><br><span class="line">  Net mask  : 255.255.255.0</span><br><span class="line">  Tos 0  metric: 48</span><br><span class="line">  Priority  : Low</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">		         Area: 0.0.0.1</span><br><span class="line">		 Link State Database </span><br><span class="line"></span><br><span class="line">  Type      : Sum-Net</span><br><span class="line">  Ls id     : 192.168.123.0</span><br><span class="line">  Adv rtr   : 3.3.3.3  </span><br><span class="line">  Ls age    : 21 </span><br><span class="line">  Len       : 28 </span><br><span class="line">  Options   :  E  </span><br><span class="line">  seq#      : 80000001 </span><br><span class="line">  chksum    : 0x1b50</span><br><span class="line">  Net mask  : 255.255.255.0</span><br><span class="line">  Tos 0  metric: 1</span><br><span class="line">  Priority  : Low</span><br><span class="line"></span><br><span class="line">  Type      : Sum-Net</span><br><span class="line">  Ls id     : 192.168.15.0</span><br><span class="line">  Adv rtr   : 3.3.3.3  </span><br><span class="line">  Ls age    : 21 </span><br><span class="line">  Len       : 28 </span><br><span class="line">  Options   :  E  </span><br><span class="line">  seq#      : 80000001 </span><br><span class="line">  chksum    : 0xcd09</span><br><span class="line">  Net mask  : 255.255.255.0</span><br><span class="line">  Tos 0  metric: 2</span><br><span class="line">  Priority  : Low</span><br><span class="line"></span><br><span class="line">  Type      : Sum-Net</span><br><span class="line">  Ls id     : 192.168.2.0</span><br><span class="line">  Adv rtr   : 3.3.3.3  </span><br><span class="line">  Ls age    : 23 </span><br><span class="line">  Len       : 28 </span><br><span class="line">  Options   :  E  </span><br><span class="line">  seq#      : 80000001 </span><br><span class="line">  chksum    : 0x5d86</span><br><span class="line">  Net mask  : 255.255.255.0</span><br><span class="line">  Tos 0  metric: 2</span><br><span class="line">  Priority  : Low</span><br><span class="line"></span><br><span class="line">  Type      : Sum-Net</span><br><span class="line">  Ls id     : 192.168.1.0</span><br><span class="line">  Adv rtr   : 3.3.3.3  </span><br><span class="line">  Ls age    : 26 </span><br><span class="line">  Len       : 28 </span><br><span class="line">  Options   :  E  </span><br><span class="line">  seq#      : 80000001 </span><br><span class="line">  chksum    : 0x687c</span><br><span class="line">  Net mask  : 255.255.255.0</span><br><span class="line">  Tos 0  metric: 2</span><br><span class="line">  Priority  : Low</span><br></pre></td></tr></table></figure>

<p>总结下来，R3往area0发送了一条type-3 LSA，用于描述area1里 R3-R4所处的网段。</p>
<p>R3往area1发送了4条type-3 LSA，用于描述area0里的4个网段。</p>
<p>值得注意的是，R3在发布type-3 LSA时，会附加上自己到达该网段的cost值（表中的“Tos 0  metric”字段）。</p>
<p>例如到达192.168.34.0是48，到达192.168.123.0是1，到达其他三个网段是2（需要经过两条千兆链路，1+1&#x3D;2，交换机处不计算，因为对于ospf来说它感知不到经过了交换机以及经过了多少台交换机）</p>
<blockquote>
<p>虽然说是多条LSA，但我们回顾一下LSU的报文格式。一条LSU报文内可以包含多条LSA，所以实际不等于路由器真的发了多条数据包。</p>
<img src= "/image/loading.gif" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/627a02faee9f1cd93d917.png" style="zoom:80%;" />
</blockquote>
<p>基于type-1、type-2、type-3 LSA，一个OSPF网络内所有的路由器就都可以互相访问了。（只要配置符合ospf的规则）</p>
<h3 id="type-3-LSA的防环机制"><a href="#type-3-LSA的防环机制" class="headerlink" title="type-3 LSA的防环机制"></a>type-3 LSA的防环机制</h3><p>type-3 LSA内的信息，我们可以提取为ABR的router-id、目标网段、目标网段的掩码、cost值。对于收到该LSA的路由器来说，它能明白的就是前往该目标网段的下一跳是router-id为多少的路由器。</p>
<p>这么一说，你可能发现了，这和RIP协议非常相似——将自己路由表内的路由信息发送给邻居，下一跳会设置为自己。</p>
<p>因此，使用type-3 LSA是存在与RIP相似的“环路”隐患。</p>
<p>为此，ospf“借鉴”了RIP的“水平分割”——ABR只能将自己所连接的区域内路由通告给area0，而不能将从其他区域学习到路由再通告给area0。</p>
<h2 id="type-4、type-5-LSA"><a href="#type-4、type-5-LSA" class="headerlink" title="type-4、type-5 LSA"></a>type-4、type-5 LSA</h2><p>我认为这两强相关的LSA放一起比较合适。</p>
<h3 id="以新拓扑分析描述"><a href="#以新拓扑分析描述" class="headerlink" title="以新拓扑分析描述"></a>以新拓扑分析描述</h3><p>让我们更新一下网络拓扑——让R4接入一个RIP网络中。(右上角)</p>
<p><img src= "/image/loading.gif" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/a71783268130ad8709f5e.png"></p>
<p>显然，对于ospf网络中的路由器来说，它们并没有前往RIP网络的路由。</p>
<p>这时就需要R4将RIP的路由引入到ospf网络中，当我们在R4上执行引入路由的操作后，R4就认为自己是一台ASBR。</p>
<p>身为ASBR的R4会基于协议要求，会产生描述到达RIP网络的type-5 LSA。</p>
<p>该LSA经过路由器之间的LSU报文最终传遍ospf网络内的所有路由器，使得它们能知道前往RIP网络要经过R4。</p>
<p>但是对于area0区域的ospf路由器来说，它们仅拥有前往area1区域的type-3 LSA，而没有精准到达R4的LSA信息，因此它们还是无法路由到RIP网络。</p>
<p>对于R3来说，它与R4同属于area1，基于type-1 LSA，它清楚到达R4的路由。</p>
<p>因此ospf里规定了，同属一个区域的ABR（也就是R3），需要产生一条type-4 LSA，用于描述到达ASBR（也就是R4）的路由。</p>
<p>type-4 LSA会像type-5 LSA一样传遍所有路由器，结合起来，使其他路由器都能路由到RIP网络。</p>
<h3 id="type-5-LSA"><a href="#type-5-LSA" class="headerlink" title="type-5 LSA"></a>type-5 LSA</h3><p>接下来我们就实际验证一下，首先我们在R4上进行路由引入，并检查type-5 LSA：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[R4]ospf 1</span><br><span class="line">[R4-ospf-1]import-route rip 1</span><br><span class="line">[R4-ospf-1]display ospf lsdb ase</span><br><span class="line"></span><br><span class="line">	 OSPF Process 1 with Router ID 4.4.4.4</span><br><span class="line">		 Link State Database</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Type      : External</span><br><span class="line">  Ls id     : 192.168.78.0</span><br><span class="line">  Adv rtr   : 4.4.4.4  </span><br><span class="line">  Ls age    : 196 </span><br><span class="line">  Len       : 36 </span><br><span class="line">  Options   :  E  </span><br><span class="line">  seq#      : 80000001 </span><br><span class="line">  chksum    : 0x7791</span><br><span class="line">  Net mask  : 255.255.255.0 </span><br><span class="line">  TOS 0  Metric: 1 </span><br><span class="line">  E type    : 2</span><br><span class="line">  Forwarding Address : 0.0.0.0 </span><br><span class="line">  Tag       : 1 </span><br><span class="line">  Priority  : Low</span><br><span class="line"></span><br><span class="line">  Type      : External</span><br><span class="line">  Ls id     : 192.168.47.0</span><br><span class="line">  Adv rtr   : 4.4.4.4  </span><br><span class="line">  Ls age    : 196 </span><br><span class="line">  Len       : 36 </span><br><span class="line">  Options   :  E  </span><br><span class="line">  seq#      : 80000001 </span><br><span class="line">  chksum    : 0xcd5a</span><br><span class="line">  Net mask  : 255.255.255.0 </span><br><span class="line">  TOS 0  Metric: 1 </span><br><span class="line">  E type    : 2</span><br><span class="line">  Forwarding Address : 0.0.0.0 </span><br><span class="line">  Tag       : 1 </span><br><span class="line">  Priority  : Low</span><br></pre></td></tr></table></figure>

<p>RIP网络中192.168.78.0&#x2F;24与192.168.47.0&#x2F;24两个网段都描述出来了。</p>
<p>看的出来其报文格式应该就是：</p>
<img src= "/image/loading.gif" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/446418aceb0bc687f49fa.png" style="zoom:80%;" />

<p>对于Type-5 LSA， <strong>“链路状态ID”</strong>字段的值是<strong>外部路由的目的网络地址</strong>。其他主要字段的描述如下。</p>
<blockquote>
<ul>
<li>网络掩码(Netmask)：外部路由的目的网络掩码。</li>
<li>E 位：用于表示该外部路由使用的度量值类型。OSPF 定义了两种外部路由度量值类型，分别是 Metric-Type-1 和 Metric-Type-2。值为0表示Metric-Type-1，1表示Metric-Type-2。关于这两种度量值类型的区别，本文将在后续小节中阐述。</li>
<li>度量值(Metric)：该外部路由的Cost。</li>
<li>转发地址(Forwarding Address， FA)：<strong>当 FA 为 0.0.0.0 时，则到达该外部网段的流量会被发往引入这条外部路由的ASBR</strong>(即LSA头部的通告路由器)。而如果FA不为0.0.0.0,则流量会被发往这个转发地址。</li>
<li>外部路由标记(External Route Tag)：这是一个只有外部路由才能够携带的标记，常被用于部署路由策略。</li>
</ul>
</blockquote>
<p>我们再抓个包看一下，都没直接抓过OSPF报文呢。这是在交换机处抓到的R3发送出来的OSPF报文：</p>
<img src= "/image/loading.gif" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/11125548e2d7a42510d1e.png" style="zoom: 50%;" />

<p>这是一个OSPF报文，在这个OSPF报文中是LSU报文信息，LSU内包含了两条type-5 LSA。至于内容就不重复讲了。</p>
<h3 id="type-4-LSA"><a href="#type-4-LSA" class="headerlink" title="type-4 LSA"></a>type-4 LSA</h3><p>在type-5 LSA内是描述了外部路由，以及发现该外部路由的路由器的router-id。</p>
<p>对于R1来说，它并不知道4.4.4.4这个router-id是谁——指示router-id的LSA是type-1 LSA，而type-1 LSA是不能跨区域的。</p>
<p>我们也可以直接使用<strong>display ospf peer</strong>命令查看R1的邻居表，也是找不到4.4.4.4的。</p>
<p>因此需要有人去发布type-4 LSA来告知area0区域内的路由器4.4.4.4这个路由器在哪。</p>
<p>我们在R1上去检查下type-4 LSA：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[R1]display ospf lsdb asbr</span><br><span class="line"></span><br><span class="line">	 OSPF Process 1 with Router ID 1.1.1.1</span><br><span class="line">		         Area: 0.0.0.0</span><br><span class="line">		 Link State Database </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Type      : Sum-Asbr</span><br><span class="line">  Ls id     : 4.4.4.4</span><br><span class="line">  Adv rtr   : 3.3.3.3  </span><br><span class="line">  Ls age    : 458 </span><br><span class="line">  Len       : 28 </span><br><span class="line">  Options   :  E  </span><br><span class="line">  seq#      : 80000001 </span><br><span class="line">  chksum    : 0x2ce3</span><br><span class="line">  Tos 0  metric: 48</span><br></pre></td></tr></table></figure>

<p>可以看到标识了4.4.4.4，以及发现者3.3.3.3。也就是说要去找4.4.4.4这个路由器，可以让3.3.3.3代劳。</p>
<p>我们也抓个包看看，这次我两个报文一起放出来，R3会发布两条OSPF报文，一条是通告type-5 LSA的，另一条是通告type-4 LSA的：</p>
<img src= "/image/loading.gif" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/2a2ed4493733fc78c71e6.png" style="zoom:50%;" />

<p>实际上type-4 LSA的报文结构就是type-3 LSA的结构，只不过链路状态ID填写为ASBR的router-id，且子网掩码字段的值填为0。</p>
<h2 id="type-7-LSA"><a href="#type-7-LSA" class="headerlink" title="type-7 LSA"></a>type-7 LSA</h2><p>type-7 LSA是用于NSSA *(Not-So-Stubby Area，非完全末梢区域)*内的一种特殊LSA。</p>
<p>在stub区域内是禁止type-4与type-5 LSA的(包括自己本区域自主产生也是禁止的)。</p>
<p>如果想要仅拒绝其他区域传外部路由进入，但不妨碍自己本区域传外部路由出去，那么就可以配置该stub区域为NSSA。</p>
<p>在NSSA中，启用了type-7 LSA用于代替type -5 LSA。</p>
<p>也因此，作为代替品的type-7 LSA仅出现在NSSA中，该type-7 LSA在ABR处会被转化为type-5 LSA，再发布给其他区域。</p>
<p>同时，正因为是用于代替type-5 LSA的，所以type-7 LSA的报文格式与type-5 LSA一样，仅仅是链路类型从5改成了7。</p>
<h3 id="再更新一遍拓扑，介绍type-7-LSA的原理"><a href="#再更新一遍拓扑，介绍type-7-LSA的原理" class="headerlink" title="再更新一遍拓扑，介绍type-7 LSA的原理"></a>再更新一遍拓扑，介绍type-7 LSA的原理</h3><p>让我们最后一次修改一下拓扑——将RIP网络删除，改为R4下直连了一个网段192.168.4.0 &#x2F;24，同时将area1配置为NSSA。</p>
<img src= "/image/loading.gif" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/7d9ddc5bd5fa46ea0bb47.png" style="zoom: 50%;" />

<p>NSSA的配置需要在待修改区域的所有路由器上进行，因此在R3与R4配置如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[R3]ospf 1</span><br><span class="line">[R3-ospf-1]area 1</span><br><span class="line">[R3-ospf-1-area-0.0.0.1]nssa</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[R4]ospf 1</span><br><span class="line">[R4-ospf-1]area 1</span><br><span class="line">[R4-ospf-1-area-0.0.0.1]nssa</span><br></pre></td></tr></table></figure>



<p>现在，让我们在R4上配置引入外部路由（此处为直连路由）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[R4-ospf-1-area-0.0.0.1]quit </span><br><span class="line">[R4-ospf-1]import-route direct </span><br></pre></td></tr></table></figure>

<blockquote>
<p>区域视图下是无法引入路由的，要退回到ospf进程视图下。</p>
</blockquote>
<p>这时让我们看下刚刚在area1的串口链路上抓到的包：</p>
<img src= "/image/loading.gif" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/684bcf3a3125614f1c711.png" style="zoom: 50%;" />

<blockquote>
<p>LSA类型为7，链路状态ID为引入的192.168.4.0&#x2F;24网段。（眼尖的会看到LSA数量为3，只是因为直接导入了直连路由，所以包括192.168.34.0&#x2F;24也引入进去了）</p>
</blockquote>
<p>再看一下R3发布到area0的LSA：</p>
<img src= "/image/loading.gif" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/b41e61b5427f78b40bdc6.png" style="zoom:50%;" />

<blockquote>
<p>LSA类型为3，网段依旧是192.168.4.0&#x2F;24，不过通告路由器改为了3.3.3.3。</p>
</blockquote>
<h1 id="基础配置命令与解决方案"><a href="#基础配置命令与解决方案" class="headerlink" title="基础配置命令与解决方案"></a>基础配置命令与解决方案</h1><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><h3 id="启用OSPF"><a href="#启用OSPF" class="headerlink" title="启用OSPF"></a>启用OSPF</h3><ol>
<li><p>执行命令<strong>system-view</strong>，进入系统视图。</p>
</li>
<li><p>执行命令<strong>ospf</strong> [ <em>process-id</em> | <strong>router-id</strong> <em>router-id</em> ] ，创建并进入OSPF进程视图。</p>
<p>第一个可选参数为进程id，默认为1。该进程id仅作用于本地，也就是说两台配置进同一个ospf网络的路由器可以进程名不一样。</p>
<p>第二个可选参数为手动配置router-id，默认使用本地上配置的最大的ip地址。手动配置Router ID时，必须保证任意两台路由器的router-id不相同。<strong>router-id也可以在创建ospf进程之前配置。</strong></p>
</li>
<li><p>执行命令<strong>area</strong> <em>area-id</em>，进入OSPF区域视图。</p>
</li>
<li><p>执行命令<strong>network</strong> <em>ip-address</em> <em>wildcard-mask</em>，在OSPF区域中配置包含的网段，属于该网段的接口会自动启用OSPF功能。第二个参数配置的为通配符，而不是子网掩码。</p>
<p>通配符掩码中，0表示要检查的位，1表示不需要检查的位。如果不理解，可以当作是“反掩码”，比如通配符的0.0.0.255可以理解位子网掩码的255.255.255.0。</p>
<p>不过严谨来说，它并不是直接指示网络位与主机位的。举个例子，通配符可以写成0.0.0.254，这个通配符不仅表示了&#x2F;24的子网，还可以筛选单数或者双数。（如果哪天发现了ip地址双数的能上网，单数的上不了网，记得去检查是不是哪里的通配符打错成254了）</p>
<p>”宣告“也只是指定设备上的什么接口开启ospf功能加入该进程该区域（接口的ip地址符合宣告的规则）。</p>
<p>如果计划宣告的接口不多，其实我们可以直接以 <em>接口的ip地址</em> + <em>通配符0.0.0.0</em> 来直接指定单个接口。</p>
<blockquote>
<p>通配符0.0.0.0即表示严格匹配前者，而前者填写为接口的ip地址，即为直接指定该接口。</p>
</blockquote>
</li>
</ol>
<h3 id="引入外部路由"><a href="#引入外部路由" class="headerlink" title="引入外部路由"></a>引入外部路由</h3><ol>
<li>执行命令<strong>system-view</strong>，进入系统视图。</li>
<li>执行命令<strong>ospf</strong>，进入OSPF进程视图。</li>
<li>执行命令<strong>import-route</strong> { <strong>bgp</strong> [ <strong>permit-ibgp</strong> ] | <strong>direct</strong> | <strong>unr</strong> | <strong>rip</strong> [ <em>process-id-rip</em> ] | <strong>static</strong> | <strong>isis</strong> [ <em>process-id-isis</em> ] | <strong>ospf</strong> [ <em>process-id-ospf</em> ] } [ <strong>cost</strong> <em>cost</em> | <strong>type</strong> <em>type</em> | <strong>tag</strong> <em>tag</em> | <strong>route-policy</strong> <em>route-policy-name</em> ]，引入其它协议的路由信息。<ul>
<li>[ <strong>cost</strong> <em>cost</em> | <strong>type</strong> <em>type</em> | <strong>tag</strong> <em>tag</em> | <strong>route-policy</strong> <em>route-policy-name</em> ] 这一段是可选对引入的外部路由进行一些自定义——cost值，类型，标记，路由策略。</li>
</ul>
</li>
</ol>
<h3 id="检查配置"><a href="#检查配置" class="headerlink" title="检查配置"></a>检查配置</h3><ul>
<li>在任意视图下执行<strong>display ospf</strong> [ <em>process-id</em> ] <strong>peer</strong>命令，查看指定OSPF进程的邻居信息。</li>
<li>在任意视图下执行<strong>display ospf</strong> [ <em>process-id</em> ] <strong>interface</strong>命令，查看指定OSPF进程的接口信息。</li>
<li>在任意视图下执行<strong>display ospf</strong> [ <em>process-id</em> ] <strong>routing</strong>命令，查看指定OSPF进程的路由表信息。</li>
<li>在任意视图下执行<strong>display ospf</strong> [ <em>process-id</em> ] <strong>lsdb</strong>命令，查看指定OSPF进程的LSDB信息。</li>
</ul>
<h2 id="路由汇总与默认路由"><a href="#路由汇总与默认路由" class="headerlink" title="路由汇总与默认路由"></a>路由汇总与默认路由</h2><h3 id="路由汇总"><a href="#路由汇总" class="headerlink" title="路由汇总"></a>路由汇总</h3><p>ABR向其它区域发送路由信息时，以网段为单位生成Type3 LSA。</p>
<p>当区域中存在连续的网段（具有相同前缀的路由信息）时，可以通过<strong>abr-summary</strong>命令将这些网段聚合成一个网段。</p>
<p>ABR<strong>向其他区域只发送一条聚合后的LSA</strong>（对于自己本身依旧保持原有的LSA），所有指定的聚合网段范围的LSA将不会再被单独发送。</p>
<p>从而有效减少路由表中的条目，减小对系统资源的占用，不影响系统的性能。</p>
<ul>
<li><p>配置ABR路由聚合</p>
<ol>
<li>执行命令<strong>system-view</strong>，进入系统视图。</li>
<li>执行命令<strong>ospf</strong> [ <em>process-id</em> ]，进入OSPF进程视图。</li>
<li>执行命令<strong>area</strong> <em>area-id</em>，进入OSPF区域视图。</li>
<li>执行命令<strong>abr-summary</strong> <em>ip-address</em> <em>mask</em>  [ <strong>cost</strong> { <em>cost</em> | <strong>inherit-minimum</strong> }  ] ，配置OSPF的ABR路由聚合。</li>
</ol>
</li>
<li><p>配置ASBR路由聚合</p>
<ol>
<li>执行命令<strong>system-view</strong>，进入系统视图。</li>
<li>执行命令<strong>ospf</strong> [ <em>process-id</em> ]，进入OSPF进程视图。</li>
<li>执行命令<strong>asbr-summary</strong> <em>ip-address</em> <em>mask</em> [ <strong>cost</strong> <em>cost</em> |  <strong>tag</strong> <em>tag</em>  ] ，配置OSPF的ASBR路由聚合。</li>
</ol>
</li>
</ul>
<h3 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h3><p>为了减少路由表的容量，还可以配置引入默认路由，保证网络的高可用性。</p>
<ul>
<li><p>配置OSPF将默认路由通告到OSPF路由区域</p>
<ol>
<li><p>执行命令<strong>system-view</strong>，进入系统视图。</p>
</li>
<li><p>执行命令<strong>ospf</strong> [ <em>process-id</em> ]，进入OSPF进程视图。</p>
</li>
<li><p>执行命令<strong>default-route-advertise</strong> [ [ <strong>always</strong> | <strong>permit-calculate-other</strong> ] | <strong>cost</strong> <em>cost</em> | <strong>type</strong> <em>type</em> | <strong>route-policy</strong> <em>route-policy-name</em> [ <strong>match-any</strong> ] ] ，将默认路由通告到OSPF路由区域。</p>
<p><strong>always</strong>表示无论本机是否存在激活的非本OSPF进程的默认路由，都会产生并发布一个描述默认路由的LSA。</p>
<p><strong>permit-calculate-other</strong>表示在发布默认路由后，仍允许计算其他路由器发布的默认路由。</p>
</li>
</ol>
</li>
</ul>
<h2 id="虚链路（Virtual-link）"><a href="#虚链路（Virtual-link）" class="headerlink" title="虚链路（Virtual link）"></a>虚链路（Virtual link）</h2><p>OSPF里规定了所有区域都必须与骨干区域area0相连，否则LSA的泛洪就会出现问题，非直连区域会成为“孤岛”。</p>
<p>一般来说，我们都是要区域重新划分，保证区域直连area0。</p>
<p>但现网中，有的时候条件并不允许，无法重新规划为直连area0。</p>
<p>这时就可以考虑一种临时方案——虚链路。</p>
<p>虚链路是指在逻辑上虚拟出一条链路，使得该链路两台的设备能直接通信，直接尝试构建邻接关系。</p>
<p>而虚链路本身是承载在先有物理链路上的，我们可以理解为套娃、套壳。</p>
<p>使用虚链路让区域内一台路由器“直连”到area0里，该路由器则作为ABR负责该区域的LSA汇总。</p>
<p><strong>操作步骤</strong></p>
<ol>
<li><p>执行命令<strong>system-view</strong>，进入系统视图。</p>
</li>
<li><p>执行命令<strong>ospf</strong> [ <em>process-id</em> ]，进入OSPF进程视图。</p>
</li>
<li><p>执行命令<strong>area</strong> <em>area-id</em>，进入OSPF区域视图。</p>
</li>
<li><p>执行命令<strong>vlink-peer</strong> <em>router-id</em> [ <strong>smart-discover</strong> | <strong>hello</strong> <em>hello-interval</em> | <strong>retransmit</strong> <em>retransmit-interval</em> | <strong>trans-delay</strong> <em>trans-delay-interval</em> | <strong>dead</strong> <em>dead-interval</em> | [ <strong>simple</strong> [ <strong>plain</strong> <em>plain-text</em> | [ <strong>cipher</strong> ] <em>cipher-text</em> ] | { <strong>md5</strong> | <strong>hmac-md5</strong> | <strong>hmac-sha256</strong> } [ <em>key-id</em> { <strong>plain</strong> <em>plain-text</em> | [ <strong>cipher</strong> ] <em>cipher-text</em> } ] | <strong>authentication-null</strong> | <strong>keychain</strong> <em>keychain-name</em> ] ] ，创建到达指定路由器的虚连接。</p>
<p><strong>在另一端的路由器上也需要配置此命令。</strong></p>
</li>
</ol>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="OSPF邻居建立不起来？"><a href="#OSPF邻居建立不起来？" class="headerlink" title="OSPF邻居建立不起来？"></a>OSPF邻居建立不起来？</h2><p>以下各项的答案为“是”，才是正常的。</p>
<blockquote>
<p>实际本质就是两端的hello报文能互相发送给对方，并且hello报文内信息除了标识router-id要不同以外，其他的信息需要一样。</p>
</blockquote>
<ol>
<li><p><strong>检查邻居两端的接口物理和协议状态是否UP，状态是否稳定，接口是否不丢包，两边互ping大包是否能通。</strong></p>
<blockquote>
<p>若物理接口不Up或是不稳定（有振荡现象），请排查物理链路和链路层协议，确保物理和协议状态都是Up，并且接口无错误计数。</p>
<p>可以通过ping测试，长ping测试是否存在丢包现象，ping大包（1500字节以上）测试是否存在大包不通的现象。</p>
</blockquote>
</li>
<li><p><strong>检查链路两端OSPF进程的Router ID是否唯一。</strong></p>
<blockquote>
<p>分别在链路两端的设备上执行命令<strong>display ospf</strong> [ <em>process-id</em> ] <strong>brief</strong>，查看OSPF进程的Router ID。</p>
<p>RouterID尽量保证全网唯一，否则有可能邻居不能正常建立、路由信息不正确的问题。建议在设备上单独为每个OSPF进程配置全网唯一的Router ID。</p>
<p>如果链路两端OSPF进程的Router ID冲突，请在系统视图下执行命令<strong>ospf</strong> [ <em>process-id</em> ] <strong>router-id</strong> <em>router-id</em>，修改OSPF进程的Router ID以保证不冲突。</p>
<p>修改OSPF进程的Router ID之后，必须在用户视图下执行命令<strong>reset ospf</strong>[ <em>process-id</em> ] <strong>process</strong>重启进程后，新配置的Router ID才会生效。</p>
</blockquote>
</li>
<li><p><strong>检查链路两端OSPF区域ID是否一致。</strong></p>
<blockquote>
<p>分别在链路两端的设备上执行命令<strong>display ospf</strong> [ <em>process-id</em> ] <strong>brief</strong>，查看OSPF的区域ID。</p>
<p>如果链路两端的OSPF区域ID不一致，请在OSPF视图下执行命令<strong>area</strong> <em>area-id</em>，修改OSPF区域ID以保证一致。</p>
</blockquote>
</li>
<li><p><strong>检查链接两端OSPF接口的网络类型是否一致。</strong></p>
<blockquote>
<p>分别在链路两端的设备上执行命令<strong>display ospf</strong> [ <em>process-id</em> ] <strong>interface</strong>，查看OSPF接口的接口类型。</p>
<p>一般情况下，链路两端的OSPF接口的网络类型必须一致，否则双方不能正常建立起OSPF邻居关系。</p>
<ul>
<li>当链路两端的OSPF接口的网络类型一端是广播网（以太网）而另一端是P2P时，双方仍可以正常的建立起邻居关系，但互相学不到路由信息。</li>
<li>当链路两端的OSPF接口的网络类型一端是P2MP而另一端是P2P时，双方仍可以正常的建立起邻居关系，但互相学不到路由信息。为了相互学到路由信息，此时需要在链路两端的OSPF接口上配置相同的Hello报文发送间隔和邻居失效时间。</li>
</ul>
<p>如果OSPF接口的网络类型不一致，请在运行OSPF协议的接口视图下执行命令<strong>ospf network-type</strong> { <strong>broadcast</strong> | <strong>nbma</strong> | <strong>p2mp</strong> | <strong>p2p</strong> }，修改OSPF接口的网络类型以保证一致。</p>
<p>如果链路两端OSPF接口的网络类型都是NBMA，则必须在OSPF视图下执行命令<strong>peer</strong> <em>ip-address</em> [ <strong>dr-priority</strong> <em>priority</em> ]，配置NBMA网络的OSPF邻居。</p>
</blockquote>
</li>
<li><p><strong>检查链路两端OSPF接口的IP地址的掩码是否一致。</strong></p>
<blockquote>
<p>分别在链路两端的设备上执行命令<strong>display current-configuration</strong> <strong>interface</strong> <em>interface-type</em> <em>interface-number</em>，查看OSPF接口的IP地址。</p>
<p>一般情况下，链路两端的OSPF接口的IP地址的掩码必须一致，否则双方不能正常建立OSPF邻居关系。</p>
<p>但在P2MP网络中，可以通过在运行OSPF协议的接口视图下配置命令<strong>ospf p2mp-mask-ignore</strong>来使设备忽略对网络掩码的检查，从而正常建立OSPF邻居关系。</p>
<p>如果OSPF接口的IP地址的掩码不一致，请在运行OSPF协议的接口视图下执行命令<strong>ip address</strong> <em>ip-address</em> { <em>mask</em> | <em>mask-length</em> }，修改OSPF接口的IP地址以保证掩码一致。</p>
</blockquote>
</li>
<li><p><strong>检查链路两端OSPF接口的IP地址所在网段是否包含在区域内配置的network内。</strong></p>
<blockquote>
<p>也就是检查接口是否激活了OSPF。</p>
<p>分别在链路两端的设备上执行命令<strong>display current-configuration</strong> <strong>interface</strong> <em>interface-type</em> <em>interface-number</em>，查看OSPF接口的IP地址；执行命令<strong>display current-configuration</strong> <strong>configuration</strong> <strong>ospf</strong>，查看OSPF进程的配置。</p>
<p>满足下面两个条件，OSPF协议才能在接口上运行：</p>
<ul>
<li>接口的IP地址掩码长度≥<strong>network</strong>命令中的掩码长度。OSPF使用反掩码，例如0.0.0.255表示掩码长度24位。</li>
<li>接口的主IP地址必须在<strong>network</strong>命令指定的网段范围之内。</li>
</ul>
<p>如果检查发现接口IP地址与配置的<strong>network</strong>不满足上述条件，请在运行OSPF协议的接口视图下执行命令<strong>ip address</strong> <em>ip-address</em> { <em>mask</em> | <em>mask-length</em> }，修改接口的IP地址；或者在OSPF进程对应的区域视图下执行命令<strong>network</strong>，修改配置的网段，保证满足上述条件。</p>
</blockquote>
</li>
<li><p><strong>检查链路两端OSPF接口的DR优先级是否非零。</strong></p>
<blockquote>
<p>分别在链路两端的设备上执行命令<strong>display ospf</strong> [ <em>process-id</em> ] <strong>interface</strong>，查看OSPF接口的DR优先级。</p>
<p>对于广播和NBMA类型网络，链路中至少要有一个OSPF接口的DR优先级不为0，这样才能正常选举出DR。否则两边的邻居状态只能达到<strong>2-Way</strong>。</p>
<p>如果链路两端OSPF接口的DR优先级都为0，请在运行OSPF协议的接口视图下执行命令<strong>ospf dr-priority</strong> <em>priority</em>，修改OSPF接口的DR优先级以保证至少有一个接口的DR优先级不为0。</p>
</blockquote>
</li>
</ol>
<h2 id="报文认证"><a href="#报文认证" class="headerlink" title="报文认证"></a>报文认证</h2><p>为了避免有攻击者通过接入非法路由器并启用OSPF，向我方OSPF网络中注入大量无用的LSA，可以在OSPF中配置报文认证。</p>
<p>OSPF 支持三种类型的认证方式，分别是空认证（Null Authentication）、简单口令认证（Simple Password）、密文认证（Ctyptograhpic Authentication），这三种认 证方式对应的“认证类型”字段值分别为0、1和2。</p>
<p><strong>空认证</strong>：</p>
<ul>
<li>空认证即不做认证，这是OSPF接口的默认设置。</li>
</ul>
<p><strong>简单口令认证</strong>：</p>
<ul>
<li><p>简单口令认证又称明文认证，OSPF报文的认证数据字段中会填写为配置的明文口令（密码），接口收到该OSPF报文就会去检查包含的口令是否正确。</p>
<p>但因为此种认证是采用明文的方式，存在被截获口令的隐患，并不安全。</p>
</li>
</ul>
<p><strong>密文认证</strong>：</p>
<ul>
<li>密文认证是对口令进行了加密，报文中传输的是加密后的口令。（虽然加密对安全性没有太多的帮助，依旧可以截获并使用报文中的口令，只是无法得知加密前的口令是什么）</li>
<li>密文认证还增加了密码序列号这一字段以预防重放攻击（截获正常报文，重复发送）</li>
</ul>
<blockquote>
<p>命令不作介绍了，有兴趣可以查看文档，在模拟器上测试一轮。</p>
</blockquote>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>OSPF还有其他非常多的配置命令，碍于篇幅，以及一般都不会使用的原因，本文不做介绍。</p>
<p>感兴趣的可以查看产品手册参考可配置命令，其中大多数都是进行优先的命令。<del>但实际现网中，能通就行，真有次优路由也无妨</del></p>
<p>另外，本文弱化了网络类型的概念，OSPF可以在多种网络类型中使用，但个人认为其他网络类型目前使用场景太少了，现在是以太网一统天下的时代，因此本文是默认为以太网环境下进行介绍的。</p>
<p>此外，本文还是默认为ipv4环境，使用的是OSPF Version 2。OSPF还有一个OSPF Version 3，是针对ipv6场景的，有机会的话我们再介绍。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://magiku.github.io">Magiku</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://magiku.github.io/2024/06/28/B11[%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1]ospf%E8%AF%A6%E8%A7%A3/">https://magiku.github.io/2024/06/28/B11[%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1]ospf%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，转载请注明出处！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C/">网络</a></div><div class="post_share"><div class="social-share" data-image="https://c4893f9d.telegraph-image-713.pages.dev/file/dcb11262f483239ffc471.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/01/B12%5B%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%5DIS-IS/" title="B12【动态路由】IS-IS"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">B12【动态路由】IS-IS</div></div></a></div><div class="next-post pull-right"><a href="/2024/06/19/A01%5B%E7%A7%91%E6%99%AE%5D%EF%BC%88%E8%BD%AF%E4%BB%B6%E5%90%91%EF%BC%89%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" title="A01【科普】（软件向）网络运维工具的介绍与使用技巧"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">A01【科普】（软件向）网络运维工具的介绍与使用技巧</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/06/19/A01%5B%E7%A7%91%E6%99%AE%5D%EF%BC%88%E8%BD%AF%E4%BB%B6%E5%90%91%EF%BC%89%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" title="A01【科普】（软件向）网络运维工具的介绍与使用技巧"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-19</div><div class="title">A01【科普】（软件向）网络运维工具的介绍与使用技巧</div></div></a></div><div><a href="/2024/06/17/A02%5B%E7%A7%91%E6%99%AE%5D%EF%BC%88%E7%A1%AC%E4%BB%B6%E5%90%91%EF%BC%89%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" title="A02【科普】（硬件向）网络运维工具的介绍与使用技巧"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-17</div><div class="title">A02【科普】（硬件向）网络运维工具的介绍与使用技巧</div></div></a></div><div><a href="/2023/10/19/A00%5B%E7%A7%91%E6%99%AE%5D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/" title="A00【科普]】计算机网络概述"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-19</div><div class="title">A00【科普]】计算机网络概述</div></div></a></div><div><a href="/2024/07/28/B01%5B%E4%BA%A4%E6%8D%A2%E5%9F%BA%E7%A1%80%5D%E6%B3%9B%E6%B4%AA%E4%B8%8EARP/" title="B01【交换基础】泛洪与ARP"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-28</div><div class="title">B01【交换基础】泛洪与ARP</div></div></a></div><div><a href="/2024/07/08/A03%5B%E7%A7%91%E6%99%AE-%E8%BF%90%E7%BB%B4%5D%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E6%89%8B%E5%86%8C/" title="A03【科普-运维】网络故障排查手册"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-08</div><div class="title">A03【科普-运维】网络故障排查手册</div></div></a></div><div><a href="/2023/12/11/B05%5B%E4%BA%A4%E6%8D%A2%E5%9F%BA%E7%A1%80%5Dvlan%E3%80%81%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E3%80%81vlanif/" title="B05【交换基础】vlan、接口类型、vlanif"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-11</div><div class="title">B05【交换基础】vlan、接口类型、vlanif</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "/image/loading.gif" data-lazy-src="https://c4893f9d.telegraph-image-713.pages.dev/file/dcb11262f483239ffc471.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Magiku</div><div class="author-info__description">个人博客，用于记录知识库。<br>希望这些笔记能对你有所帮助！<br>要是有什么需要交流的，欢迎联系我~</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/39293027"><i class="fab fa-bilibili"></i><span>Follow me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81"><span class="toc-text">链路状态</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ospf%E7%9A%84%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86"><span class="toc-text">ospf的基础原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0"><span class="toc-text">原理简述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DR%E3%80%81router-id"><span class="toc-text">DR、router-id</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%A5%E6%96%87%E5%8F%91%E9%80%81%E6%96%B9%E5%BC%8F"><span class="toc-text">报文发送方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%BB%E5%B1%85%E4%B8%8E%E9%82%BB%E6%8E%A5%E5%85%B3%E7%B3%BB"><span class="toc-text">邻居与邻接关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E5%B1%85%E8%A1%A8"><span class="toc-text">邻居表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OSPF%E5%9F%9F"><span class="toc-text">OSPF域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9F%9F%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-text">区域的格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tips"><span class="toc-text">Tips</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OSPF%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E8%A7%92%E8%89%B2"><span class="toc-text">OSPF路由器的角色</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LSA%E7%B1%BB%E5%9E%8B1-5"><span class="toc-text">LSA类型1-5</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#OSPF%E7%9A%84%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%E3%80%81%E9%82%BB%E5%B1%85%E7%8A%B6%E6%80%81%E3%80%81%E9%82%BB%E5%B1%85-%E9%82%BB%E6%8E%A5%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B"><span class="toc-text">OSPF的报文格式、邻居状态、邻居&#x2F;邻接建立过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#OSPF%E7%9A%84%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B"><span class="toc-text">OSPF的报文类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OSPF%E7%9A%84%E9%82%BB%E5%B1%85%E7%8A%B6%E6%80%81"><span class="toc-text">OSPF的邻居状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E9%82%BB%E5%B1%85%E5%85%B3%E7%B3%BB"><span class="toc-text">建立邻居关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E9%82%BB%E6%8E%A5%E5%85%B3%E7%B3%BB"><span class="toc-text">建立邻接关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#OSPF%E7%9A%84%E5%BA%A6%E9%87%8F%E5%80%BC%E2%80%94%E2%80%94cost"><span class="toc-text">OSPF的度量值——cost</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%EF%BC%88%E6%9C%AB%E6%A2%A2%E5%8C%BA%E5%9F%9F%EF%BC%89"><span class="toc-text">特殊区域（末梢区域）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Stub-Area-%EF%BC%88%E6%9C%AB%E6%A2%A2%E5%8C%BA%E5%9F%9F%EF%BC%89"><span class="toc-text">Stub Area （末梢区域）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Totally-Stub-Area%EF%BC%88%E5%AE%8C%E5%85%A8%E6%9C%AB%E6%A2%A2%E5%8C%BA%E5%9F%9F%EF%BC%89"><span class="toc-text">Totally Stub Area（完全末梢区域）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NSSA-Not-So-Stubby-Area%EF%BC%8C%E9%9D%9E%E5%AE%8C%E5%85%A8%E6%9C%AB%E6%A2%A2%E5%8C%BA%E5%9F%9F"><span class="toc-text">NSSA (Not-So-Stubby Area，非完全末梢区域)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Totally-NSSA"><span class="toc-text">Totally NSSA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#OSPF%E7%9A%84%E7%BB%B4%E6%8A%A4"><span class="toc-text">OSPF的维护</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LSA%E8%AF%A6%E8%A7%A3"><span class="toc-text">LSA详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#type-1-LSA"><span class="toc-text">type-1 LSA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-text">报文格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-text">举例说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5R1%E4%B8%BA%E4%BE%8B%EF%BC%9A"><span class="toc-text">以R1为例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5R3%E4%B8%BA%E4%BE%8B%EF%BC%9A"><span class="toc-text">以R3为例：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-2-LSA"><span class="toc-text">type-2 LSA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F-1"><span class="toc-text">报文格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E-1"><span class="toc-text">举例说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-3-LSA"><span class="toc-text">type-3 LSA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F-2"><span class="toc-text">报文格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E-2"><span class="toc-text">举例说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-3-LSA%E7%9A%84%E9%98%B2%E7%8E%AF%E6%9C%BA%E5%88%B6"><span class="toc-text">type-3 LSA的防环机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-4%E3%80%81type-5-LSA"><span class="toc-text">type-4、type-5 LSA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E6%96%B0%E6%8B%93%E6%89%91%E5%88%86%E6%9E%90%E6%8F%8F%E8%BF%B0"><span class="toc-text">以新拓扑分析描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-5-LSA"><span class="toc-text">type-5 LSA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-4-LSA"><span class="toc-text">type-4 LSA</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-7-LSA"><span class="toc-text">type-7 LSA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E6%9B%B4%E6%96%B0%E4%B8%80%E9%81%8D%E6%8B%93%E6%89%91%EF%BC%8C%E4%BB%8B%E7%BB%8Dtype-7-LSA%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">再更新一遍拓扑，介绍type-7 LSA的原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E5%91%BD%E4%BB%A4%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">基础配置命令与解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE"><span class="toc-text">基础配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E7%94%A8OSPF"><span class="toc-text">启用OSPF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E5%A4%96%E9%83%A8%E8%B7%AF%E7%94%B1"><span class="toc-text">引入外部路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E9%85%8D%E7%BD%AE"><span class="toc-text">检查配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E6%B1%87%E6%80%BB%E4%B8%8E%E9%BB%98%E8%AE%A4%E8%B7%AF%E7%94%B1"><span class="toc-text">路由汇总与默认路由</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E6%B1%87%E6%80%BB"><span class="toc-text">路由汇总</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E8%B7%AF%E7%94%B1"><span class="toc-text">默认路由</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E9%93%BE%E8%B7%AF%EF%BC%88Virtual-link%EF%BC%89"><span class="toc-text">虚链路（Virtual link）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#OSPF%E9%82%BB%E5%B1%85%E5%BB%BA%E7%AB%8B%E4%B8%8D%E8%B5%B7%E6%9D%A5%EF%BC%9F"><span class="toc-text">OSPF邻居建立不起来？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%A5%E6%96%87%E8%AE%A4%E8%AF%81"><span class="toc-text">报文认证</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-text">结语</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Magiku</div><div class="footer_custom_text"></p></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "/image/loading.gif" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "/image/loading.gif" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'd55e9307ca605124a542',
      clientSecret: '73a85d39b9bda1aa0f24ac51ea5a9504edf02277',
      repo: 'magiku.github.io',
      owner: 'magiku',
      admin: ['magiku'],
      id: 'a845cf3dc4ddde036a063c56ae74839f',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.textContent= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://magiku.github.io/categories/计算机网络/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 计算机网络 (20)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://magiku.github.io/categories/个人杂谈/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 磨叽墨迹 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://magiku.github.io/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #74d6cf}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:black}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "/image/loading.gif" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.8/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = '/2023/,/2024/,/2025/,/2026/,/2027/,/2028/,/2029/,/2030/'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = '39b2c1fede67489eb9265b983874c66d';
  var gaud_map_key = '84b1f52230bfdc06111b20984a0b04d9';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.324587,23.106574';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.8/lib/clock.min.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/10/19/A00[科普]计算机网络概述/" alt=""><img width="48" height="48" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-19</span><a class="blog-slider__title" href="2023/10/19/A00[科普]计算机网络概述/" alt="">A00【科普]】计算机网络概述</a><div class="blog-slider__text">本文以实际出发，介绍计算机网络的入门知识，让读者对计算机网络有个总体的知识体系</div><a class="blog-slider__button" href="2023/10/19/A00[科普]计算机网络概述/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/07/08/A03[科普-运维]网络故障排查手册/" alt=""><img width="48" height="48" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-08</span><a class="blog-slider__title" href="2024/07/08/A03[科普-运维]网络故障排查手册/" alt="">A03【科普-运维】网络故障排查手册</a><div class="blog-slider__text">本文将介绍一些常见的网络故障与排查思路，主要适用于家庭与公司内部网络，运营商一侧的维护不介绍（只要会判断是不是它们的问题即可</div><a class="blog-slider__button" href="2024/07/08/A03[科普-运维]网络故障排查手册/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/07/28/B01[交换基础]泛洪与ARP/" alt=""><img width="48" height="48" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-28</span><a class="blog-slider__title" href="2024/07/28/B01[交换基础]泛洪与ARP/" alt="">B01【交换基础】泛洪与ARP</a><div class="blog-slider__text">本文将介绍设备之前是如何通过MAC地址通信的，包括交换机的泛洪学习，设备的ARP协议，网关的代理ARP等。</div><a class="blog-slider__button" href="2024/07/28/B01[交换基础]泛洪与ARP/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/06/04/B08[路由基础]静态路由、RIP协议/" alt=""><img width="48" height="48" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-06-04</span><a class="blog-slider__title" href="2024/06/04/B08[路由基础]静态路由、RIP协议/" alt="">B08【路由基础】静态路由、RIP协议</a><div class="blog-slider__text">本文将介绍路由相关知识，也就是路由器相关的内容。上篇介绍的交换与vlan都是二层技术，基于mac地址信息所在的数据帧。而路由是三层技术（网络层），是基于ip地址信息所在的数据包。</div><a class="blog-slider__button" href="2024/06/04/B08[路由基础]静态路由、RIP协议/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/12/22/B03[多链路问题]环路、广播风暴、链路聚合/" alt=""><img width="48" height="48" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-12-22</span><a class="blog-slider__title" href="2023/12/22/B03[多链路问题]环路、广播风暴、链路聚合/" alt="">B03【多链路问题】环路、广播风暴、链路聚合</a><div class="blog-slider__text">本篇是针对交换部分的多链路进行讨论，探讨了环路的危害与预防措施，进而延申出链路聚合的概念与知识点。</div><a class="blog-slider__button" href="2023/12/22/B03[多链路问题]环路、广播风暴、链路聚合/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1s');
    arr[i].setAttribute('data-wow-delay', '0.5s');
    arr[i].setAttribute('data-wow-offset', '0');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>
<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【路由控制】ACL、路由策略、策略路由</title>
      <link href="/2024/07/15/%E3%80%90%E8%B7%AF%E7%94%B1%E6%8E%A7%E5%88%B6%E3%80%91ACL%E3%80%81%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5%E3%80%81%E7%AD%96%E7%95%A5%E8%B7%AF%E7%94%B1/"/>
      <url>/2024/07/15/%E3%80%90%E8%B7%AF%E7%94%B1%E6%8E%A7%E5%88%B6%E3%80%91ACL%E3%80%81%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5%E3%80%81%E7%AD%96%E7%95%A5%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文将介绍路由策略与策略路由，它们名字很相似，很容易混淆。其实只要分清主语就可以了。</p><p>路由<strong>策略</strong>是作用于路由的<strong>策略</strong>，是对路由去做一个过滤筛选与自定义参数，主要用在引入路由的时候。</p><p>策略<strong>路由</strong>是有策略的<strong>路由</strong>，是对数据包的走向进行自定义，这也相当于是对数据包进行路由。</p><p>总的来说，一个是策略，另一个是路由。</p><p>而ACL是一种用在路由策略的“策略”。因此本文会先介绍它。</p><h1 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h1><p>ACL（Access Control List，访问控制列表）是由一条或多条规则组成的集合，是用于控制数据包流动的一种机制。</p><p>所谓规则，是指描述报文匹配条件的判断语句，这些条件可以是报文的源地址、目的地址、端口号等。</p><p>ACL本质上是一种报文过滤器，设备基于规则进行报文匹配，可以过滤出特定的报文。</p><p>配置完ACL后，必须在具体的业务模块中应用ACL，才能使ACL正常下发和生效。</p><p>最终根据应用ACL的业务模块的处理策略来允许或阻止该报文通过。</p><table><thead><tr><th>业务分类</th><th>应用场景</th><th>涉及业务模块</th></tr></thead><tbody><tr><td>对转发的报文进行过滤</td><td>基于全局和接口，对转发的报文进行过滤，从而使设备能够进一步对过滤出的报文进行丢弃、修改优先级、重定向等处理。<br />例如，可以利用ACL，降低P2P下载、网络视频等消耗大量带宽的数据流的服务等级，在网络拥塞时优先丢弃这类流量，减少它们对其他重要流量的影响。</td><td>简化流策略&#x2F;流策略</td></tr><tr><td>对上送CPU处理的报文进行过滤</td><td>对上送CPU的报文进行必要的限制，可以避免CPU处理过多的协议报文造成占用率过高、性能下降。<br />例如，当发现某用户向设备发送大量的ARP攻击报文，造成设备CPU繁忙，引发系统中断时，可以在本机防攻击策略的黑名单中应用ACL，将该用户加入黑名单，使CPU丢弃该用户发送的报文。</td><td>黑名单</td></tr><tr><td>登录控制</td><td>对设备的登录权限进行控制，允许合法主机登录，拒绝非法主机登录，从而有效防止未经授权的非法接入，保证网络安全性。<br />例如，一般情况下设备只允许管理员登录，非管理员用户不允许随意登录。这时就可以在Telnet中应用ACL，并在ACL中定义哪些主机可以登录，哪些主机不能。</td><td>Telnet、STelnet、FTP、SFTP、HTTP、SNMP</td></tr><tr><td>路由过滤</td><td>ACL可以应用在各种动态路由协议中，对路由协议发布、接收的路由信息以及组播组进行过滤。<br />例如，可以将ACL和路由策略配合使用，禁止设备将某网段路由发给邻居路由器。</td><td>BGP、IS-IS、OSPF、OSPFv3、RIP、RIPng、组播协议</td></tr></tbody></table><p>在各类业务模块中应用ACL时，ACL的默认动作各有不同。</p><p>所以各业务模块对命中&#x2F;未命中ACL规则报文的处理机制也各不相同。</p><blockquote><p>例如：</p><p>流策略中的ACL默认动作是permit（允许），也就是说在流策略中应用ACL时，如果报文<strong>未匹配</strong>上ACL中的任何一条规则，该报文仍可以正常通过。</p><p>而登录控制中的ACL默认动作是deny（阻止），在登录控制中应用ACL时，如果遇到此种情况，该报文会被拒绝通过。</p><p>此外，黑名单模块中的ACL处理机制与其他模块有所不同。在黑名单中应用ACL时，无论ACL规则配置成permit还是deny，只要报文命中了规则，该报文都会被系统丢弃。</p></blockquote><h2 id="ACL的编号和步长"><a href="#ACL的编号和步长" class="headerlink" title="ACL的编号和步长"></a>ACL的编号和步长</h2><p>用户在创建ACL时必须为其指定编号或名称，不同的编号对应不同类型的ACL。</p><table>       <tr>             <th>ACL类型</th>     <th>编号范围</th>     <th>适用的IP版本</th>     <th>规则制定依据</th>       </tr>       <tr>        <td rowspan="2">基本ACL</td>     <td rowspan="2">2000～2999</td>     <td>IPv4</td>     <td>报文的源IPv4地址</td>       </tr>     <tr>        <td>IPv6</td>     <td>报文的源IPv6地址</td>       </tr>        <tr>        <td rowspan="2">高级ACL</td>     <td rowspan="2">3000～3999</td>     <td>IPv4</td>     <td>报文的源IPv4地址、目的IPv4地址、报文优先级、IPv4承载的协议类型及特性等三、四层信息</td>       </tr>     <tr>        <td>IPv6</td>     <td>报文的源IPv6地址、目的IPv6地址、报文优先级、IPv6承载的协议类型及特性等三、四层信息</td>       </tr>        <tr>        <td>二层ACL</td>     <td>4000～4999</td>     <td>IPv4和IPv6</td>     <td>报文的源MAC地址、目的MAC地址、802.1p优先级、链路层协议类型等二层信息</td>       </tr> </table><p>除了ACL编号外，ACL中的每条rule（规则）也有自己的编号，这个rule编号在一个ACL中是唯一的。</p><p>ACL的匹配是按顺序的，以rule编号小的为优先匹配。</p><p>创建规则时，可以手工为其指定一个rule编号；如未手工指定rule编号，则由系统为其自动分配一个rule编号</p><p>由于规则的编号可能影响规则匹配的顺序，因此当由系统自动分配rule编号时，为了方便后续在已有规则之前插入新的规则，系统通常会在相邻rule编号之间留下一定的空间，这个空间的大小（即相邻编号之间的差值）就称为ACL的步长。</p><p>一般默认ACL的rule编号步长为5，系统会将编号5、10、15、20……依次分配给新创建的规则。</p><blockquote><p>因此，一般手动配置的时候，<strong>不要使用连号</strong>；</p><p>否则后期再想插入新的规则，就只能先删除已有的规则，然后再配置新规则，最后再将之前删除的规则重新配置还原。</p></blockquote><h2 id="ACL的匹配"><a href="#ACL的匹配" class="headerlink" title="ACL的匹配"></a>ACL的匹配</h2><p>一条ACL可以由多条“deny”或”permit”语句组成，每一条语句描述一条规则，这些规则可能存在重复或矛盾的地方。</p><p>例如，在一条ACL中先后配置以下两条规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rule deny ip destination 10.1.0.0 0.0.255.255   //表示拒绝目的IP地址为10.1.0.0/16网段地址的报文通过</span><br><span class="line">rule permit ip destination 10.1.1.0 0.0.0.255   //表示允许目的IP地址为10.1.1.0/24网段地址的报文通过</span><br></pre></td></tr></table></figure><p>对于目的IP&#x3D;10.1.1.1的报文，如果系统先将deny规则与其匹配，则该报文会被拒绝通过。</p><p>相反，如果系统先将permit规则与其匹配，则该报文会得到允许通过。</p><p>也就是说，数据报文经过ACL时，遵循<strong>“一旦命中则停止</strong>”的原则。</p><p>因此，对于规则之间存在重复或矛盾的情形，报文的匹配结果与ACL的匹配顺序是息息相关的。</p><p>设备支持两种ACL匹配顺序：配置顺序（config模式）和自动排序（auto模式）。默认ACL匹配顺序是config模式。</p><p><strong>配置顺序</strong>，即系统按照ACL规则编号<strong>从小到大的顺序进行报文匹配</strong>，规则编号越小越容易被匹配。</p><ul><li>如果配置规则时指定了规则编号，则规则编号越小，规则插入位置越靠前，该规则越先被匹配。</li><li>如果配置规则时未指定规则编号，则由系统自动为其分配一个编号。该编号是一个大于当前ACL内最大规则编号且是步长整数倍的最小整数，因此该规则会被最后匹配。</li></ul><p><strong>自动排序</strong>，是指系统使用“深度优先”的原则，将规则按照精确度从高到低进行排序，并按照精确度从高到低的顺序进行报文匹配。（类似路由转发中的“最长匹配原则”）</p><p>规则中定义的匹配项限制越严格，规则的精确度就越高，即优先级越高，系统越先匹配。</p><p>相比<strong>config</strong>模式的ACL，<strong>auto</strong>模式ACL的规则匹配顺序更为复杂，但是<strong>auto</strong>模式ACL有其独特的应用场景。</p><blockquote><p>例如：</p><p>在网络部署初始阶段，为了保证网络安全性，管理员定义了较大的ACL匹配范围，用于丢弃不可信网段范围的所有IP报文。</p><p>随着时间的推移，实际应用中需要允许这个大范围中某些特征的报文通过。</p><p>此时，如果管理员采用的是<strong>auto</strong>模式，则只需要定义新的ACL规则，无需再考虑如何对这些规则进行排序避免报文被误丢弃。</p></blockquote><h2 id="ACL的规则"><a href="#ACL的规则" class="headerlink" title="ACL的规则"></a>ACL的规则</h2><p>配置<strong>基本ACL</strong>规则的命令具有如下的结构。 </p><p><strong>rule</strong> [<em>rule-id</em>] <strong>{deny | permit}</strong> [<strong>source</strong> (<em>source-address source-wildcard</em> | <strong>any</strong>) I <strong>fragment</strong> | <strong>logging</strong> | <strong>time-range</strong> <em>time-name</em>]</p><p>命令中各个组成项的解释如下。（大括号为必选、中括号为可选，黑体为固定命令，斜体为变量。）</p><blockquote><p>rule：表示这是一条规则。 </p><p><em>rule-id</em>：表示这条规则的编号。 </p><p>deny | permit：这是一个二选一选项,表示与这条规则相关联的处理动作。deny表示“拒绝”;  permit表示“允许”。 </p><p>source：表示源 IP 地址信息。 </p><p><em>source-address</em>：表示具体的源 IP 地址。 </p><p><em>source-wildcard</em>：表示与 source-address 相对应的通配符。 source-wildcard 和source-address 的结合使用，可以确定出一个 IP 地址的集合。该集合中也可以只包含一个 IP 地址。  </p><p>any：表示源 IP 地址可以是任何地址。 </p><p>fragment:表示该规则只对非首片分片报文有效。</p><p>logging：表示需要将匹配上该规则的 IP 报文进行日志记录。</p><p>time-range <em>time-name</em>：表示该规则的生效时间段为time-name。</p></blockquote><p>以下rule的表达方式仅是示意形式。</p><ul><li><strong>rule permit xxx</strong>：表示允许指定的报文通过，xxx表示指定报文的标识，可以是源IP地址、源MAC地址、生效时间段等。</li><li><strong>rule deny xxx</strong>：表示拒绝指定的报文通过。</li><li><strong>rule permit</strong>：表示允许所有报文通过。</li><li><strong>rule deny</strong>：表示拒绝所有报文通过。</li></ul><p>根据各业务模块ACL默认动作的不同，ACL的配置原则也不同。</p><p>例如，在默认动作为permit的业务模块中，如果只希望deny部分IP地址的报文，只需配置具体IP地址的deny规则，结尾无需添加任意IP地址的permit规则；而默认动作为deny的业务模块恰与其相反。</p><p>具体分类如下：</p><table><thead><tr><th>业务模块的ACL默认动作</th><th>permit所有报文</th><th>deny所有报文</th><th>permit少部分报文，deny大部分报文</th><th>deny少部分报文，permit大部分报文</th></tr></thead><tbody><tr><td><strong>permit</strong></td><td>无需应用ACL</td><td>配置<strong>rule deny</strong></td><td>需先配置<strong>rule permit xxx</strong>，再配置<strong>rule deny xxx</strong>或<strong>rule deny</strong><br />说明：以上原则适用于报文过滤的情形。当ACL应用于流策略中进行流量监管或者流量统计时，如果仅希望对指定的报文进行限速或统计，则只需配置<strong>rule permit xxx</strong>。</td><td>只需配置<strong>rule deny xxx</strong>，无需再配置<strong>rule permit xxx</strong>或<strong>rule permit</strong><br />说明：如果配置<strong>rule permit</strong>并在流策略中应用ACL，且该流策略的流行为behavior<br />配置为<strong>deny</strong>，则设备会拒绝所有报文通过，导致全部业务中断。</td></tr><tr><td><strong>deny</strong></td><td>路由和组播模块：需配置<strong>rule permit</strong>其他模块：无需应用ACL</td><td>路由和组播模块：无需应用ACL其他模块：需配置<strong>rule deny</strong></td><td>只需配置<strong>rule permit xxx</strong>，无需再配置<strong>rule deny xxx</strong>或<strong>rule deny</strong></td><td>需先配置<strong>rule deny xxx</strong>，再配置<strong>rule permit xxx</strong>或<strong>rule permit</strong></td></tr></tbody></table><p>举例：</p><ul><li><p>例1：在流策略中应用ACL，使设备对192.168.1.0&#x2F;24网段的报文进行过滤，拒绝192.168.1.2和192.168.1.3主机地址的报文通过，允许192.168.1.0&#x2F;24网段的其他地址的报文通过。</p><p>流策略的ACL默认动作为<strong>permit</strong>，该例属于“deny少部分报文，permit大部分报文”的情况，所以只需配置<strong>rule deny xxx</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line">acl number 2000</span><br><span class="line"> rule 5 deny source 192.168.1.2 0</span><br><span class="line"> rule 10 deny source 192.168.1.3 0</span><br><span class="line">#</span><br></pre></td></tr></table></figure></li><li><p>例2：在流策略中应用ACL，使设备对192.168.1.0&#x2F;24网段的报文进行过滤，允许192.168.1.2和192.168.1.3主机地址的报文通过，拒绝192.168.1.0&#x2F;24网段的其他地址的报文通过。</p><p>流策略的ACL默认动作为<strong>permit</strong>，该例属于“permit少部分报文，deny大部分报文”的情况，所以需先配置<strong>rule permit xxx</strong>，再配置<strong>rule deny xxx</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line">acl number 2000</span><br><span class="line"> rule 5 permit source 192.168.1.2 0</span><br><span class="line"> rule 10 permit source 192.168.1.3 0</span><br><span class="line"> rule 15 deny source 192.168.1.0 0.0.0.255</span><br><span class="line">#</span><br></pre></td></tr></table></figure></li><li><p>例3：在Telnet中应用ACL，仅允许管理员主机（IP地址为172.16.105.2）能够Telnet登录设备，其他用户不允许Telnet登录。</p><p>Telnet的ACL默认动作为<strong>deny</strong>，该例属于“permit少部分报文，deny大部分报文”的情况，所以只需配置<strong>rule permit xxx</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line">acl number 2000</span><br><span class="line"> rule 5 permit source 172.16.105.2 0</span><br><span class="line">#</span><br></pre></td></tr></table></figure></li><li><p>例4：在Telnet中应用ACL，不允许某两台主机（IP地址为172.16.105.3和172.16.105.4）Telnet登录设备，其他用户均允许Telnet登录。</p><p>Telnet的ACL默认动作为<strong>deny</strong>，该例属于“deny少部分报文，permit大部分报文”的情况，所以需先配置<strong>rule deny xxx</strong>，再配置<strong>rule permit</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line">acl number 2000</span><br><span class="line"> rule 5 deny source 172.16.105.3 0</span><br><span class="line"> rule 10 deny source 172.16.105.4 0</span><br><span class="line"> rule 15 permit</span><br><span class="line">#</span><br></pre></td></tr></table></figure></li><li><p>例5：在FTP中应用ACL，不允许用户在周六的00:00～8:00期间访问FTP服务器，允许用户在其他任意时间访问FTP服务器。</p><p>FTP的ACL默认动作为<strong>deny</strong>，该例属于“deny少部分报文，permit大部分报文”的情况，所以需先配置<strong>rule deny xxx</strong>，再配置<strong>rule permit xxx</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line">time-range t1 00:00 to 08:00 Sat</span><br><span class="line">time-range t2 00:00 to 23:59 daily</span><br><span class="line">#</span><br><span class="line">acl number 2000</span><br><span class="line"> rule 5 deny time-range t1</span><br><span class="line"> rule 10 permit time-range t2</span><br><span class="line">#</span><br></pre></td></tr></table></figure></li></ul><h1 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>路由策略主要实现了<strong>路由过滤</strong>和<strong>路由属性设置</strong>等功能，它通过改变路由属性（包括可达性）来改变网络流量所经过的路径。</p><p>路由协议在发布、接收和引入路由信息时，根据实际组网需求实施一些策略，如：</p><ul><li><p>控制路由的接收和发布</p><p>只发布和接收必要、合法的路由信息，以控制路由表的容量，提高网络的安全性。</p></li><li><p>控制路由的引入</p><p>在一种路由协议引入 <u>其它路由协议发现的路由信息</u> 时，只引入一部分满足条件的路由信息。</p></li><li><p>设置特定路由的属性</p><p>修改通过路由策略过滤的路由的属性，满足自身需要。</p></li></ul><p>路由策略具有以下价值：</p><ul><li>通过控制路由器的路由表规模，节约系统资源。</li><li>通过控制路由的接收、发布和引入，提高网络安全性。</li><li>通过修改路由属性，对网络数据流量进行合理规划，提高网络性能。</li></ul><p>实际上，路由策略并不是单一的一项技术，而是一种思路、方案的统称。</p><p>接下来我们就介绍几种路由策略的实现方式。</p><h2 id="Route-Policy"><a href="#Route-Policy" class="headerlink" title="Route-Policy"></a>Route-Policy</h2><p>Route-Policy 是一个非常重要的路由策略工具，如图所示，可以把它想象成拥有一个或多个节点(Node)的列表，每一个节点都可以是一系列条件语句及执行语句的集合，这些节点按照编号从小到大的顺序排列。</p><p>在每个节点中，用户可以定义条件语句及执行语句，这就有点像程序设计语言里的If语句。</p><p>在Route-Policy被执行的时候，设备从编号最小的节点开始进行路由匹配，如果被匹配的对象满足所有条件，则执行该节点中的执行语句，并且不会再继续往下一个节点进行匹配。而如果节点1中，有任何一个条件不满足，则前往下一个节点，也就是到节点2中去匹配条件语句，如果被匹配的对象满足所有条件，则执行该节点中的执行语句；如果不满足，则继续往下一个节点进行匹配，以此类推。</p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/fa17fbc3e48d0173269ae.png" style="zoom:67%;" /><p>在Route-Policy里，条件语句是if-match，执行语句是apply，可在它们后配置具体的判断条件和执行动作。</p><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>Route-Policy中<strong>If-match</strong>子句可匹配多种过滤器，目前我们主要学习以下两种。</p><blockquote><p>注意，此处列举的是过滤器，是独立在Route-Policy之外，预先配置好的，然后引用到Route-Policy里。</p></blockquote><ul><li><strong>ACL</strong></li></ul><p>ACL是将报文中的入接口、源或目的地址、协议类型、源或目的端口号作为匹配条件的过滤器，在各路由协议发布、接收路由时单独使用。在Route-Policy的<strong>If-match</strong>子句中<strong>只支持基本ACL</strong>。</p><ul><li><strong>地址前缀列表（IP Prefix List）</strong></li></ul><p>地址前缀列表将源地址、目的地址和下一跳的地址前缀作为匹配条件的过滤器，可在各路由协议发布和接收路由时单独使用。</p><p>每个地址前缀列表可以包含多个索引（index），每个索引对应一个节点。路由按索引号从小到大依次检查各个节点是否匹配，任意一个节点匹配成功，将不再检查其他节点。若所有节点都匹配失败，路由信息将被过滤。</p><p>根据匹配的前缀不同，前缀过滤列表可以进行精确匹配，也可以进行在一定掩码长度范围内匹配。</p><p>当IP地址为0.0.0.0时表示通配地址，表示掩码长度范围内的所有路由都被Permit或Deny。</p><blockquote><p>因为if-match语句携带的ACL只支持基本ACL，在Route-Policy只能用作过滤指定目的地址；</p><p>所以对于需要将源地址作为条件的场景就需要使用地址前缀列表了。</p></blockquote><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol><li><p>执行命令<strong>system-view</strong>，进入系统视图。</p></li><li><p>执行命令<strong>route-policy</strong> <em>route-policy-name</em> { <strong>permit</strong> | <strong>deny</strong> } <strong>node</strong> <em>node-number</em>，创建Route-Policy，并进入Route-Policy视图。</p><p>当使用Route-Policy时，<em>node-number</em>的值小的节点先进行匹配。一个节点匹配成功后，路由将不再匹配其他节点。全部节点匹配失败后，路由将被过滤。</p></li><li><p>下列命令之间是并列关系，请根据实际情况配置路由策略中的<strong>if-match</strong>子句。</p><ul><li><p>匹配基本ACL：<strong>if-match acl</strong> { <em>acl-number</em> | <em>acl-name</em> }</p><blockquote><p>使用路由协议下的Route-Policy策略过滤路由时：</p><ul><li>如果ACL规则的动作是<strong>permit</strong>时，那么被此条rule规则匹配的路由信息被认为通过<strong>if-match</strong>子句的检查。</li><li>如果ACL规则的动作是<strong>deny</strong>时，那么被此条rule规则匹配的路由信息被认为未通过<strong>if-match</strong>子句的检查。</li><li>如果路由信息不在ACL规则指定的范围内，那么这些路由信息被认为未通过<strong>if-match</strong>子句的检查。</li><li>如果ACL中不存在规则，那么在此节点检查的所有路由信息被认为未通过<strong>if-match</strong>子句的检查。</li><li>对于<strong>route-policy</strong>中的<strong>permit</strong>节点，路由信息如果通过<strong>if-match</strong>子句的检查，则执行<strong>apply</strong>子句的相应动作；未通过<strong>if-match</strong>子句的检查则匹配<strong>route-policy</strong>下一个节点中<strong>apply</strong>子句的相应动作。</li><li>对于<strong>route-policy</strong>中的<strong>deny</strong>节点，路由信息如果通过<strong>if-match</strong>子句的检查，则不被执行<strong>apply</strong>子句的相应动作；未通过<strong>if-match</strong>子句的检查则匹配<strong>route-policy</strong>下一个节点中<strong>apply</strong>子句的相应动作。</li></ul></blockquote></li><li><p>匹配地址前缀列表：<strong>if-match ip-prefix</strong> <em>ip-prefix-name</em></p></li><li><p>匹配路由信息的开销值：<strong>if-match cost</strong> <em>cost</em></p></li><li><p>匹配路由信息的出接口：<strong>if-match interface</strong> <em>interface-type</em> <em>interface-number</em> </p></li><li><p>匹配路由信息的标记：<strong>if-match tag</strong> <em>tag</em></p></li></ul></li><li><p>根据实际情况配置路由策略中的<strong>apply</strong>子句。</p></li></ol><ul><li>设置路由的开销值：<strong>apply cost</strong> [ <strong>+</strong> | <strong>-</strong> ] <em>cost</em></li><li>设置IPv4路由的下一跳地址：<strong>apply ip-address next-hop</strong> { <em>ipv4-address</em> | <strong>peer-address</strong> }</li><li>设置IPv6路由的下一跳地址：<strong>apply ipv6 next-hop</strong> { <strong>peer-address</strong> | <em>ipv6-address</em> }</li><li>设置路由协议的优先级：<strong>apply preference</strong> <em>preference</em></li><li>设置路由的标记域：<strong>apply tag</strong> <em>tag</em></li></ul><ol start="5"><li>以上配置删除了使用率很低的命令，比如IS-IS、BGP、MPLS等相关参数的修改。</li></ol><h3 id="案例介绍"><a href="#案例介绍" class="headerlink" title="案例介绍"></a>案例介绍</h3><h4 id="使用acl作为过滤器，在引入静态路由时，进行筛选"><a href="#使用acl作为过滤器，在引入静态路由时，进行筛选" class="headerlink" title="使用acl作为过滤器，在引入静态路由时，进行筛选"></a>使用acl作为过滤器，在引入静态路由时，进行筛选</h4><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/d6ef51222a269ae41126a.png"></p><p>在图示的网络中, R1及R2在各自的GE0&#x2F;0&#x2F;0接口上激活OSPF并在Area0内建立邻接关系。</p><p>R1还有另外三个直连接口，这三个接口并没有使用network命令激活OSPF。</p><p>为了让OSPF域内的路由器能够学习到R1的GE0&#x2F;0&#x2F;1及GE0&#x2F;0&#x2F;2接口的路由(且路由的度量值为20)，就需要在R1上将直连路由引入OSPF。</p><p>但是这样一来，R1所有的直连路由都会被引入，这显然并非我们期望看到的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#创建基本acl，acl编号为2000，内容为匹配GE0/0/1及GE0/0/2接口的路由。注意，因为是匹配路由，因此ip地址为网络地址，为了避免“误伤”，通配符填写为0.0.0.0。</span><br><span class="line">[R1]acl 2000</span><br><span class="line">[R1-acl-basic-2000]rule permit source 10.0.1.0 0.0.0.0</span><br><span class="line">[R1-acl-basic-2000]rule permit source 10.0.2.0 0.0.0.0</span><br><span class="line">[R1-acl-basic-2000]q</span><br><span class="line">#创建基本route-policy，名称为no3，默认为permit，节点编号为10。</span><br><span class="line">#判断条件为acl 2000，执行动作为修改cost值=20。</span><br><span class="line">[R1]route-policy no3 permit node 10</span><br><span class="line">[R1-route-policy]if-match acl 2000</span><br><span class="line">[R1-route-policy]apply cost 20</span><br><span class="line">[R1-route-policy]q</span><br><span class="line">#创建ospf，引入直连路由的同时绑定route-policy。</span><br><span class="line">[R1]ospf 1 router-id 1.1.1.1</span><br><span class="line">[R1-ospf-1]area 0</span><br><span class="line">[R1-ospf-1-area-0.0.0.0]network 10.1.12.1 0.0.0.0</span><br><span class="line">[R1-ospf-1-area-0.0.0.0]q</span><br><span class="line">[R1-ospf-1]import-route direct route-policy no3 </span><br></pre></td></tr></table></figure><p>在R1上进行以上配置，即可达到要求，我们可以在R2上检查路由表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[R2]display ospf routing </span><br><span class="line"></span><br><span class="line"> OSPF Process 1 with Router ID 2.2.2.2</span><br><span class="line">  Routing Tables </span><br><span class="line"></span><br><span class="line"> Routing for Network </span><br><span class="line"> Destination        Cost  Type       NextHop         AdvRouter       Area</span><br><span class="line"> 10.1.12.0/24       1     Transit    10.1.12.2       2.2.2.2         0.0.0.0</span><br><span class="line"></span><br><span class="line"> Routing for ASEs</span><br><span class="line"> Destination        Cost      Type       Tag         NextHop         AdvRouter</span><br><span class="line"> 10.0.1.0/24        20        Type2      1           10.1.12.1       1.1.1.1</span><br><span class="line"> 10.0.2.0/24        20        Type2      1           10.1.12.1       1.1.1.1</span><br><span class="line"></span><br><span class="line"> Total Nets: 3  </span><br><span class="line"> Intra Area: 1  Inter Area: 0  ASE: 2  NSSA: 0 </span><br></pre></td></tr></table></figure><h4 id="使用地址前缀列表作为过滤器，在引入静态路由时，进行筛选"><a href="#使用地址前缀列表作为过滤器，在引入静态路由时，进行筛选" class="headerlink" title="使用地址前缀列表作为过滤器，在引入静态路由时，进行筛选"></a>使用地址前缀列表作为过滤器，在引入静态路由时，进行筛选</h4><p>如果继续使用刚刚的拓扑图，那么采用地址前缀列表的方式，配置如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#提前删除之前配置的route-policy与路由引入</span><br><span class="line">#创建名为no3的地址前缀过滤器，设置过滤规则</span><br><span class="line">[R1]ip ip-prefix no3 permit 10.0.1.0 24</span><br><span class="line">[R1]ip ip-prefix no3 permit 10.0.2.0 24</span><br><span class="line">#创建名为no3的route-policy，绑定地址前缀过滤器</span><br><span class="line">[R1]route-policy no3 permit node 10</span><br><span class="line">[R1-route-policy]if-match ip-prefix no3</span><br><span class="line">[R1-route-policy]q</span><br><span class="line">#进入ospf，引入直连路由的同时绑定route-policy。</span><br><span class="line">[R1]ospf 1</span><br><span class="line">[R1-ospf-1]import-route direct route-policy no3</span><br></pre></td></tr></table></figure><p>解释一下，<strong>ip-prefix默认动作为deny</strong>，也就是说对于没有匹配到规则的报文都一律拒绝通过。因此此处才没有专门配置“ip ip-prefix no3 deny 10.0.3.0 24”。</p><p>关于ip-prefix的语法，还有三个可选参数，分别是：</p><ul><li>index：编号，默认步长为10。与acl的rule编号、route-policy的node编号是一个用途。</li><li>greater-equal：要求掩码长度大于等于指定数值。</li><li>less-equal：要求掩码长度小于等于指定数值。</li></ul><p>ip-prefix的默认动作为deny，如果我们的需求是只禁止某几条路由信息，那么我们就可以配置以下命令。</p><ul><li><p><strong>ip ip-prefix</strong> name <strong>index</strong> 10 <strong>permit</strong> 0.0.0.0 0 <strong>less-equal</strong> 32</p><blockquote><p>0.0.0.0后面还有一个标识掩码长度的0！</p></blockquote></li></ul><p>上述语句中，IP 地址为 0.0.0.0，这种形式的 IP 地址被称为任意地址或通配地址，也即该地址能匹配任意的目的网络地址。</p><p>因此该语句并不关心被匹配路由的目的网络地址，但是要求路由的目的网络掩码长度须大于或等于0，且小于或等于32；</p><p>实际上所有的路由都满足上述要求，因此该条语句相当于“允许所有”。</p><h2 id="Filter-Policy"><a href="#Filter-Policy" class="headerlink" title="Filter-Policy"></a>Filter-Policy</h2><p>本节将介绍另外一款用于路由过滤的工具——Filter-Policy (过滤-策略)，可以将其视为一种路由过滤器。</p><p>filter-policy工作在协议的进程下，可以作用于进程的进出两个方向。</p><blockquote><p>但它只能过滤路由信息，并不检查过滤链路状态信息，因此在OSPF协议下，它不适合用在出方向。</p><p>而在入方向，过滤只会影响lsdb的加表过程，不会影响到lsa。</p><p>如果ospf的边界路由器执行过滤，他只会对其他area泛洪自身已加表的路由。</p><p>有关这部分内容，我们稍后探讨。</p></blockquote><p>filter-policy本身无法设置滤条件，需要调用其它过滤条件来完成路由信息过滤。</p><p><strong>一般可以调用acl、ip-prefix、route-policy这三项进行过滤。</strong></p><p>这三项都已经介绍过了，因此我们直接进入案例吧。</p><h3 id="在RIP网络中过滤路由"><a href="#在RIP网络中过滤路由" class="headerlink" title="在RIP网络中过滤路由"></a>在RIP网络中过滤路由</h3><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/007e8960c7802677a27f7.png"></p><p>图示的网络中, R1、 R2及R3运行了RIPv2，初始情况下，R2能够学习到192.168.1.0&#x2F;24、192.168.2.0&#x2F;24及192.168.3.0&#x2F;24这三条RIP路由。而R3也能够通过RIP学习到这三条路由，此外还会学习到10.1.12.0&#x2F;24路由。</p><p>现在希望禁止R3通过RIP学习到192.168.2.0&#x2F;24路由，我们可以在R2上部署Filter-Policy，将192.168.2.0&#x2F;24路由从通告给 R3 的路由中过滤掉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#创建基本acl，编号2000，拦截192.168.2.00 /24路由信息</span><br><span class="line">[R2]acl 2000</span><br><span class="line">[R2-acl-basic-2000]rule deny source 192.168.2.0 0.0.0.0</span><br><span class="line">[R2-acl-basic-2000]rule permit</span><br><span class="line">[R2-acl-basic-2000]q</span><br><span class="line">#进入rip进程1，执行filter-policy调用acl2000在G0/0/1出口方向进行过滤</span><br><span class="line">[R2]rip 1</span><br><span class="line">[R2-rip-1]filter-policy 2000 export GigabitEthernet 0/0/1</span><br></pre></td></tr></table></figure><p>filter-policy并不需要像Route-Policy那样提前创建；直接在进程下即可配置。</p><p>此处拓扑里，R2不禁止192.168.2.0&#x2F;24的路由，因此是在出方向调用。</p><p>可以分别检查R2与R3的RIP路由表，可以发现R2有192.168.2.0&#x2F;24的路由，而R3没有。</p><p>如果配置在入方向：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[R2]rip 1</span><br><span class="line">[R2-rip-1]filter-policy 2000 import GigabitEthernet 0/0/0</span><br></pre></td></tr></table></figure><p>那么R2的RIP路由表就没有192.168.2.0&#x2F;24的路由：</p><blockquote><p>如果是刚设的，因为之间收集的路由还没过期，所以暂时会发现还在，等过期后就没有192.168.2.0&#x2F;24的路由了。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[R2]display rip 1 route </span><br><span class="line"> Route Flags : R - RIP</span><br><span class="line">               A - Aging, G - Garbage-collect</span><br><span class="line"> ----------------------------------------------------------------------------</span><br><span class="line"> Peer 10.1.12.1 on GigabitEthernet0/0/0</span><br><span class="line">      Destination/Mask        Nexthop     Cost   Tag     Flags   Sec</span><br><span class="line">      192.168.3.0/24         10.1.12.1      1    0        RA      15</span><br><span class="line">      192.168.1.0/24         10.1.12.1      1    0        RA      15</span><br></pre></td></tr></table></figure><h3 id="在OSPF网络中过滤路由"><a href="#在OSPF网络中过滤路由" class="headerlink" title="在OSPF网络中过滤路由"></a>在OSPF网络中过滤路由</h3><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/ddf7518060e989eec1668.png"></p><p>如图所示，R1、R2、R3、R4一起组成一个OSPF网络，R2、R3、R4处于area0区域，R1、R2处于area1区域。</p><p>R4一侧连接一个有R5存在的RIP网络。R1上连接了三个直连网段，且并未激活OSPF。</p><ol><li>现在我们希望R1引入直连路由，但不引入192.168.2.0的路由。</li><li>而192.168.3.0的路由不传给R4。</li><li>在R4上引入RIP路由，但不传给area1区域。</li></ol><p>让我们一个一个需求来。</p><h4 id="过滤引入的直连路由（不引入192-168-2-0的路由）"><a href="#过滤引入的直连路由（不引入192-168-2-0的路由）" class="headerlink" title="过滤引入的直连路由（不引入192.168.2.0的路由）"></a>过滤引入的直连路由（不引入192.168.2.0的路由）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#创建基本acl，拦截192.168.2.0的路由</span><br><span class="line">[R1]acl 2000                </span><br><span class="line">[R1-acl-basic-2000]rule deny source 192.168.2.0 0.0.0.0</span><br><span class="line">[R1-acl-basic-2000]rule permit</span><br><span class="line">[R1-acl-basic-2000]q</span><br><span class="line">#在ospf进程下使用filter-policy绑定acl过滤器（引入路由需要写为export）</span><br><span class="line">[R1]ospf 1</span><br><span class="line">[R1-ospf-1]filter-policy 2000 export </span><br><span class="line">[R1-ospf-1]import-route direct </span><br></pre></td></tr></table></figure><blockquote><p>需要解释一下：</p><p>从整个OSPF网络的角度来看，我们是在”引入”路由。然而，在filter-policy命令中使用export而不是import是有原因的。</p><p>以R1为视角，它自身是持有这些路由信息了，是与它相连的OSPF网络中的其他路由没有。</p><p>我们“引入”路由，其实是“发布”R1已有的路由给其他OSPF路由器。</p><p>使用export表示我们要在路由被OSPF接受并准备发送给其他OSPF邻居之前进行过滤。</p><p>这样可以确保不符合ACL条件的路由不会进入OSPF的路由数据库，也不会被发送给其他OSPF路由器。</p></blockquote><p>在R1上执行完以上命令，可以检查发现R1确实不会发布带有192.168.2.0的LSA信息给其他路由器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[R1]display ospf 1 lsdb originate-router 1.1.1.1</span><br><span class="line"></span><br><span class="line"> OSPF Process 1 with Router ID 1.1.1.1</span><br><span class="line"> Link State Database </span><br><span class="line"></span><br><span class="line">         Area: 0.0.0.1</span><br><span class="line"> Type      LinkState ID    AdvRouter          Age  Len   Sequence   Metric</span><br><span class="line"> Router    1.1.1.1         1.1.1.1             91  36    80000006       1</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> AS External Database</span><br><span class="line"> Type      LinkState ID    AdvRouter          Age  Len   Sequence   Metric</span><br><span class="line"> External  192.168.3.0     1.1.1.1             91  36    80000001       1</span><br><span class="line"> External  192.168.1.0     1.1.1.1             91  36    80000001       1</span><br><span class="line"> External  10.1.12.0       1.1.1.1             91  36    80000001       1</span><br></pre></td></tr></table></figure><h4 id="过滤OSPF中传输的路由（192-168-3-0的路由不传给R4）"><a href="#过滤OSPF中传输的路由（192-168-3-0的路由不传给R4）" class="headerlink" title="过滤OSPF中传输的路由（192.168.3.0的路由不传给R4）"></a>过滤OSPF中传输的路由（192.168.3.0的路由不传给R4）</h4><p>我们很容易就想到，可以在R3的出方向过滤拦截，让192.168.3.0的路由不发送给R4。</p><p>那我们配置一下试试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[R3]acl 2000</span><br><span class="line">[R3-acl-basic-2000]rule deny source 192.168.3.0 0.0.0.0</span><br><span class="line">[R3-acl-basic-2000]rule permit </span><br><span class="line">[R3-acl-basic-2000]q</span><br><span class="line">[R3]ospf 1</span><br><span class="line">[R3-ospf-1]filter-policy 2000 export </span><br></pre></td></tr></table></figure><p>但可以发现，没有作用，甚至通过重新引入路由来刷新lsdb表了，依旧存在192.168.3.0的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[R4]display ospf 1 lsdb</span><br><span class="line"></span><br><span class="line"> OSPF Process 1 with Router ID 4.4.4.4</span><br><span class="line"> Link State Database </span><br><span class="line"></span><br><span class="line">         Area: 0.0.0.0</span><br><span class="line"> Type      LinkState ID    AdvRouter          Age  Len   Sequence   Metric</span><br><span class="line"> Router    4.4.4.4         4.4.4.4           1706  36    80000005       1</span><br><span class="line"> Router    2.2.2.2         2.2.2.2           1694  36    80000005       1</span><br><span class="line"> Router    3.3.3.3         3.3.3.3           1689  48    80000009       1</span><br><span class="line"> Network   10.1.23.3       3.3.3.3           1689  32    80000003       0</span><br><span class="line"> Network   10.1.34.4       4.4.4.4           1706  32    80000002       0</span><br><span class="line"> Sum-Net   10.1.12.0       2.2.2.2           1685  28    80000002       1</span><br><span class="line"> Sum-Asbr  1.1.1.1         2.2.2.2              6  28    80000001       1</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> AS External Database</span><br><span class="line"> Type      LinkState ID    AdvRouter          Age  Len   Sequence   Metric</span><br><span class="line"> External  192.168.3.0     1.1.1.1              7  36    80000001       1</span><br><span class="line"> External  192.168.1.0     1.1.1.1              7  36    80000001       1</span><br><span class="line"> External  10.1.12.0       1.1.1.1              7  36    80000001       1</span><br><span class="line"></span><br><span class="line">[R4]display ospf 1 routing </span><br><span class="line"></span><br><span class="line"> OSPF Process 1 with Router ID 4.4.4.4</span><br><span class="line">  Routing Tables </span><br><span class="line"></span><br><span class="line"> Routing for Network </span><br><span class="line"> Destination        Cost  Type       NextHop         AdvRouter       Area</span><br><span class="line"> 10.1.34.0/24       1     Transit    10.1.34.4       4.4.4.4         0.0.0.0</span><br><span class="line"> 10.1.12.0/24       3     Inter-area 10.1.34.3       2.2.2.2         0.0.0.0</span><br><span class="line"> 10.1.23.0/24       2     Transit    10.1.34.3       3.3.3.3         0.0.0.0</span><br><span class="line"></span><br><span class="line"> Routing for ASEs</span><br><span class="line"> Destination        Cost      Type       Tag         NextHop         AdvRouter</span><br><span class="line"> 192.168.1.0/24     1         Type2      1           10.1.34.3       1.1.1.1</span><br><span class="line"> 192.168.3.0/24     1         Type2      1           10.1.34.3       1.1.1.1</span><br><span class="line"></span><br><span class="line"> Total Nets: 5  </span><br><span class="line"> Intra Area: 2  Inter Area: 1  ASE: 2  NSSA: 0 </span><br></pre></td></tr></table></figure><p>这是因为filter-policy只会过滤路由信息，而OSPF这边链路状态协议传递的是链路状态信息，不会被filter-policy匹配过滤。</p><p>不过，OSPF设计了如果在入方向使用filter-policy的话，可以让OSPF路由表内路由导入到本地ip路由表的这个动作对LSA进行filter-policy过滤。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">[R4]acl 2000</span><br><span class="line">[R4-acl-basic-2000]rule deny source 192.168.3.0 0.0.0.0</span><br><span class="line">[R4-acl-basic-2000]rule permit </span><br><span class="line">[R4-acl-basic-2000]q</span><br><span class="line">[R4]ospf 1</span><br><span class="line">[R4-ospf-1]filter-policy 2000 import </span><br><span class="line"></span><br><span class="line">#检查R4的IP路由表，没有192.168.3.0 /24的路由</span><br><span class="line">[R4]display ip routing-table</span><br><span class="line">Route Flags: R - relay, D - download to fib</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Routing Tables: Public</span><br><span class="line">         Destinations : 14       Routes : 14       </span><br><span class="line"></span><br><span class="line">Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</span><br><span class="line"></span><br><span class="line">        5.5.5.5/32  RIP     100  1           D   10.1.45.5       GigabitEthernet0/0/1</span><br><span class="line">      10.1.12.0/24  OSPF    10   3           D   10.1.34.3       GigabitEthernet0/0/0</span><br><span class="line">      10.1.23.0/24  OSPF    10   2           D   10.1.34.3       GigabitEthernet0/0/0</span><br><span class="line">      10.1.34.0/24  Direct  0    0           D   10.1.34.4       GigabitEthernet0/0/0</span><br><span class="line">      10.1.34.4/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/0</span><br><span class="line">    10.1.34.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/0</span><br><span class="line">      10.1.45.0/24  Direct  0    0           D   10.1.45.4       GigabitEthernet0/0/1</span><br><span class="line">      10.1.45.4/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/1</span><br><span class="line">    10.1.45.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/1</span><br><span class="line">      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">    192.168.1.0/24  O_ASE   150  1           D   10.1.34.3       GigabitEthernet0/0/0</span><br><span class="line">255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line"></span><br><span class="line">#但在OSPF路由表中是有该信息的</span><br><span class="line">[R4]dis ospf 1 routing </span><br><span class="line"></span><br><span class="line"> OSPF Process 1 with Router ID 4.4.4.4</span><br><span class="line">  Routing Tables </span><br><span class="line"></span><br><span class="line"> Routing for Network </span><br><span class="line"> Destination        Cost  Type       NextHop         AdvRouter       Area</span><br><span class="line"> 10.1.34.0/24       1     Transit    10.1.34.4       4.4.4.4         0.0.0.0</span><br><span class="line"> 10.1.12.0/24       3     Inter-area 10.1.34.3       2.2.2.2         0.0.0.0</span><br><span class="line"> 10.1.23.0/24       2     Transit    10.1.34.3       3.3.3.3         0.0.0.0</span><br><span class="line"></span><br><span class="line"> Routing for ASEs</span><br><span class="line"> Destination        Cost      Type       Tag         NextHop         AdvRouter</span><br><span class="line"> 192.168.1.0/24     1         Type2      1           10.1.34.3       1.1.1.1</span><br><span class="line"> 192.168.3.0/24     1         Type2      1           10.1.34.3       1.1.1.1</span><br><span class="line"></span><br><span class="line"> Total Nets: 5  </span><br><span class="line"> Intra Area: 2  Inter Area: 1  ASE: 2  NSSA: 0 </span><br></pre></td></tr></table></figure><h4 id="扩展一下：能不能过滤到达area1的RIP外部路由"><a href="#扩展一下：能不能过滤到达area1的RIP外部路由" class="headerlink" title="扩展一下：能不能过滤到达area1的RIP外部路由"></a>扩展一下：能不能过滤到达area1的RIP外部路由</h4><p>在R2上的入方向进行过滤，这次我们用地址前缀的方式过滤吧，换换口味熟悉一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ip-prefix默认动作为拒绝，所以逻辑上我们要放行所有信息，再去单独拦截RIP网络中的10.1.45.0 24。</span><br><span class="line">[R2]ip ip-prefix norip deny 10.1.45.0 24</span><br><span class="line">[R2]ip ip-prefix norip permit 0.0.0.0 0 less-equal 32</span><br><span class="line">[R2]ospf 1</span><br><span class="line">[R2-ospf-1]filter-policy ip-prefix norip import </span><br></pre></td></tr></table></figure><p>配置完成后，我们在R4上引入RIP路由再来检查一下R2的情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[R2]dis ip routing-table </span><br><span class="line">Route Flags: R - relay, D - download to fib</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Routing Tables: Public</span><br><span class="line">         Destinations : 14       Routes : 14       </span><br><span class="line"></span><br><span class="line">Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</span><br><span class="line"></span><br><span class="line">        5.5.5.5/32  O_ASE   150  1           D   10.1.23.3       GigabitEthernet0/0/1</span><br><span class="line">      10.1.12.0/24  Direct  0    0           D   10.1.12.2       GigabitEthernet0/0/0</span><br><span class="line">      10.1.12.2/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/0</span><br><span class="line">    10.1.12.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/0</span><br><span class="line">      10.1.23.0/24  Direct  0    0           D   10.1.23.2       GigabitEthernet0/0/1</span><br><span class="line">      10.1.23.2/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/1</span><br><span class="line">    10.1.23.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/1</span><br><span class="line">      10.1.34.0/24  OSPF    10   2           D   10.1.23.3       GigabitEthernet0/0/1</span><br><span class="line">      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">    192.168.1.0/24  O_ASE   150  1           D   10.1.12.1       GigabitEthernet0/0/0</span><br><span class="line">    192.168.3.0/24  O_ASE   150  1           D   10.1.12.1       GigabitEthernet0/0/0</span><br><span class="line">255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br></pre></td></tr></table></figure><p>可以看到代表RIP网络的10.1.45.0的路由并没有加载到R2的ip路由表中，这符合我们之前使用acl在入方向的过滤结果。</p><blockquote><p>另外，我留了一个R5的回环地址5.5.5.5，以表示RIP路由确实已经被引入OSPF网络中了。</p></blockquote><p>然而，R2的LSDB表中还是存在10.1.45.0的LSA信息。（这边就不展示LSDB表了）</p><p>因此，R2在传递LSA信息的时候，依旧将带有10.1.45.0的LSA发送到area1区域内。</p><p>所以在R1上还是能看到RIP网络的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#在R1上检查宣告者为4.4.4.4的lsdb表，发现存在10.1.45.0</span><br><span class="line">[R1]display ospf 1 lsdb originate-router 4.4.4.4</span><br><span class="line"></span><br><span class="line"> OSPF Process 1 with Router ID 1.1.1.1</span><br><span class="line"> Link State Database </span><br><span class="line"></span><br><span class="line">         Area: 0.0.0.1</span><br><span class="line"> Type      LinkState ID    AdvRouter          Age  Len   Sequence   Metric</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> AS External Database</span><br><span class="line"> Type      LinkState ID    AdvRouter          Age  Len   Sequence   Metric</span><br><span class="line"> External  10.1.45.0       4.4.4.4            735  36    80000001       1</span><br><span class="line"> External  5.5.5.5         4.4.4.4            735  36    80000001       1</span><br><span class="line"> External  10.1.34.0       4.4.4.4            735  36    80000001       1</span><br><span class="line"> </span><br><span class="line">#在R1上检查ip路由表，也是存在10.1.45.0</span><br><span class="line">[R1]display ip routing-table </span><br><span class="line">Route Flags: R - relay, D - download to fib</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Routing Tables: Public</span><br><span class="line">         Destinations : 20       Routes : 20       </span><br><span class="line"></span><br><span class="line">Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</span><br><span class="line"></span><br><span class="line">        5.5.5.5/32  O_ASE   150  1           D   10.1.12.2       GigabitEthernet0/0/0</span><br><span class="line">      10.1.12.0/24  Direct  0    0           D   10.1.12.1       GigabitEthernet0/0/0</span><br><span class="line">      10.1.12.1/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/0</span><br><span class="line">    10.1.12.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/0</span><br><span class="line">      10.1.23.0/24  OSPF    10   2           D   10.1.12.2       GigabitEthernet0/0/0</span><br><span class="line">      10.1.34.0/24  OSPF    10   3           D   10.1.12.2       GigabitEthernet0/0/0</span><br><span class="line">      10.1.45.0/24  O_ASE   150  1           D   10.1.12.2       GigabitEthernet0/0/0</span><br><span class="line">      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">    192.168.1.0/24  Direct  0    0           D   192.168.1.254   LoopBack1</span><br><span class="line">  192.168.1.254/32  Direct  0    0           D   127.0.0.1       LoopBack1</span><br><span class="line">  192.168.1.255/32  Direct  0    0           D   127.0.0.1       LoopBack1</span><br><span class="line">    192.168.2.0/24  Direct  0    0           D   192.168.2.254   LoopBack2</span><br><span class="line">  192.168.2.254/32  Direct  0    0           D   127.0.0.1       LoopBack2</span><br><span class="line">  192.168.2.255/32  Direct  0    0           D   127.0.0.1       LoopBack2</span><br><span class="line">    192.168.3.0/24  Direct  0    0           D   192.168.3.254   LoopBack3</span><br><span class="line">  192.168.3.254/32  Direct  0    0           D   127.0.0.1       LoopBack3</span><br><span class="line">  192.168.3.255/32  Direct  0    0           D   127.0.0.1       LoopBack3</span><br><span class="line">255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>对于OSPF来说，只能在宣告路由器上拦截外部路由，对于正在传输的路由不能完全拦截。</p><p>只能做到对单独一台路由器禁止指定的路由被启用（加载进ip路由表）。</p><h1 id="策略路由"><a href="#策略路由" class="headerlink" title="策略路由"></a>策略路由</h1><p>首先让我们回顾一下传统IP路由的概念，所谓的路由，指的是当路由设备收到一个IP报文时，在其路由表中查询该报文的<strong>目的IP地址</strong>，在找到最匹配的路由表项后，按照该表项所指示的出接口及下一跳IP地址转发该报文。</p><p>从这个描述可以看出，<strong>路由行为只关心报文的目的IP地址，而并不关心其源IP地址</strong>。</p><p>当面对一些特殊的需求时，传统的路由行为是存在短板的。</p><p>所谓的策略路由，即是基于策略的路由(**Policy-Based Routing, PBR)**。</p><p>与单纯依照IP报文的目的地址查找路由表进行转发不同，策略路由是一种依据用户制定的策略进行路由转发的机制。</p><p>策略路由可以对于满足一定条件（ACL规则）的报文，执行指定的操作（设置报文的下一跳、SRv6 TE  Policy、出接口等）。</p><p>为了避免混淆，我们再列举一下路由策略与策略路由的的概念：</p><table><thead><tr><th>名称</th><th>作用</th><th>操作对象</th></tr></thead><tbody><tr><td>路由策略</td><td>对“路由信息”进行过滤，或修改其属性的策略操作，本质是策略</td><td>路由信息</td></tr><tr><td>策略路由</td><td>对“数据报文”的转发过程进行自带义操作，本质是路由</td><td>数据报文</td></tr></tbody></table><p>策略路由一样也是多种具体技术的统称，根据作用对象的不同，策略路由可分为以下两种类型：</p><ul><li>本地策略路由：对设备本身产生的报文（比如本地发出的ping报文）起作用，指导其发送。</li><li>接口策略路由：对接口接收的报文起作用，指导其转发。</li></ul><p>另外还有一种智能策略路由，主要是增加智能检测链路状态，以满足通过匹配链路质量和网络业务对链路质量的需求，实现智能选路。</p><h2 id="本地策略路由"><a href="#本地策略路由" class="headerlink" title="本地策略路由"></a>本地策略路由</h2><p>本地策略路由<strong>仅对本机下发的报文进行处理，对转发的报文不起作用。</strong></p><p>一条本地策略路由可以配置多个策略点，并且这些策略点具有不同的优先级，本机下发报文优先匹配优先级高的策略点。</p><p>本机下发报文时，根据本地策略路由节点的优先级，依次匹配各节点绑定的匹配规则，本地策略路由支持基于ACL或报文长度的匹配规则。</p><p>本地策略路由的实现逻辑与路由策略中的Route-Policy十分相似。</p><h3 id="配置本地策略路由"><a href="#配置本地策略路由" class="headerlink" title="配置本地策略路由"></a>配置本地策略路由</h3><p>在配置本地策略路由之前，需完成以下任务：</p><ul><li>配置接口的链路层协议参数，使接口的链路协议状态为Up。</li><li>配置用于匹配报文的ACL。</li><li>如果希望报文进入VPN，则需要预先配置VPN。</li></ul><h4 id="配置匹配条件"><a href="#配置匹配条件" class="headerlink" title="配置匹配条件"></a>配置匹配条件</h4><ol><li><p>执行命令<strong>system-view</strong>，进入系统视图。</p></li><li><p>执行命令<strong>policy-based-route</strong> <em>policy-name</em> { <strong>deny</strong> | <strong>permit</strong> } <strong>node</strong> <em>node-id</em>，创建策略路由和策略点，若策略点已创建则进入本地策略路由视图。</p><ul><li><strong>permit</strong>表示对满足匹配条件的报文进行策略路由，<strong>deny</strong>表示对满足匹配条件的报文不进行策略路由。</li><li>重复执行该命令可以在一条本地策略路由下创建多个策略点，策略点由顺序号<em>node-id</em>来指定，顺序号的值越小则优先级越高，相应策略优先执行。</li></ul></li><li><p>执行如下命令，可以只执行一条也可以两条都执行，设置IP报文匹配条件。</p><ul><li><p>执行命令<strong>if-match acl</strong> <em>acl-number</em>，设置IP报文的ACL匹配条件。</p><blockquote><ul><li>当ACL的rule配置为<strong>permit</strong>时，设备会对匹配该规则的报文执行本地策略路由的动作：<ul><li>本地策略路由中策略点为<strong>permit</strong>时对满足匹配条件的报文进行策略路由；</li><li>本地策略路由中策略点为<strong>deny</strong>时对满足匹配条件的报文不进行策略路由，即根据目的地址查找路由表转发报文。</li></ul></li><li>当报文匹配的ACL的rule配置为**deny **或 报文未匹配上任何规则，则根据目的地址查找路由表转发报文。</li></ul></blockquote></li><li><p>执行命令<strong>if-match packet-length</strong> min-length max-length，设置IP报文长度匹配条件。</p></li></ul></li></ol><h4 id="配置执行动作"><a href="#配置执行动作" class="headerlink" title="配置执行动作"></a>配置执行动作</h4><ol><li><p>执行命令<strong>policy-based-route</strong> <em>policy-name</em> { <strong>deny</strong> | <strong>permit</strong> } <strong>node</strong> <em>node-id</em> ，进入已创建的本地策略路由视图。</p></li><li><p>执行如下命令，配置策略路由的动作。一个策略点中至少包含一条<strong>apply</strong>子句，也可以多条<strong>apply</strong>子句组合使用。</p><ul><li><p>执行命令<strong>apply output-interface</strong> interface-type interface-number，指定本地策略路由中报文的出接口。</p><blockquote><ul><li>报文的出接口不能为以太接口等广播型接口。</li><li>如果策略中设置了两个出接口，那么报文转发在两个出接口之间负载分担。</li><li>如果先使用命令配置了两个出接口，然后又执行该命令配置了一个出接口，则后配置的出接口将覆盖前面配置的第一个出接口，而第二个出接口不会被覆盖。</li></ul></blockquote></li><li><p>执行命令<strong>apply ip-address next-hop</strong> ip-address1 [ ip-address2 ]，设置本地策略路由中报文的下一跳。</p><p>用户可以指定报文的下一跳。</p><blockquote><ul><li>报文的下一跳地址不能是本设备的IP地址。</li><li>如果策略中设置了两个下一跳，那么报文转发在两个下一跳之间负载分担。</li><li>如果先使用命令配置了两个下一跳，然后又执行该命令配置了一个下一跳，则后配置的下一跳将覆盖前面配置的第一个下一跳，而第二个下一跳不会被覆盖。</li></ul></blockquote></li><li><p>执行命令<strong>apply ip-address next-hop</strong> { <em>ip-address1</em> <strong>track</strong> <strong>ip-route</strong> <em>ip-address2</em> { <em>mask</em> | <em>mask-length</em> } } &amp;&lt;1-2&gt;，配置本地策略路由的下一跳联动路由功能。</p></li><li><p>执行命令<strong>apply ip-address backup-nexthop</strong> <em>ip-address</em>，配置本地策略路由中报文转发的备份下一跳。</p></li></ul></li></ol><h4 id="配置启用本地策略路由"><a href="#配置启用本地策略路由" class="headerlink" title="配置启用本地策略路由"></a>配置启用本地策略路由</h4><ol><li>执行命令<strong>system-view</strong>，进入系统视图。</li><li>应用本地策略路由：<ul><li>执行命令<strong>ip local policy-based-route</strong> <em>policy-name</em>，使能本地策略路由。</li><li>执行命令<strong>ip local route-based-source enable</strong>，使能等价路由多上行的场景下本机发出的报文会基于报文源地址选择出接口功能。</li></ul></li></ol><h2 id="接口策略路由（流策略）"><a href="#接口策略路由（流策略）" class="headerlink" title="接口策略路由（流策略）"></a>接口策略路由（流策略）</h2><p>配置接口策略路由可以将到达接口的三层报文<strong>重定向到指定的下一跳地址</strong>。</p><p><strong>接口策略路由只对转发的报文起作用</strong>，对本地下发的报文（比如本地的Ping报文）不起作用。</p><h3 id="数据流、流分类、流行为"><a href="#数据流、流分类、流行为" class="headerlink" title="数据流、流分类、流行为"></a>数据流、流分类、流行为</h3><p><strong>数据流</strong>是指在网络中传输的一系列相关数据包的集合。这些数据包通常属于同一会话或应用程序，具有相同的源和目的地址。</p><p> 通常是双向的，有上行和下行流量。通过源IP、目的IP、源端口、目的端口和协议这五元组来唯一标识</p><p><strong>流分类</strong>是对网络中不同数据流的进行分类标识。这是实现网络质量服务(QoS)、安全策略和流量管理的基础。</p><blockquote><p>分类方法:</p><ul><li>基于协议: 如TCP、UDP、HTTP、FTP等</li><li>基于应用: 如视频流、语音通话、邮件等</li><li>基于用户或设备: 通过IP地址或MAC地址识别</li><li>基于服务等级: 如高优先级业务流、普通业务流等</li></ul></blockquote><p><strong>流行为</strong>描述了数据流在网络中的特征和模式。</p><p>在策略路由中，我们是要手动配置流行为，修改指定数据流的动作。</p><h3 id="配置流分类与流行为"><a href="#配置流分类与流行为" class="headerlink" title="配置流分类与流行为"></a>配置流分类与流行为</h3><p>在配置接口策略路由前，需要完成以下任务：</p><ul><li>配置相关接口的IP地址和路由协议，保证路由互通。</li><li>如果使用ACL作为接口策略路由的流分类规则，配置相应的ACL。</li></ul><h4 id="配置流分类"><a href="#配置流分类" class="headerlink" title="配置流分类"></a>配置流分类</h4><ol><li><p>执行命令<strong>system-view</strong>，进入系统视图。</p></li><li><p>执行命令<strong>traffic classifier</strong> <em>classifier-name</em> [ <strong>operator</strong> { <strong>and</strong> | <strong>or</strong> } ]，创建一个流分类，进入流分类视图。</p><blockquote><p><strong>and</strong>表示流分类中各规则之间关系为“逻辑与”，指定该逻辑关系后：</p><ul><li>当流分类中有ACL规则时，报文必须匹配其中一条ACL规则以及所有非ACL规则才属于该类。</li><li>当流分类中没有ACL规则时，则报文必须匹配所有非ACL规则才属于该类。</li></ul><p><strong>or</strong>表示流分类各规则之间是“逻辑或”，即报文只需匹配流分类中的一个或多个规则即属于该类。</p><p>默认情况下，流分类中各规则之间的关系为“逻辑或”。</p></blockquote></li><li><p>请根据实际情况配置流分类中的匹配规则。（可以匹配高级ACL ，因此一般ACL就够满足需求了）</p><table><thead><tr><th>匹配规则</th><th>命令</th></tr></thead><tbody><tr><td>ACL规则</td><td><strong>if-match acl</strong> { <em>acl-number</em> | <em>acl-name</em> }</td></tr><tr><td>外层VLAN ID</td><td><strong>if-match vlan-id</strong> <em>start-vlan-id</em> [ <strong>to</strong> <em>end-vlan-id</em> ]</td></tr><tr><td>目的MAC地址</td><td><strong>if-match destination-mac</strong> <em>mac-address</em> [ <strong>mac-address-mask</strong> <em>mac-address-mask</em> ]</td></tr><tr><td>源MAC地址</td><td><strong>if-match source-mac</strong> <em>mac-address</em> [ <strong>mac-address-mask</strong> <em>mac-address-mask</em> ]</td></tr><tr><td><strong>以太网帧</strong>头中协议类型字段</td><td><strong>if-match l2-protocol</strong> { <strong>arp</strong> | <strong>ip</strong> | <strong>rarp</strong> | <em>protocol-value</em> }</td></tr><tr><td>所有报文</td><td><strong>if-match any</strong></td></tr><tr><td>入接口</td><td><strong>if-match inbound-interface</strong> <em>interface-type</em> <em>interface-number</em></td></tr><tr><td>出接口</td><td><strong>if-match outbound-interface</strong> <strong>Cellular</strong> <em>interface-number:channel</em></td></tr></tbody></table><blockquote><p>部分不常用的匹配条件未列出，可自行翻阅对应产品文档。</p></blockquote></li><li><p>执行命令<strong>quit</strong>，退出流分类视图。</p></li></ol><h4 id="配置流行为"><a href="#配置流行为" class="headerlink" title="配置流行为"></a>配置流行为</h4><ol><li><p>执行命令<strong>traffic behavior</strong> <em>behavior-name</em>，创建一个流行为并进入流行为视图，或进入已存在的流行为视图。</p></li><li><p>请根据实际需要进行如下配置：</p><ul><li><p>执行命令<strong>redirect ip-nexthop</strong> <em>ip-address</em> [ <strong>vpn-instance</strong> <em>vpn-instance-name</em> ] [ <strong>track</strong> { <strong>nqa</strong> <em>admin-name</em> <em>test-name</em> | <strong>ip-route</strong> <em>ip-address</em> { <em>mask</em> | <em>mask-length</em> } | } ] [ <strong>post-nat</strong> ] [ <strong>discard</strong> ] [ <strong>sfc-nsh</strong> <strong>spi</strong> <em>spi-index</em> <strong>si</strong> <em>si-index</em> ]，将符合流分类的报文重定向到下一跳，可选配置重定向与NQA测试例或IP路由联动。</p><blockquote><p>NQA（Network Quality Analysis）是网络故障诊断和定位的有效工具，路由状态则可以直接反映出目的IP是否可达，配置NQA&#x2F;路由与重定向联动功能，可以在目的IP不可达时，实现链路快速切换，保障用户流量正常转发：</p><ul><li>当NQA&#x2F;路由模块检测到目的IP可达时，按照指定的IP进行报文转发，即重定向生效。</li><li>当NQA&#x2F;路由模块检测到目的IP不可达时，重定向不生效，如果用户未配置<strong>discard</strong>参数，系统将按原来的转发路径转发报文，否则报文将被丢弃。</li></ul></blockquote></li><li><p>执行命令<strong>redirect ipv6-nexthop</strong> <em>ipv6-address</em> [ <strong>track</strong> { <strong>nqa</strong> <em>nqa-admin</em> <em>nqa-name</em> | <strong>ipv6-route</strong> <em>ipv6–address</em> <em>masklen</em> } ] [ <strong>discard</strong> ]，将符合流分类的IPv6报文重定向到下一跳。</p></li><li><p>执行命令<strong>redirect interface</strong> <em>interface-type</em> <em>interface-number</em> [ <strong>track</strong> { <strong>nqa</strong> <em>admin-name</em> <em>test-name</em> | <strong>ip-route</strong> <em>ip-address</em> { <em>mask</em> | <em>mask-length</em> } [ <strong>weak</strong> ] | <strong>ipv6-route</strong> <em>ipv6-address</em> <em>mask-length</em> } ] [ <strong>discard</strong> ]，将符合流分类的报文重定向到指定接口。</p><blockquote><ul><li>包含重定向动作的流策略只能在接口的入方向上应用。</li></ul></blockquote></li></ul></li><li><p>执行命令<strong>quit</strong>，退出流行为视图。</p></li><li><p>执行命令<strong>quit</strong>，退出系统视图。</p></li></ol><h4 id="配置流策略"><a href="#配置流策略" class="headerlink" title="配置流策略"></a>配置流策略</h4><ol><li>执行命令<strong>system-view</strong>，进入系统视图。</li><li>执行命令<strong>traffic policy</strong> <em>policy-name</em>，创建一个流策略并进入流策略视图，或进入已存在的流策略视图。</li><li>执行命令<strong>classifier</strong> <em>classifier-name</em> <strong>behavior</strong> <em>behavior-name</em> [ <strong>precedence</strong> <em>precedence-value</em> ]，在流策略中为指定的流分类配置所需流行为，即<strong>绑定流分类和流行为。</strong></li><li>执行命令<strong>quit</strong>，退出流策略视图。</li><li>执行命令<strong>quit</strong>，退出系统视图。</li></ol><h4 id="应用流策略"><a href="#应用流策略" class="headerlink" title="应用流策略"></a>应用流策略</h4><ol><li><p>执行命令<strong>system-view</strong>，进入系统视图。</p></li><li><p>执行命令<strong>interface</strong> <em>interface-type</em> <em>interface-number</em> [.<em>subinterface-number</em> ]，进入接口视图或子接口视图。</p></li><li><p>执行命令<strong>traffic-policy</strong> <em>policy-name</em> <strong>inbound</strong>，在接口或子接口的入方向应用流策略。</p><p>目前，<strong>接口策略路由仅支持在接口的入方向上应用。</strong></p></li></ol><h2 id="策略路由应用案例"><a href="#策略路由应用案例" class="headerlink" title="策略路由应用案例"></a>策略路由应用案例</h2><p>注：以下都是自嗨式案例介绍，现网中不要这样玩。</p><h3 id="本地策略路由的简单验证"><a href="#本地策略路由的简单验证" class="headerlink" title="本地策略路由的简单验证"></a>本地策略路由的简单验证</h3><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/ac6394463c964f8367a4f.png"></p><p>如图，设计了2台路由器与2台PC。PC1与R1处于192.168.1.0&#x2F;24网段，R1与R2处于10.1.12.0&#x2F;24网段，R2与PC2处于192.168.2.0&#x2F;24网段。</p><p><strong>我们不在R1或R2上配置路由，只保留了直连路由。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[R1]display ip routing-table </span><br><span class="line">Route Flags: R - relay, D - download to fib</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Routing Tables: Public</span><br><span class="line">         Destinations : 10       Routes : 10       </span><br><span class="line"></span><br><span class="line">Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</span><br><span class="line"></span><br><span class="line">      10.1.12.0/24  Direct  0    0           D   10.1.12.1       GigabitEthernet0/0/0</span><br><span class="line">      10.1.12.1/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/0</span><br><span class="line">    10.1.12.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/0</span><br><span class="line">      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">    192.168.1.0/24  Direct  0    0           D   192.168.1.254   GigabitEthernet0/0/1</span><br><span class="line">  192.168.1.254/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/1</span><br><span class="line">  192.168.1.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/1</span><br><span class="line">255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br></pre></td></tr></table></figure><p>很明显，因为R1缺少到192.168.2.0网段的路由，无法访问PC2。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[R1]ping 192.168.2.2</span><br><span class="line">  PING 192.168.2.2: 56  data bytes, press CTRL_C to break</span><br><span class="line">    Request time out</span><br><span class="line">    Request time out</span><br><span class="line">    Request time out</span><br><span class="line">    Request time out</span><br><span class="line">    Request time out</span><br><span class="line"></span><br><span class="line">  --- 192.168.2.2 ping statistics ---</span><br><span class="line">    5 packet(s) transmitted</span><br><span class="line">    0 packet(s) received</span><br><span class="line">    100.00% packet loss</span><br></pre></td></tr></table></figure><blockquote><p>R2一样缺少路由，访问不了PC1，这边就不展示了。</p></blockquote><p><strong>现在我们分别在R1与R2上配置<u>本地策略路由</u>。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#创建高级ACL，编号3001，用于匹配目标地址为192.168.2.0/24网段的数据报文</span><br><span class="line">[R1]acl 3001</span><br><span class="line">[R1-acl-adv-3001]rule 5 permit ip destination 192.168.2.0 0.0.0.255</span><br><span class="line">#创建1名为to2的本地策略路由，节点编号为5</span><br><span class="line">[R1]policy-based-route to2 permit node 5</span><br><span class="line">#本地策略路由的匹配规则设定为acl3001，匹配后执行转发报文到10.1.12.2</span><br><span class="line">[R1-policy-based-route-to2-5]if-match acl 3001</span><br><span class="line">[R1-policy-based-route-to2-5]apply ip-address next-hop 10.1.12.2</span><br><span class="line">#启用该本地策略路由</span><br><span class="line">[R1]ip local policy-based-route to2</span><br><span class="line"></span><br><span class="line">#检测R1能否访问PC2</span><br><span class="line">[R1]ping 192.168.2.2</span><br><span class="line">  PING 192.168.2.2: 56  data bytes, press CTRL_C to break</span><br><span class="line">    Request time out</span><br><span class="line">    Reply from 192.168.2.2: bytes=56 Sequence=2 ttl=127 time=30 ms</span><br><span class="line">    Reply from 192.168.2.2: bytes=56 Sequence=3 ttl=127 time=20 ms</span><br><span class="line">    Reply from 192.168.2.2: bytes=56 Sequence=4 ttl=127 time=20 ms</span><br><span class="line">    Reply from 192.168.2.2: bytes=56 Sequence=5 ttl=127 time=20 ms</span><br><span class="line"></span><br><span class="line">  --- 192.168.2.2 ping statistics ---</span><br><span class="line">    5 packet(s) transmitted</span><br><span class="line">    4 packet(s) received</span><br><span class="line">    20.00% packet loss</span><br><span class="line">    round-trip min/avg/max = 20/22/30 ms</span><br></pre></td></tr></table></figure><p>可以发现，<strong>即使路由表没有路由信息，配置了本地策略路由，也能实现数据报文的转发，证明了策略路由的本质就是路由！</strong></p><p>另外，我们也在R2上配置一下吧，这次我们使用另一种匹配条件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#创建名为to1的本地策略路由，使用报文长度作为匹配条件（设置为0到1500字节），匹配成功后的动作为转发给10.1.12.1</span><br><span class="line">[R2]policy-based-route to1 permit node 5</span><br><span class="line">[R2-policy-based-route-to1-5]if-match packet-length 0 1500</span><br><span class="line">[R2-policy-based-route-to1-5]apply ip-address next-hop 10.1.12.1</span><br><span class="line">[R2-policy-based-route-to1-5]q</span><br><span class="line">[R2]ip local policy-based-route to1</span><br><span class="line"></span><br><span class="line">#测试R2到达PC1</span><br><span class="line">[R2]ping 192.168.1.1</span><br><span class="line">  PING 192.168.1.1: 56  data bytes, press CTRL_C to break</span><br><span class="line">    Request time out</span><br><span class="line">    Reply from 192.168.1.1: bytes=56 Sequence=2 ttl=127 time=10 ms</span><br><span class="line">    Reply from 192.168.1.1: bytes=56 Sequence=3 ttl=127 time=20 ms</span><br><span class="line">    Reply from 192.168.1.1: bytes=56 Sequence=4 ttl=127 time=20 ms</span><br><span class="line">    Reply from 192.168.1.1: bytes=56 Sequence=5 ttl=127 time=20 ms</span><br><span class="line"></span><br><span class="line">  --- 192.168.1.1 ping statistics ---</span><br><span class="line">    5 packet(s) transmitted</span><br><span class="line">    4 packet(s) received</span><br><span class="line">    20.00% packet loss</span><br><span class="line">    round-trip min/avg/max = 10/17/20 ms</span><br></pre></td></tr></table></figure><p>理论上，现在我们实现了全网互通（虽然是使用了策略路由），那么现在让我们试试PC1是否能范围PC2。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PC&gt;ping 192.168.2.2</span><br><span class="line"></span><br><span class="line">Ping 192.168.2.2: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">Request timeout!</span><br><span class="line">Request timeout!</span><br><span class="line">Request timeout!</span><br><span class="line">Request timeout!</span><br><span class="line">Request timeout!</span><br><span class="line"></span><br><span class="line">--- 192.168.2.2 ping statistics ---</span><br><span class="line">  5 packet(s) transmitted</span><br><span class="line">  0 packet(s) received</span><br><span class="line">  100.00% packet loss</span><br></pre></td></tr></table></figure><p>很遗憾，不行。</p><p>原因很简单，因为我们配置的是本地策略路由，只针对路由器本身发出的报文有效，对于来自PC的报文无效。</p><p>现在就让我们在R1、R2上配置接口策略以实现全网互通吧。</p><h3 id="接口策略的简单验证"><a href="#接口策略的简单验证" class="headerlink" title="接口策略的简单验证"></a>接口策略的简单验证</h3><p>由于前面给R1配置过匹配到达192.168.2.0&#x2F;24的ACL规则了，所以我们直接进行如下配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#创建名为to2的流分类，通过acl3001进行判断匹配。</span><br><span class="line">[R1]traffic classifier to2</span><br><span class="line">[R1-classifier-to2]if-match acl 3001</span><br><span class="line">[R1-classifier-to2]q</span><br><span class="line"></span><br><span class="line">#创建名为toR2的流行为，设置执行动作转发到10.1.12.2</span><br><span class="line">[R1]traffic behavior toR2</span><br><span class="line">[R1-behavior-toR2]redirect ip-nexthop 10.1.12.2</span><br><span class="line">[R1-behavior-toR2]q</span><br><span class="line"></span><br><span class="line">#创建名为1to2的流策略，绑定流分类与流行为</span><br><span class="line">[R1]traffic policy 1to2</span><br><span class="line">[R1-trafficpolicy-1to2]classifier to2 behavior toR2</span><br><span class="line">[R1-trafficpolicy-1to2]q</span><br><span class="line"></span><br><span class="line">进入PC1所在接口，在该接口启用流策略</span><br><span class="line">[R1]interface g0/0/1</span><br><span class="line">[R1-GigabitEthernet0/0/1]traffic-policy 1to2 inbound </span><br></pre></td></tr></table></figure><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/eb683da0c7f43f5624dfa.png"></p><p>配置完以上命令，PC1已经可以通向PC2了，在PC2上能够抓到PC1的报文。</p><p>但由于还未在R2进行接口策略路由的配置，PC2回给PC1的报文，PC1无法收到，因此表现为ping不通（超时）。</p><p>现在我们也为R2配置一下吧。（依旧是换换口味熟悉命令）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#创建名为from2的流分类，匹配ipv4报文</span><br><span class="line">[R2]traffic classifier from1</span><br><span class="line">[R2-classifier-from1]if-match protocol ip</span><br><span class="line">[R2-classifier-from1]q</span><br><span class="line"></span><br><span class="line">#创建名为to1的流行为</span><br><span class="line">[R2]traffic behavior to1</span><br><span class="line">[R2-behavior-to2]redirect ip-nexthop 10.1.12.1</span><br><span class="line">[R2-behavior-to2]q</span><br><span class="line"></span><br><span class="line">#创建名为2to1的流策略，绑定流分类与流行为</span><br><span class="line">[R2]traffic policy 2to1</span><br><span class="line">[R2-trafficpolicy-1to2]classifier from2 behavior to1</span><br><span class="line">[R2-trafficpolicy-1to2]q</span><br><span class="line"></span><br><span class="line">#在g0/0/1口上启用该策略</span><br><span class="line">[R2]interface g0/0/1</span><br><span class="line">[R2-GigabitEthernet0/0/1]traffic-policy 2to1 inbound </span><br></pre></td></tr></table></figure><p>现在PC1就可以ping通PC2了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PC&gt;ping 192.168.2.2</span><br><span class="line"></span><br><span class="line">Ping 192.168.2.2: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">Request timeout!</span><br><span class="line">From 192.168.2.2: bytes=32 seq=2 ttl=126 time=15 ms</span><br><span class="line">From 192.168.2.2: bytes=32 seq=3 ttl=126 time=16 ms</span><br><span class="line">From 192.168.2.2: bytes=32 seq=4 ttl=126 time=16 ms</span><br><span class="line">From 192.168.2.2: bytes=32 seq=5 ttl=126 time=31 ms</span><br><span class="line"></span><br><span class="line">--- 192.168.2.2 ping statistics ---</span><br><span class="line">  5 packet(s) transmitted</span><br><span class="line">  4 packet(s) received</span><br><span class="line">  20.00% packet loss</span><br><span class="line">  round-trip min/avg/max = 0/19/31 ms</span><br></pre></td></tr></table></figure><blockquote><p>ensp模拟器中似乎不支持mac地址匹配与接口匹配，至少我原本打算使用这两种进行测试的，却无法通网。</p></blockquote><h4 id="二次验证"><a href="#二次验证" class="headerlink" title="二次验证"></a>二次验证</h4><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/0917db7f20378a2593dec.png"></p><p>我们在R1上将本地策略路由取消启用，会发现R1无法ping通PC2了。</p><p>但这不影响PC1经过R1去ping通PC2。</p><p>这再次说明了，<strong>本地策略路由只作用于路由器本身产生的数据报文，接口策略路由只作用于其他设备产生的数据报文</strong>（经过自身进行转发）。</p><p>此外，再次强调，本案例中并未配置动态路由或静态路由。本地路由表中仅存在直连路由。</p><p>策略路由本身就可以提供“路由”的作用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[R1]display ip routing-table </span><br><span class="line">Route Flags: R - relay, D - download to fib</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Routing Tables: Public</span><br><span class="line">         Destinations : 10       Routes : 10       </span><br><span class="line"></span><br><span class="line">Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</span><br><span class="line"></span><br><span class="line">      10.1.12.0/24  Direct  0    0           D   10.1.12.1       GigabitEthernet0/0/0</span><br><span class="line">      10.1.12.1/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/0</span><br><span class="line">    10.1.12.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/0</span><br><span class="line">      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">    192.168.1.0/24  Direct  0    0           D   192.168.1.254   GigabitEthernet0/0/1</span><br><span class="line">  192.168.1.254/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/1</span><br><span class="line">  192.168.1.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/1</span><br><span class="line">255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br></pre></td></tr></table></figure><blockquote><p>但一般来说，很少需要去管路由器自己产生的报文，需求都是针对其他网络设备的。</p><p>所以实际说起策略路由都是说的接口策略路由。</p></blockquote><p>另外，值得注意的是，本文是基于华为的设备命令与ensp模拟器编写的。</p><p>而在H3C中，并没有接口策略路由这个概念，直接使用policy-based-route就揽括了华为中本地策略路由与接口策略路由的工作。</p><p>事实上，华为中这套基于流策略的配置也实在繁琐，比如说需要起三次名字。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【科普/运维】网络故障排查手册</title>
      <link href="/2024/07/08/%E3%80%90%E7%A7%91%E6%99%AE-%E8%BF%90%E7%BB%B4%E3%80%91%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E6%89%8B%E5%86%8C/"/>
      <url>/2024/07/08/%E3%80%90%E7%A7%91%E6%99%AE-%E8%BF%90%E7%BB%B4%E3%80%91%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="施工中。。。"><a href="#施工中。。。" class="headerlink" title="施工中。。。"></a>施工中。。。</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文默认你已经看过之前的计算机网络科普，或者说你已经掌握这些知识点。</p><p>另外，之前还出了两篇介绍处理网络故障的工具，强烈建议去看一看。</p><p>本文将介绍一些常见的网络故障与排查思路，主要适用于家庭与公司内部网络；</p><p>运营商一侧的维护不介绍（只要会判断是不是它们的问题即可，是运营商问题，直接摇人便是。）</p><p>本文更多是让读者进行学习，内化为自己的知识，并不是一本可以在现场直接照着进行操作的攻略书。</p><p>同时网络故障千奇百怪，想写一本通用的排查手册几乎不可能。</p><p>我希望读者能在空闲时间读完全文，思考一下，进行内化。</p><p>稍微啰嗦一下：</p><p>一般来说，后期维护并不需要涉及太多网络配置相关的东西（指路由配置、策略配置、权限配置等），大部分的故障都是物理层链路层处的故障，小部分为人为因素故障。</p><p>因此，遇到网络故障了，第一时间是腿动起来，拿着工具去测。（当然我们还是得先进行故障现象验证、一些基础的检查与测试，这部分之后详细说）</p><p><strong>一定不要有在电脑上各种测试、调试就能判断故障问题甚至直接解决故障的定性思维。</strong></p><blockquote><p>举个实际我碰到过的例子，在某项目地，有一台设备不定时的丢包。</p><p>某公司的网络工程师在那用笔记本使用命令进行各种调试，甚至进到汇聚交换机后台去检查，折腾了很久都没解决（中途我跑去干饭了）。</p><p>后来收到该兄弟的微信，说他有事先去别的地方忙，告诉了我刚刚那台设备是连接在交换机上第几口（后台看arp表看的），让我去机房换个交换机接口试试。</p><p>我换完回去测试，依旧存在丢包的现象，于是我就去检查线路了，很快就在线槽下的延长转接处发现网线破皮了。</p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/de3144f803be6617597c7.png" style="zoom: 67%;" /><blockquote><p>为啥我不一开始就去干？</p><p>因为一开始人家（甲方&#x2F;业主）就不是叫我去处理这个事情，我没有理由去揽分给其他公司的活，给自己没事找事。</p><p>二是因为我个人不喜欢在别人埋头处理事情时去插手插嘴，一方面这会打断对方的思路，另一方面是很可能我需要花费不少时间去解释要做什么、为什么做，以及还要看对方听不听你的，愿不愿意让你现在操作。不如等他都处理完了，我再以我自己的思路去处理一遍，还不用动嘴解释。</p></blockquote></blockquote><p>以上啰嗦了，现在回到主题，我们先简要介绍一下本文的大纲。</p><p>第一部分会介绍更加底层的信息&#x2F;数据是怎么传输的，这有利于去解释一些“玄学”的故障问题。</p><p>第二部分会介绍常见的网络故障类型与大致现象</p><p>第三部分则介绍从接到报障电话开始，如何快速的缩小故障排查范围，尽可能快的判断处故障原理&#x2F;解决网络故障。</p><p> 碍于篇幅，本文默认你已经掌握了基础计算机网络知识与各类工具，如果你有不太清楚的，可以翻看上两篇文章。</p><h1 id="数据传输的本质"><a href="#数据传输的本质" class="headerlink" title="数据传输的本质"></a>数据传输的本质</h1><h2 id="码元、编码、解码与网线传输的原理"><a href="#码元、编码、解码与网线传输的原理" class="headerlink" title="码元、编码、解码与网线传输的原理"></a>码元、编码、解码与网线传输的原理</h2><p>计算机内部的信息都是0与1组成的。</p><p>进行信息传输，就需要想办法怎么表示0与1。</p><p>码元就是用来区分0与1的。</p><p>而编码，就是将数据转换为码元的过程，解码就是反过来的过程。</p><p>码元是基于高电平与低电平来表示的。</p><p>网线传输的本质是传播电信号——网线为铜线也就是导线，线芯之间的电平变化就是码元信息的表示。</p><blockquote><p>这也是干网络布线的被称为“弱电”的原因</p></blockquote><p>在大概了解这个原理后，我们来分析一下。</p><p>为什么网线要做成“双绞线”？</p><p>因为双绞线抗干扰，我想很多人都知道。那为啥抗干扰呢？又为啥有干扰呢？这可能有些人就答不出来了</p><ul><li>电能生磁、磁也能生电，如果网线处于一个有磁场变化的环境，导致线路内部的电平发生了变化，这就会导致这是传输的信息错误。</li><li>双绞线通过紧密贴合与双绞，让干扰发生后，虽然电平是变化了，但是两芯线保持同等变化，最终电平差值保持不变，不影响信息判断。</li><li>也是因此，我们才有了水晶头线序的规范。来，我们思考一下，最基础的通信是不是1236，12是不是同一对双绞线，36是不是同一对双绞线。</li></ul><h2 id="RS-232、RS-485通信"><a href="#RS-232、RS-485通信" class="headerlink" title="RS-232、RS-485通信"></a>RS-232、RS-485通信</h2><p>串口信号传输，本质也跟网线传输一样，就不赘述了。</p><p>这边推荐个视频看看了解一下，反过来，可以通过这个视频，去理解一下网线传输是怎么样的。</p><p><a href="https://www.bilibili.com/video/BV1PD4y147ts/?share_source=copy_web&vd_source=5ea4b537c83c10ddc4d51e37d940285c">5分钟看懂!串口RS232 RS485最本质的区别</a></p><h1 id="常见故障类型与现象"><a href="#常见故障类型与现象" class="headerlink" title="常见故障类型与现象"></a>常见故障类型与现象</h1><p>碍于篇幅，只简单提及，毕竟具体介绍，每一种都能单独写一篇文章出来。</p><h2 id="DHCP获取失败"><a href="#DHCP获取失败" class="headerlink" title="DHCP获取失败"></a>DHCP获取失败</h2><p>当设备网络设置为自动获取时，它会周期性的去寻找DHCP服务请求IP地址等信息。</p><p>如果持续一段时间找不到，该设备会使用169.254.0.0网段的IP地址作为临时IP地址（可与其他相同境遇的设备进行通信）</p><h2 id="IP冲突"><a href="#IP冲突" class="headerlink" title="IP冲突"></a>IP冲突</h2><p>当设备IP冲突时，如果设备自身未检测到冲突，它会保持使用该IP地址，那么就可能出现网络时断时续的情况。</p><p>这是因为交换机分不清回来的数据交给该设备还是与该设备IP相同的另一台设备。</p><p>如果设备自身检测到冲突，那么它不会使用该IP地址，为此，它也会像DHCP获取失败一样使用169.254.0.0网段的IP地址作为临时IP地址。</p><p>也许你体验过这种情景，给设备手动设置的静态ip，但是检查网络信息的时候，发现电脑死活就是首选使用一个169.254.0.0网段的IP地址。（而你又想着你明明没有使用自动获取，为此犯迷糊了）</p><h2 id="DNS故障"><a href="#DNS故障" class="headerlink" title="DNS故障"></a>DNS故障</h2><p>DNS故障表现为部分网站&#x2F;应用无法上网，因为DNS的作用是将域名翻译为ip地址，网络通信实际是以IP为标准的。</p><p>但DNS故障，无法将域名准确的“翻译”为IP地址，就会导致访问该域名失败。</p><h2 id="二层环路"><a href="#二层环路" class="headerlink" title="二层环路"></a>二层环路</h2><p>二层环路会导致网络中广播包大量存在，无法停止，最终占用大量网络资源（之前出过文章介绍，可以去看看）</p><p>在Windows里我们可以使用netstat -e命令，查看广播包的收发情况（也叫非单播包）</p><h2 id="三层环路"><a href="#三层环路" class="headerlink" title="三层环路"></a>三层环路</h2><p>三层的环路主要是单播包来回传，但由于三层包中有TTL限制，也就是数据包传播次数有上限，因此三层环路一般不会很快发展到引起网络故障，但三层环路依旧值得关注。</p><p>三层环路的成因是路由设置有误，一般搭建好、未在进行配置修改的网络中，这个故障可能性几乎为0。</p><h2 id="链路与硬件故障"><a href="#链路与硬件故障" class="headerlink" title="链路与硬件故障"></a>链路与硬件故障</h2><p>这个就很好理解了，设备或者设备接口、网线、光纤、模块、分光器、光纤收发器等坏了导致网络故障</p><h2 id="设备过热与过载"><a href="#设备过热与过载" class="headerlink" title="设备过热与过载"></a>设备过热与过载</h2><p>交换机与路由器，本质也是一台计算机，计算机会有的故障，它们也会有。</p><p>设备过热导致降频甚至死机，影响数据传输，就导致网络故障。</p><p>或者设备负荷过大，处理不过来，就导致网络卡顿甚至死机。</p><h2 id="网络代理"><a href="#网络代理" class="headerlink" title="网络代理"></a>网络代理</h2><p>代理，也就是网络中转站。</p><p>一般来说，有一些网络资源，我们设备本身无法访问到或者是访问速度慢，就开启代理，让代理服务器去处理。（加速器与科学上网的本质）</p><p>如果因为一些其他情况，代理服务器无法访问目标网络资源，而我们设备开着代理，就会导致网络故障。</p><h2 id="带宽被大量占用"><a href="#带宽被大量占用" class="headerlink" title="带宽被大量占用"></a>带宽被大量占用</h2><p>带宽被占满，会导致网络“延迟、卡顿、丢包”。常见的就是同局域网下，有人占满网速在下载东西，会导致其他人“卡了”。</p><h2 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h2><p>这边不做专门介绍了，网上有很多文章介绍网络攻击。</p><p>这边提出来只是让读者不要忽视了这个可能性，虽然平时很少遇到，但确实有这个可能性。</p><blockquote><p>如果是电脑中病毒，然后自主的对外传大量传数据这种情况其实是算上一个故障类型。</p></blockquote><h1 id="故障处理思路"><a href="#故障处理思路" class="headerlink" title="故障处理思路"></a>故障处理思路</h1><p>请不要跳过上文，直接观看本段！本段内容都是默认你已经看过上文了。</p><h2 id="发现故障阶段"><a href="#发现故障阶段" class="headerlink" title="发现故障阶段"></a>发现故障阶段</h2><h3 id="抵达现场"><a href="#抵达现场" class="headerlink" title="抵达现场"></a>抵达现场</h3><p>接到报障时，我们应该着重询问了解故障范围、故障现象与出现时间&#x2F;周期、尤其要询问前一天是否正常，或者说最近一次使用时间。</p><p><strong>到达现场之后，一起要记得自己去测试一次，切记不可听信用户自己的描述，必须自己操作一遍观察故障现象。</strong></p><p>在验证故障的过程中，嘴巴也别闲着，前面第一段那些问题没了解清楚的，在这时继续询问用户。</p><p>同时询问用户最近是否有什么变动，类似系统升级、安装了软件、周围或者办公室内有施工、设备是否更换等等。</p><p>验证完故障时，一定要问一句用户附近有交换机&#x2F;路由器吗。</p><h3 id="确定故障范围"><a href="#确定故障范围" class="headerlink" title="确定故障范围"></a>确定故障范围</h3><p>这是很重要的一步，故障范围可以快速的帮助确定故障点。</p><blockquote><p>但并不绝对，一定要记得，故障原因没有绝对，都是可能性，我们的工作是考虑可能性，再逐一排除可能性。</p><p>“从怀疑到验证”重复这个过程，并不是”怀疑&#x3D;确信“。</p></blockquote><ul><li>如果故障范围不小，比如一间办公室。那么显然，故障<strong>大概率</strong>不是出在终端设备这边（一般指电脑），排查重点在这些设备的上行链路（上层交换机&#x2F;路由器）</li><li>故障范围限定于一台终端设备，那么我们的排查重点就是在设备这边，以及设备到达机房的这段链路。</li><li>故障范围仅限于终端设备上的部分情景（譬如只有部分网站打不开等），那么我们可以暂时排除线路故障。排查重点在于DNS、防火墙<strong>等</strong>“上层应用”，以及对端设备（<strong>比如</strong>网站的服务器一侧，包括服务器本身与服务器到网关的链路）</li></ul><h2 id="排查阶段"><a href="#排查阶段" class="headerlink" title="排查阶段"></a>排查阶段</h2><h3 id="进行基础测试"><a href="#进行基础测试" class="headerlink" title="进行基础测试"></a>进行基础测试</h3><h4 id="检查终端的网络状态"><a href="#检查终端的网络状态" class="headerlink" title="检查终端的网络状态"></a>检查终端的网络状态</h4><p>以window11为例（我知道很多人都用不习惯，但是作为运维人员，你不能说不好用就拒绝学习，用户电脑系统就用win11，你现场摸瞎搞被人当成不专业吗）</p><p><strong>打开控制面板的更改网络设配器界面（三种方法任选一种）：</strong></p><blockquote><p>我知道ipconfig &#x2F;all 一样的效果，但是可视化程度，易读性上还是进设配器界面好，同时还方便后面可能进行的手动设置。</p></blockquote><ol><li><p>Windows11直接在系统搜索处输入”网络连接“，按回车进入传统的网络设配器界面。（搜索不需要鼠标去点，键盘按一下Windows键，在开始菜单界面输入文字就自动进入搜索状态）</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/94e57429e4357e63121d5.png"></p></li><li><p>win+R或者其他方式打开运行窗口，输入ncpa.cpl</p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/2efd3a7c6320cf23b22d3.png" style="zoom:67%;" /></li><li><p>打开控制面板，点击网络和共享中心，点击更改设配器设置。（如何打开控制面板不在此赘述）</p></li></ol><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/5ae0655c2d386aaea5bd5.png"></p><p>选中当前使用的设配器（网卡），双击或者右键点击状态，打开状态界面。</p><p>在状态界面点击详细信息，打开详细信息界面。</p><h4 id="解读一下网络信息"><a href="#解读一下网络信息" class="headerlink" title="解读一下网络信息"></a>解读一下网络信息</h4><p><strong>第一眼关注状态窗口下方的”活动“，观察已发送与已接收流量是否正常。</strong></p><ul><li>如果是字节数只有发送，而接收为0，初步可以怀疑IP冲突或者DHCP获取IP失败。（可以通过禁用再启用，刷新字节数）</li><li>如果接收的字节数量增加速度很快，并且确认当前设备未在下载东西，那么需要怀疑一下环路或网络攻击等会占用大量网络资源的故障因素。</li></ul><p><strong>第二眼关注详细信息里的ip、掩码、网关，记录下来。</strong></p><ul><li><p>假设ip地址为169.254.X.X；则说明该设备目前没有正常的ip地址可用。</p><p>或许你很好奇我的说法，不应该直接断定是DHCP获取地址失败吗？</p><p>其实不止，如果是使用静态ip地址，而ip冲突了，那么该设备就会处于没有ip可用的状态。</p><p>它会启用与DHCP获取ip失败时一样的补救措施，使用169.254.X.X。</p></li><li><p>假设是DHCP自动获取ip，那么我们会看到ip地址租期以及DHCP服务器的ip地址。记录服务器地址</p></li></ul><h4 id="查看网络信息要做的测试"><a href="#查看网络信息要做的测试" class="headerlink" title="查看网络信息要做的测试"></a>查看网络信息要做的测试</h4><p>第一步就是测试到网关的连通性。</p><p>请注意，不要只相信Ping的结果，很多时候会遇到禁Ping的设备，遇到拦截Ping包的防火墙。Ping的通的好说，Ping不通时，我们还要使用telnet、TCPing再测试一遍。</p><p>假设能通网关，说明从设备到机房设备这中间一段有没有故障。包括本地这边设备，设备到机房的链路，机房内的链路，机房网关设备。</p><blockquote><p>这种情况下就再测试到达DNS的连通性，同时测试一下到达其他DNS的连通性（比如114.114.114.114；如果是纯内网环境，就ping内网里的服务器或者其他网段的电脑，以ip地址的方式）。</p><ul><li>若能通DNS，那么大概率故障不在下三层，而在上层。例如防火墙&#x2F;策略&#x2F;代理&#x2F;对端服务未启用等等。</li><li>若不通DNS（不止一个），那么大概率是网关到DNS的这段有问题。</li></ul></blockquote><p>假设不能通网关，那么就要先排查设备到机房的这一段了，包括本地设备的设置、硬件、网线、交换机等等。</p><blockquote><p>可以进行的简单测试有拔插网线，检查水晶头，测线序，更换本地IP地址，更换本地mac地址（这两项更换测试完，记得改回去）</p></blockquote><h4 id="检查附近非故障机的网络信息"><a href="#检查附近非故障机的网络信息" class="headerlink" title="检查附近非故障机的网络信息"></a>检查附近非故障机的网络信息</h4><p>在非故障机上去验证能否联网，并查看以上的网络信息。</p><p>然后比对故障机与非故障机有什么配置区别，以排除ip&#x2F;子网&#x2F;网关配置错误的可能性。</p><p>如果是自动获取的，那么得看看网关是不是同一个设备，以排除是局域网内有私接的网关&#x2F;路由器。</p><p>可以<strong>使用ARP命令查看网关的mac地址</strong>，mac地址不止可以确定是不是同一台设备；</p><p><strong>mac地址的前6位代表网卡的生产厂商</strong>，我们可以借助厂商品牌大概推断会是什么设备。（比如是苹果的，可能是电脑；电信的，可能是路由器；TP-Link的，也可能是路由器）这也方便我们去找设备，重点找指定品牌的设备。</p><p>通过拔掉故障机的网线，在非故障机处ping&#x2F;tcping故障机的IP，以排除IP冲突的可能性（通就说明冲突了，可以在通过ARP命令检查MAC进一步确定）</p><h3 id="假设故障范围大"><a href="#假设故障范围大" class="headerlink" title="假设故障范围大"></a>假设故障范围大</h3><p>以网络完全不通为前提。</p><p>通过询问与寻线，找到故障机们最近的上一级交换机，将该设备重启，并检查主线水晶头与线序（最好是用寻线仪检测）</p><blockquote><p>假设线序不正确或者主线不亮，证明链路有故障。</p><p>重打链路两端的水晶头后再次检测。（对端就靠寻线过去）</p><p>寻不到线或者故障依旧则可以放弃该段链路了（后者如果是测线序有大于4芯亮的，那还可以抢救一下，打1236走百兆）</p></blockquote><p><strong>值得注意的是，找到设备的时候一定要摸一摸，并观察指示灯，以排除设备过热&#x2F;硬件故障等可能性。</strong></p><p>断开交换机上的主线，保持其他不变，检查故障机彼此是否互通。</p><blockquote><p>若互通，说明该交换本身以及到设备都是没问题的。</p><p>若不通</p><ul><li>检查水晶头，检查是否环路</li><li>更换交换机测试</li></ul></blockquote><p>有条件在这里测试主线直连故障机是否能正常访问网络。（推荐常备网络直通头，直接使用直通头连接主线与故障机的网线。）</p><p>没有条件的，用主线直连自己带的笔记本，测试能否通网关。</p><blockquote><p>如果直连网络可通，那么尝试更换该交换机上主线的接口。</p><ul><li>假设更换接口都不可使用，检查其余网线上的水晶头是否正常，线长有余裕的就直接重打水晶头</li><li>假设故障依旧就更换一台交换机</li></ul><p>如果直连网络都不通</p><ul><li>第一步还是检查水晶头，有条件重打主线的水晶头</li><li>水晶头无误，则再寻线去到更上一层交换机处进行以上检查</li></ul></blockquote><h3 id="假设故障范围小"><a href="#假设故障范围小" class="headerlink" title="假设故障范围小"></a>假设故障范围小</h3><p>也就是故障限定在一台设备，<strong>请先排除IP冲突</strong>，以下是排除IP冲突后的处理过程。</p><p>第一步依旧是检查到网关的连通性。</p><ul><li>若不通再检查到同网段其他电脑的连通性（比如隔壁电脑）<ul><li>若通其他电脑，说明可能是有策略或者防火墙将本地电脑拦截。</li><li>若依旧不通，ping 127.0.0.1测试是否设备网卡或协议存在故障。</li><li>若通本地127.0.0.1，则检查物理链路（水晶头、网线）</li><li>若不通127.0.0.1，则说明设备网卡有故障</li></ul></li><li>修改ip地址再进行一轮测试，以排除IP冲突或IP被禁用的可能性</li><li>修改MAC地址再进行一轮测试，以排除MAC被禁用的可能性</li><li>进入带网络功能的PE系统，以排除系统问题</li><li>将非故障机的网线接入故障机，以排除线路问题（包括交换机端口问题以及端口设置问题）</li><li>将非故障机的网线接入故障机，依旧不通网，就同时将故障机的IP与MAC都修改为该非故障机的，再测试<ul><li>若这时通了，说明是上层配置问题（策略&#x2F;防火墙等）</li><li>若不通，找个usb网卡再接网线测试</li></ul></li></ul><blockquote><p>有时，我们会接触到带认证客户端的设备，需要认证通过才能联网。</p><ul><li>这种就需要看情况处理，一般来说，先检查IP与MAC地址是否与其他设备冲突</li><li>接着排查账号问题（在故障机使用其他账号登录，以及在其他设备使用刚刚故障机上的账号）</li><li>若确定账号没问题，故障依旧存在则检查整体链路是否有问题。将非故障机的网线接入故障机，以排除线路问题（包括交换机端口问题以及端口设置问题）<ul><li>若此时通网了，说明是链路有问题（包括链路是否能通认证服务器）</li><li>若不通网，则说明链路无故障，故障出现在与设备相关的地方。</li><li>重装认证客户端测试</li><li>若还是不通网，则将IP地址与mac地址设置为非故障机的，再此测试以排除IP或MAC被拉黑的可能性。</li></ul></li><li>另外，也可以同时去认证服务器端，查看日志。</li></ul></blockquote><h3 id="假设故障为部分应用上不了网"><a href="#假设故障为部分应用上不了网" class="headerlink" title="假设故障为部分应用上不了网"></a>假设故障为部分应用上不了网</h3><p>一般这种情况就是链路并无故障，主要是上层故障导致的。</p><ul><li><p>我们可以先直接ping ip地址，再次确定是否下三层通的。</p></li><li><p>接着更换DNS以排除DNS解析有误导致的。</p></li><li><p>更换DNS后，可以手动清除DNS缓存，并使用nslookup命令检查DNS解析状况。（必要的话，检查本地hosts文件）</p></li><li><p>接着检查设备是否开启了代理。</p></li><li><p>关闭本地防火墙尝试一下。</p></li><li><p>若是浏览器打不开网站的这种情况，那么就在浏览器设置里清空缓存与cookie，重启浏览器。</p><ol><li>若依旧不行，再检查浏览器的权限设置，插件管理。</li><li>依旧不行的，更换浏览器再测试一遍。</li><li>同时可以去其他电脑访问该网站以排除对端服务器的故障&#x2F;网关策略问题。</li></ol></li></ul><h1 id="疑难杂症与”玄学“"><a href="#疑难杂症与”玄学“" class="headerlink" title="疑难杂症与”玄学“"></a>疑难杂症与”玄学“</h1><h2 id="通又不完全通（延迟、丢包）"><a href="#通又不完全通（延迟、丢包）" class="headerlink" title="通又不完全通（延迟、丢包）"></a>通又不完全通（延迟、丢包）</h2><p>这种情况，多半都是物理层面的故障导致的（设备故障、链路损伤、信号干扰等）。</p><ul><li>其中设备故障并不一定是设备坏了，也可能是过热、过载、甚至电压不稳定的原因。（不一定是交换机&#x2F;路由器，终端设备（电脑&#x2F;摄像头）也会如此）</li><li>链路损伤包含了线路破皮、潮湿、弯折角度过大（光纤更敏感）。</li><li>信号干扰一般来说就是电磁信号干扰，导致网线内部传输的电信号发生变化（磁生电）。</li></ul><p>由原理推故障都好说，但现实实操的时候，遇到故障很多时候都会犯迷糊。</p><p>因为现实生活中，变数很多，很多时候人为的因素会导致我们无法一时间发现问题所在。</p><p>举一种常见的情况——接到报障，赶到现场，故障却已消失。</p><p>也有的时候是故障只持续数秒，十数秒，根本来不及检查。</p><p>这种情况只能花时间慢慢去验证，包括观察周期、规律，摸清设备的网络走向（布线走向与交换机位置）</p><blockquote><p>我提几个存在过的实际案例（部分不是我个人经历）</p><p>因后期办公室增加了设备等原因，办公室内新增了交换机以满足使用需求，交换机也因此只能放在办公室桌子上或随意找地方放置，电源插头也接着办公室插排上。</p><ul><li>在此情景下，因为交换机被放在窗台边缘，当气温高且晴天时，太阳长时间直射交换机，导致设备过热。</li><li>在此情景下，因为交换机占用了插排的一个接口，如果有员工短时间需要接入其他电器，有可能会直接拔了交换机的电源。</li><li>在此情景下，因为交换机被放在热水壶等大功率电器附近，或者当电源接在同一插排上，当电器启动，短时的磁场变化或短时的电压变化冲击都可能导致网络波动。</li><li>在此情景下，因为交换机被放在热水壶边，烧水壶长期的热量导致设备过热。（尤其是有的员工习惯使用养生壶保持高温烧凉茶&#x2F;果茶）</li><li>在此情景下，交换机到新增设备的网线都是采用明线的方式布置，有的是在地毯下，有的是在地面线槽下，有的是穿过桌子。<ul><li>在这种情况下，可能因为线路长期踩踏&#x2F;桌子等重物压迫，线皮可能破损。破损后，如果在被踩踏&#x2F;牵扯，可能会导致破皮的两芯接触导致信号错乱。</li><li>在这种情况下，可能因为水晶头制作不良&#x2F;老化&#x2F;接口松，网线被牵扯导致接触不良，引起“网络波动”。</li></ul></li></ul></blockquote><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>其实吧，没必要分这么多情况。我个人认为，只要你了解了网络通信的原理，那么什么会导致网络通信失败都是可以推出来的。</p><p>比如说网络通信需要设备进行报文的处理，这设备的本质不就是个CPU嘛，那么反过来我问问你，什么情况会让你CPU运行状态不好？（供电&#x2F;降频——电压不足不稳、过热、过载）</p><p>再到计算机网络，MAC地址、IP地址、网段、DNS、DHCP、路由、防火墙等等他们的原理，他们的用途，都是可以推出故障点的。</p><p>回到本文，其实我对本文的结构并不满意，不够由浅入深，循序渐进；确实不好写，故障因素太多了，很难分类。</p><p>只能希望读者能全文仔细看完，进行学习内化，本文并不适合作为在现场翻看的指导书。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【动态路由2】IS-IS</title>
      <link href="/2024/07/01/%E3%80%90%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B12%E3%80%91IS-IS/"/>
      <url>/2024/07/01/%E3%80%90%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B12%E3%80%91IS-IS/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文将介绍另一项动态路由协议：IS-IS，全称intermediate system to intermediate system（中间系统到中间系统）。</p><p>它与OSPF一样，都属于链路状态协议，都是设备之间通过Hello报文发现彼此、建立邻居、交互链路状态信息、同步LSDB、最后通过SPF算法计算路由信息，并且对整个网络会进行区域划分以减少LSDB的规模，降低对网络资源与设备性能的影响。</p><p>拓展一下，我们都学习过OSI七层网络模型，但是目前我们使用的是TCP&#x2F;IP。这两种协议栈是不相同的，<strong>IS-IS原本是使用于OSI协议栈中，而我们要学习的是被引进到TCP&#x2F;IP中的IS-IS。</strong></p><p>而<strong>所谓的IS（intermediate system，中间系统）指的是OSI中的路由器</strong>，因此IS-IS的原意为实现IS之间动态路由信息交互。</p><p>在IS-IS中，交互的链路状态信息，被称为LSP（link-state packet），对于OSI模型来说，IS-IS所处层级的报文就叫做packet。</p><blockquote><p>目前IS-IS主要应用于运营商网络中，所以说实话，各位可能不太会接触到，一般的企业网还是以OSPF为主（甚至是RIP与静态）。因此本文不会介绍的太过细致，尤其是命令配置方面，真的有需要，还请以产品文档为准。</p></blockquote><p>因为IS-IS与OSPF有很多相似处，并且本文是在OSPF之后出的，所以我就默认各位都学习过OSPF了，将会与OSPF进行参照比较来介绍IS-IS。同时这也是一个复习巩固ospf知识点的机会。</p><h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>与OSPF的大致相同点，我们在前文简单描述过，对于链路状态信息以及LSDB是什么的内容则在介绍OSPF的文章中提到过了。</p><p>因此我们不再赘述身为链路状态协议是如何通过链路状态信息交互，最后得到路由的基础过程。</p><p>先着重介绍IS-IS与OSPF的不同之处，概念术语抛的差不多之后再介绍IS-IS的通信过程。</p><blockquote><p> 个别部分一样是先介绍简单概念，后面另起一小节详细介绍</p></blockquote><h2 id="路由器类型"><a href="#路由器类型" class="headerlink" title="路由器类型"></a>路由器类型</h2><p>在IS-IS中，对路由器进行了两种级别的划分，分别是level-1与level-2。值得注意的是路由器可以同时是level-1和level-2，对于这种路由器，我们称之为level-1-2路由器。</p><blockquote><p>我们可以理解为level-2为OSPF中的骨干路由器，level-1为OSPF中的非骨干区域路由器，而level-1-2则是ABR。</p></blockquote><h3 id="Level-1-路由器："><a href="#Level-1-路由器：" class="headerlink" title="Level-1 路由器："></a><strong>Level-1 路由器</strong>：</h3><ul><li>在 IS-IS 中，Level-1 路由器负责在同一个区域（Level-1 区域）内进行邻居关系建立与链路状态信息交互。</li><li>level-1路由器只能与level-1路由器建立邻居与链路状态信息交互。</li><li>类似地，在 OSPF 中，非骨干路由器负责在同一个区域内进行路由选择。</li></ul><h3 id="Level-2-路由器："><a href="#Level-2-路由器：" class="headerlink" title="Level-2 路由器："></a><strong>Level-2 路由器</strong>：</h3><ul><li>Level-2 路由器在 IS-IS 中负责在不同区域之间进行路由选择，处于连接不同 Level-1 区域的 Level-2 区域。</li><li>level-2路由器只能与level-2路由器建立邻居与链路状态信息交互。</li><li>在 OSPF 中，骨干路由器（Backbone Router）扮演类似的角色，位于连接不同区域（OSPF 区域）的骨干区域。</li></ul><h3 id="Level-1-2-路由器："><a href="#Level-1-2-路由器：" class="headerlink" title="Level-1-2 路由器："></a><strong>Level-1-2 路由器</strong>：</h3><ul><li>Level-1-2 路由器是同时具有 Level-1 和 Level-2 路由器功能的路由器</li><li>既可以在 Level-1 区域内进行邻居建立，也可以在 Level-2 区域之间进行邻居建立。</li><li>在 OSPF 中，ABR（Area Border Router）也具有类似的功能，连接不同 OSPF 区域并负责在它们之间传递链路状态信息。</li></ul><h3 id="类型总结"><a href="#类型总结" class="headerlink" title="类型总结"></a>类型总结</h3><p>可以说，IS-IS 中的 level-1、level-2 和 level-1-2 路由器与 OSPF 中的非骨干路由器、骨干路由器和 ABR 在功能上有一定的相似性，都是为了实现在不同区域之间的路由选择和信息传递。</p><h2 id="系统ID"><a href="#系统ID" class="headerlink" title="系统ID"></a>系统ID</h2><blockquote><p>再次提醒，IS-IS协议诞生于OSI协议栈中，“中间系统”这个叫法就是TCP&#x2F;IP中的“路由器”。</p></blockquote><p>系统ID（system ID）相当于OSPF中的router-id，都是表示区域内的某台路由器。</p><p>与router-id一样，IS-IS的系统ID也要求保证在区域内的唯一性。</p><p>巧的是，IS-IS是工作于二层，二层的MAC地址本质也是具备全局唯一性，因此，系统ID在不手动配置时，会<strong>默认使用MAC地址</strong>。</p><p>也因此，<strong>系统ID为48位二进制，与MAC地址长度一致；也与MAC地址一样默认使用十六进制表示。</strong></p><h2 id="区域"><a href="#区域" class="headerlink" title="区域"></a>区域</h2><h3 id="区域-id"><a href="#区域-id" class="headerlink" title="区域 id"></a>区域 id</h3><p>IS-IS使用OSPF中类似area的概念，但不同的时，IS-IS的area长度是可变的，同时，还是使用十六进制的方式书写。</p><blockquote><p>一般我们描述的区域id都是带有“49.”的前缀，实际上这个49并不属于区域id，49在OSI协议栈中用于表示私有地址。</p></blockquote><p>值得注意的是，IS-IS中，区域的边界并不是设备。</p><p>在OSPF里，假设R2的两端：R1属于area0，R3属于area1。</p><ul><li>那么我们会配置R2的一个接口属于area0，与R1相连；</li><li>R2的另一个接口属于area1，与R3相连。</li><li>最终结果就是R2处于area0与area1的边界。</li></ul><p>而<strong>在IS-IS中，我们仅能配置设备属于单个区域</strong>，对于level-2路由器之间来说：</p><ul><li>首先考虑R2究竟是要配置为R1所处的区域还是R3所处的区域。</li><li>假设R2与R1配置为同一区域，那么R2与R3会进行跨区域邻居建立。</li><li>最终结果就是区域的边界是处于R2与R3之间的链路上。</li></ul><h3 id="区域划分"><a href="#区域划分" class="headerlink" title="区域划分"></a>区域划分</h3><p>刚刚提到的情景说明，强调了“<em>对于level-2路由器之间来说</em> ”，这是因为在IS-IS中，有严格的层次划分。</p><p>IS-IS使用两级区域层次结构：Level 1和Level 2。</p><p>level-1层次类似于OSPF的常规区域，而且近似于totally NSSA区域；</p><p>level-2层次类似于OSPF的骨干区域，值得注意的是L2层次支持跨区域邻居建立。</p><blockquote><p>老实说，我认为叫成level-1区域和level-2区域对于初学者来说很容易混淆概念。个人认为，应该叫level-1层次、level-2层次，所以本文会采用这个叫法。</p></blockquote><p>level-1路由器负责区域内路由，<strong>level-1路由器只能与同区域的level-1路由器建立邻居关系。</strong></p><p>level-2路由器负责区域间路由，<strong>level-2可以跨区域，或者说无视区域id，与其他level-2路由器建立邻居关系。</strong></p><p>也因此，才会存在level-1-2路由器，它即属于level-1路由器，又属于level-2路由器。可以使用它来连接level-1层次与level-2层次，这相当于OSPF中的ABR角色。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>对于IS-IS来说，区域仅仅只是标识，而真正划分骨干区域与常规区域的是level层次。</strong></p><p>作为骨干的level-2层次可以包含多个区域。</p><p>作为常规的level-1层次需要经过level-1-2路由器与作为骨干的level-2层次相连，最后做到跨区域路由。</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/d01bdec3b64367f9277ed.png" style="zoom: 80%;" /><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/6a1bc106b1b026d840cdb.png" style="zoom:67%;" /></p><h2 id="NET地址"><a href="#NET地址" class="headerlink" title="NET地址"></a>NET地址</h2><p>系统ID只要求区域内唯一，也就是不同区域内的两台路由器实际可以用同一个系统ID（这在OSPF中也是如此）。</p><p>而<strong>NET地址则是全IS-IS网络中对路由器的唯一标识符，它由区域ID+系统ID</strong>+NSAP选择器（默认为00）组成。</p><blockquote><p>NET&#x3D;network entity title，网络实体名称</p></blockquote><p>这个概念在OSPF中是不存在的。</p><p>事实上，NET地址起源于OSI协议栈中NSAP地址的概念（相当于TCP中的套接字——ip地址+端口号）</p><p>NET的示例: 49.0001.1921.6800.1001.00</p><blockquote><p>请注意，这是一个十六进制的数。</p></blockquote><ul><li>49: AFI (Authority and Format Identifier)，表示这是一个私有地址。（起源于OSI协议栈）</li><li>0001: 区域ID</li><li>1921.6800.1001: 系统ID</li><li>00: NSAP地址中表示上层协议类型的字段，IS-IS不需要，故默认为00。</li></ul><p>总的来说，我们只关注中间的区域ID与系统ID即可。</p><p>只不过在DIS生成的伪节点上，会修改NSAP选择器字段为“01”，有关DIS与伪节点的概念稍后就介绍。</p><blockquote><p>另外，值得注意的是，区域ID是可变长的，所以推算区域ID是从右往左推——去掉2位的NSAP选择器，再去掉12位系统ID（以16进制算），得到的就是区域ID。</p><p>比如49.0000.0000.00001.00的区域ID为49</p><p>49.0000.0000.0000.00001.00的区域ID为49.0000</p><p>当然，在以太网中，实际开头不需要为49。10.0000.0000.0001.00也是没错的。</p></blockquote><h2 id="度量值"><a href="#度量值" class="headerlink" title="度量值"></a>度量值</h2><p>IS-IS与OSPF一样都是使用cost值作为度量值，不同的是IS-IS是一个完全独立的数值，默认为10。</p><blockquote><p>在OSPF中，cost值是链路带宽的值计算过来的。</p></blockquote><p>所以在不手动修改cost值的情况下，IS-IS的度量值反而更类似于RIP的度量值（跳数）。</p><p>不过实际使用中，个别厂商会在自家设备上对IS-IS协议进行魔改，提供自动计算cost的功能。（这个本文不做讨论，可以查看相应的产品文档）。</p><h2 id="协议报文"><a href="#协议报文" class="headerlink" title="协议报文"></a>协议报文</h2><p>与OSPF报文采用网络层的IP封装不同，IS-IS的报文采用数据链路层封装，在以太网中，我们称数据链路层的报文为协议数据单元PDU。</p><blockquote><p>IS-IS工作于二层的好处就是封装解封装效率高。</p></blockquote><p>IS-IS使用了以下几种PDU进行协议通信。</p><h3 id="IIH（IS-IS-Hello）"><a href="#IIH（IS-IS-Hello）" class="headerlink" title="IIH（IS-IS Hello）"></a>IIH（IS-IS Hello）</h3><p>相当于OSPF中的hello报文，一样是用于建立与维护邻居关系。</p><p><strong>在IS-IS中存在三种IIH PDU：level-1 LAN IIH、level-2 LAN IIH以及P2P IIH。</strong></p><p>前两者用于广播型网络（如以太网）：如果设备为level-1，则它仅收发level-1 IIH；如果设备为level-2，则它仅收发level-2 IIH；level-1-2设备则两者都收发。</p><p>而P2P IIH则用于P2P类型的网络中。</p><h3 id="LSP（Link-State-Packet）"><a href="#LSP（Link-State-Packet）" class="headerlink" title="LSP（Link-State Packet）"></a>LSP（Link-State Packet）</h3><p>IS-IS使用LSP承载链路状态信息，LSP是一个完整的在链路上传播的报文，因此它类似于OSPF中的LSU(包含其中的多种LSA)。</p><p>LSP仅存在level-1 LSP与level-2 LSP两种，并不像OSPF中分了多种LSA。</p><h3 id="CSNP（Complete-Sequence-Number-PDU）"><a href="#CSNP（Complete-Sequence-Number-PDU）" class="headerlink" title="CSNP（Complete Sequence Number PDU）"></a>CSNP（Complete Sequence Number PDU）</h3><p>CSNP意为完全序列号报文，也是分level-1与level-2两种，用于在不同的IS-IS邻居关系中。</p><p>CSNP类似于OSPF中的DD报文，用途为描述设备中所有的LSP摘要，确保设备之间LSDB的同步。</p><h3 id="PSNP（Partial-Sequence-Number-PDU）"><a href="#PSNP（Partial-Sequence-Number-PDU）" class="headerlink" title="PSNP（Partial Sequence Number PDU）"></a>PSNP（Partial Sequence Number PDU）</h3><p>PSNP意为部分序列报文，也是分level-1与level-2两种，PSNP与CSNP的不同之处在于PSNP只包含部分LSP摘要信息，PSNP主要用于请求LSP更新。这相当于OSPF中的LSR报文。</p><blockquote><p>个别情况下，还会作为确认收到更新LSP报文的回应报文，即OSPF中的LSAck。具体内容后续介绍。</p></blockquote><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>LSP并不只在收到PSNP报文请求后才会发布。LSP会周期性的发布，即使没有明显的网络变化。</p><p>这个周期通常被称为 “LSP 刷新间隔”，默认值通常为 900 秒（最大生存时间的60%）。</p><p>LSP 刷新的目的：</p><ul><li>确保 LSP 信息的新鲜度。</li><li>防止 LSP 因超时而被删除。</li><li>允许新加入的路由器获取完整的拓扑信息。</li></ul><p>当然，除了周期性刷新，拓扑变化也会立即触发 LSP 更新。</p><h2 id="DIS与伪节点"><a href="#DIS与伪节点" class="headerlink" title="DIS与伪节点"></a>DIS与伪节点</h2><h3 id="DIS"><a href="#DIS" class="headerlink" title="DIS"></a>DIS</h3><p>在IS-IS中，每个网段会选举一台设备作为DIS（指定中间系统），与OSPF的DR很相似，但有一些重要区别。</p><p><strong>选举:</strong></p><ul><li>基于接口优先级和**系统ID(通常是路由器的MAC地址)**。</li><li><strong>优先级最高的路由器成为DIS</strong>。如果优先级相同,则系统ID最高的成为DIS。</li><li><strong>没有备份DIS</strong>的概念(与OSPF不同)。当DIS发送故障，立即开始选举新的DIS。</li><li><strong>DIS具有抢占性</strong>，即网络中接入优先级更高的设备时，该设备会夺取DIS的名头，成为新的DIS。</li></ul><p><strong>职责：</strong></p><ul><li>定期发送CSNP(完整序列号PDU)。</li><li>为广播网络创建和维护伪节点LSP。</li><li>在网络中泛洪LSP。</li></ul><p><strong>其他路由器与DIS的关系：</strong></p><ul><li>所有路由器都与DIS建立邻接关系。</li><li>其他路由器通过DIS同步LSDB。</li></ul><p><strong>报文交换：</strong></p><ul><li>DIS定期(默认每10秒)在广播网络上发送CSNP。</li><li>其他路由器如果发现CSNP中列出的LSP是自己没有的，会发送PSNP请求这些LSP。</li><li>DIS负责响应PSNP请求，发送相应的LSP。</li></ul><h3 id="伪节点"><a href="#伪节点" class="headerlink" title="伪节点"></a>伪节点</h3><p>还有一个很特别的点在于，IS-IS中的DIS虚拟出的伪节点（Pseudonodes）：</p><blockquote><p>伪节点的NET地址是在DIS的NET地址最后位从00改为01。具体我们之后以拓扑进行详细介绍时看一下LSDB表内信息。</p></blockquote><p><strong>目的：</strong></p><ul><li>简化拓扑，减少网络中LSP的数量，每个路由器只需要发布描述它邻居为伪节点的LSP，而不需要发布他与所有其他邻居路由器的关系。</li></ul><p><strong>其他路由器与伪节点的关系：</strong></p><ul><li>伪节点代表整个广播网段。</li><li><strong>每个路由器(包括DIS)都在其LSP中声明与伪节点的连接。</strong></li><li>伪节点LSP由DIS生成和维护，包含了所有连接到该网段的路由器信息。</li></ul><p><strong>报文交换：</strong></p><ul><li><strong>路由器不直接与伪节点交换报文。</strong></li><li>路由器通过DIS了解伪节点的信息。</li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>DIS负责管理网段，而伪节点简化了网络拓扑的表示。</p><p>这种设计大大减少了需要在网络中传播的LSP数量，提高了协议的整体效率。</p><p><strong>可以说伪节点与OSPF的type-2 LSA很相似：</strong></p><ul><li>普通路由器在OSPF中是与DR建立邻接关系，最后由DR发布type-2 LSA描述DR所处网段一共有多少路由器（与我相连，邻居是我）。</li><li>普通路由器在IS-IS中则是背地里与所有路由器都建立邻接关系（包括伪节点），但是表面表示为只与伪节点建立邻接关系，最后由DIS发布的伪节点LSP中描述了DIS所处网段一共有多少路由器（与伪节点、也就是我相连，邻居是我）。</li></ul><h2 id="邻居建立过程"><a href="#邻居建立过程" class="headerlink" title="邻居建立过程"></a>邻居建立过程</h2><h3 id="广播网络"><a href="#广播网络" class="headerlink" title="广播网络"></a>广播网络</h3><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/edc7a54d6949a8277dea7.png"></p><p>如图，假设两台level-1在使用千兆以太网连接在一起，都在GE0&#x2F;0&#x2F;0口激活IS-IS。</p><ol><li><p>由于R1是level-1路由器，因此其发送的hello报文为level-1 IIH。该报文中记录了R1的系统ID以及多个TLV，其中一个TLV记录了R1的区域ID。</p><blockquote><p>有关TLV是啥，我们稍后介绍。</p></blockquote></li><li><p>R2在其GE0&#x2F;0&#x2F;0口接收到R1的level-1 IIH报文，进行相应的检查（区域是否一致等），检查通过后，R2在其邻居表中记录下R1，并将状态标记为initial（初始化）。</p><p>R2发布一个level-1 IIH报文，报文内包含了系统ID、区域TLV，以及自己已记录邻居设备信息（R1的TLV与MAC地址）。</p></li><li><p>R1收到R2的报文，了解R2已经发现了自己，则将R2记录在邻居表中，并把状态设置为up。</p><p>R1也发布一个level-1 IIH报文，报文内包含了系统ID、区域TLV，以及自己已记录邻居设备信息（R2的TLV与MAC地址）。</p><p>待R2收到R1的报文，了解R1也发现了自己，则将邻居表中R1的状态也记录为up。</p></li><li><p>R1与R2彼此状态都为up，我们就认为邻居关系建立起来了。</p></li><li><p>因为是广播网络，需要选举DIS，所以在邻居关系建立后，路由器会等待两个Hello报文间隔，再进行DIS的选举。</p><p>Hello报文中包含Priority字段(优先级)，优先级值最大的将被选举为该广播网的DIS。若优先级相同，接口MAC地址较大的被选举为DIS。（与STP的选举优先级很类似）</p></li></ol><p>以上例子是level-1路由器之间的邻居建立关系；至于level-2路由器，形式也是一样的，只不过level-2路由器是通过另一个组播地址，通过level-2 IIH报文进行关系建立。</p><p>可以说，这与OSPF的int状态、2-way状态是一样的。</p><p>但请注意，<strong>IS-IS并没有像OSPF那样分邻居与邻接两种关系，对IS-IS来说只有邻居这一种关系。</strong></p><h3 id="P2P网络"><a href="#P2P网络" class="headerlink" title="P2P网络"></a>P2P网络</h3><p>在P2P网络中，IS-IS的邻居建立过程存在两种方式：两次握手及三次握手。</p><p>两次握手方式不存在确认机制，只要设备在接口收到P2P IIH，并且检查通过后，就直接当作该邻居存在，状态设置为up。（因为是P2P网络，对端只可能存在一台设备）</p><p>三次握手方式则需要经过一轮确认（类似广播网络中需要在报文中发现自己的系统ID才确定状态可以设置为up）。</p><h4 id="两次握手"><a href="#两次握手" class="headerlink" title="两次握手"></a>两次握手</h4><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/4b0a27dcf365d20e4e67c.png"></p><ol><li>R3在S1&#x2F;0&#x2F;0口激活了IS-IS，检查到为P2P网络，于是在该接口上发送P2P IIH报文。该hello报文中包含了R3的系统ID、区域TLV。</li><li>R4也激活了IS-IS，并收到了R3的P2P IIH，则认为该点对点网络对面的设备为R3，并且链路通的（毕竟收到了该报文），于是邻居表中填写上R3的信息，并标记为up。</li><li>反过来，对R3来说也是如此，收到R4的P2P IIH报文后，也标记为up。</li></ol><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/4612579ae970195f81be9.png"></p><p>三次握手机制中，新增了一个特殊的TLV：P2P三向邻接TLV。</p><ol><li><p>R3在S1&#x2F;0&#x2F;0口激活了IS-IS，检查到为P2P网络，于是在该接口上发送P2P IIH报文。该hello报文中包含了R3的系统ID、区域TLV以及一个三向邻接TLV。由于当前R3设备并没有在该P2P网络中发现其他设备，则该邻接TLV内的邻接状态设置为Dowm</p></li><li><p>R4收到R3的P2P IIH报文，检查通过后，在其邻居表中添加R3的信息，并将状态设置为Initial。</p><p>R4发送一个P2P IIH报文，包含R4的系统ID、区域ID以及记录了邻居系统ID与状态为initial的邻接TLV。</p></li><li><p>R3收到R4的报文，检查后还发现对方发来的报文包含了自己的信息，不过由于报文内的邻接状态为initial，R3暂时不认为邻接关系建立完毕。</p><p>邻接状态为initial意味着R4并没有收到R3的进一步确认信息；对于R3来说便是没有确认到“ <em>R4 是否已经收到并处理了 R3 的信息</em>”。</p><p>R3在邻居表内只会将R3的邻居状态设置为initial。</p><p>但当R3 发送下一个 P2P IIH 报文时，在这个新的 IIH 报文中，R3 会在三向邻接 TLV 中将 R4 的状态标记为 Up。</p><p>这表示 R3 已经收到并确认了 R4 的存在，并准备建立完整的邻接关系。</p></li><li><p>R4收到信息后，发现了自己的信息，且邻接状态为up，因此邻居表中对R3的状态修改为up，同时发送一个标记R3邻接状态为up的P2P IIH报文。</p></li><li><p>R3收到邻接状态为up的报文，这时才将邻居R4的状态设置为up。</p><p>自此，双方才认为邻接关系建立完毕。</p></li></ol><p>从严格的报文交换角度来看，这个过程涉及四次报文交换。然而，它被称为”三次握手”的原因如下：</p><blockquote><ol><li><p>状态变化的关键点：</p><ul><li>第一次：初始 Down 状态</li><li>第二次：转为 Initial 状态</li><li>第三次：最终确认为 Up 状态 这三个关键的状态变化点构成了”三次握手”的核心。</li></ul></li><li><p>功能视角：</p><ul><li>第一次：通告自己</li><li>第二次：确认看到对方并通告自己</li><li>第三次：确认双方都已互相看到 从功能上看，这三步完成了必要的信息交换。</li></ul></li><li><p>最后一次交换的作用：</p><ul><li><p>第四次报文交换主要是为了同步最终状态，可以看作是对第三次握手的确认。</p><p>在上述例子的第二次交换时——R3收到R4的报文后，本可以设置为up；再加上第三次交换——R4收到R3的报文，状态更新为up。算起来正好是三次握手即可互相标记为up。</p></li><li><p>在某些描述中，这可能被视为握手过程完成后的一个额外步骤。</p></li></ul></li><li><p>简化的概念模型：</p><ul><li>称为”三次握手”可能是为了简化理解和描述，突出过程中的关键步骤。</li></ul></li></ol></blockquote><h2 id="邻居建立后"><a href="#邻居建立后" class="headerlink" title="邻居建立后"></a>邻居建立后</h2><h3 id="广播网络-1"><a href="#广播网络-1" class="headerlink" title="广播网络"></a>广播网络</h3><p>DIS会周期性地泛洪CSNP（默认10秒一次），以确保该网络中地IS-IS设备拥有一致地LSDB。</p><p>其他设备收到该CSNP后会将其包含地LSP摘要与自己地LSDB进行对比，如果一致，则忽略该CSNP。</p><p>而如果本地LSDB缺少了部分LSP，则向DIS发送PSNP请求这些LSP地详细信息；</p><p>DIS收到该PSNP后，将相应地LSP发送给对方。</p><p>设备收到DIS发来地LSP后，无需向DIS回复确认收到信息。（毕竟之后还会收到DIS地周期CSNP，如果没收到&#x2F;还是缺，再次申请即可）</p><h3 id="P2P网络-1"><a href="#P2P网络-1" class="headerlink" title="P2P网络"></a>P2P网络</h3><p> P2P 网络中不需要DIS，CSNP也仅在邻居关系建立完成时发送一次用于确定要申请更新的LSP，后续不会周期性发布。</p><p>对于设备来说，在收到 LSP 后需要发送 PSNP 来确认收到的 LSP，以确保信息的完整性。</p><p>如果发送者一直没等到对方用于确认的PSNP，则会重传刚刚的LSP。</p><h1 id="报文与LSDB详解"><a href="#报文与LSDB详解" class="headerlink" title="报文与LSDB详解"></a>报文与LSDB详解</h1><p>以下的介绍会在一个简单的拓扑上进行：R1与R2相连，网段为192.168.12.0&#x2F;24，区域ID为10，都是level-1-2路由器，具体的IP地址主机位与系统ID就是R1为1、R2为2。</p><h2 id="TLV介绍"><a href="#TLV介绍" class="headerlink" title="TLV介绍"></a>TLV介绍</h2><p>TLV是对IS-IS报文中Type、Length、Value这三个字段的合称。</p><p>type表示该TLV的类型、length表示该TLV的整体长度、value存储传递的信息。</p><p>在IS-IS报文中，会存在多个TLV，数量不做限制。可以理解为是将ospf中多种LSA类型的机制理念进一步扩大利用。</p><p>一些常见的TLV如下：</p><table><thead><tr><th>TLV Type</th><th>名称</th><th>被应用于以下PDU类型中</th></tr></thead><tbody><tr><td>1</td><td>Area Addresses，区域地址</td><td>IIH、LSP</td></tr><tr><td>2</td><td>IS Neighbors（LSP），IS邻居（LSP）</td><td>LSP</td></tr><tr><td>6</td><td>IS Neighbors（MAC Address），IS邻居（MAC 地址）</td><td>LAN IIH</td></tr><tr><td>8</td><td>Padding，填充（补足报文整体长度，内容为空白）</td><td>IIH</td></tr><tr><td>9</td><td>LSP Entries，LSP条目（摘要信息）</td><td>SNP</td></tr><tr><td>10</td><td>Authentication Information，认证信息</td><td>IIH、LSP、SNP</td></tr><tr><td>128</td><td>IP Internal Reachability Information，IP内部可达性信息（包含网段与到达该网段的cost值）</td><td>LSP</td></tr><tr><td>129</td><td>Protocols Supported，支持的协议</td><td>IIH、LSP</td></tr><tr><td>130</td><td>IP External Reachability Information，IP外部可达性信息（包含网段与到达该网段的cost值）</td><td>L2 LSP</td></tr><tr><td>131</td><td>Inter-Domain Routing Protocol Information，跨域路由协议信息</td><td>L2 LSP</td></tr><tr><td>132</td><td>IP Interface Address，设备接口的IP地址</td><td>IIH、LSP</td></tr></tbody></table><blockquote><p>SNP代指CSNP与PSNP。</p></blockquote><p>请记住，字段名称是我们人为理解的，对计算机来说，它们传递的是直接的数据信息，不包含字段名称的。</p><p>比如说，在抓包软件中，value这个字段的名称在不同的报文中会被称为不同的字段名称。以下是一个hello中的抓包信息：</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/4473f8e094d1cf90b0195.png"></p><p>通过这个抓包我们也能理解报文中TLV的结构。</p><blockquote><p>报文特有头部省略了。</p></blockquote><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/9f7f09efeb6aa1b0b3fb5.png" style="zoom: 80%;" /><h2 id="IIH-（hello报文）"><a href="#IIH-（hello报文）" class="headerlink" title="IIH （hello报文）"></a>IIH （hello报文）</h2><p>我们直接以上面的抓包的 IS-IS Hello 报文信息，进行介绍：</p><blockquote><p>也就是上图的白色背景的内容，灰色背景的内容这里不介绍。</p></blockquote><ul><li>hello报文头部信息：<ul><li><strong>Circuit type</strong>: 表示电路类型，这里是 Level 1 和 Level 2。</li><li><strong>SystemID {Sender of PDU}</strong>: 发送此 PDU 的系统 ID，为 0000.0000.0001。</li><li><strong>Holding timer</strong>: 保持计时器，设置为 30。</li><li><strong>PDU length</strong>: 该PDU 长度为 1497 字节。</li><li><strong>Priority</strong>: 路由器优先级，优先级为 64。（用于选举DIS）</li><li><strong>SystemID {Designated IS}</strong>: DIS的 系统ID 为 0000.0000.0001.01。</li></ul></li><li>以下为各TLV<ul><li><strong>Area address(es)</strong>: 区域地址，类型为 1，长度为 2。</li><li><strong>IP Interface address(es)</strong>: IP 接口地址，类型为 132，长度为 4。</li><li><strong>Protocols Supported</strong>: 支持的协议，类型为 129，长度为 1。</li><li><strong>Restart Signaling</strong>: 重启信令，类型为 211，长度为 3。</li><li><strong>Multi Topology</strong>: 多拓扑，类型为 229，长度为 2。</li><li><strong>Padding</strong>: 填充字段，用于填充报文，类型为 8，长度为 255 和 161。目的是将hello报文的长度补充到1497字节。</li></ul></li></ul><h2 id="LSP报文"><a href="#LSP报文" class="headerlink" title="LSP报文"></a>LSP报文</h2><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/c2099acb56f0070600874.png"></p><p>该图为LSP报文的抓包信息。其详细内容如下:</p><p>根据提供的抓包信息，以下是对其中一些字段的解读：</p><ul><li>LSP头部信息：<ul><li><strong>PDU length</strong>: PDU 的长度为 54 字节。</li><li><strong>Remaining lifetime</strong>: 剩余生存时间为 1198。</li><li><strong>LSP-ID</strong>: LSP 的 ID 为 0000.0000.0002.00-00。</li><li><strong>Sequence number</strong>: 序列号为 0x00000002。</li><li><strong>Checksum</strong>: 校验和为 0x6d9a，校验正确。</li><li><strong>Type block</strong>: 类型块，该报文表示的 IS 类型为 Level 2。</li></ul></li><li>TLV信息：<ul><li><strong>Protocols supported</strong>: 支持的协议，类型为 129，长度为 1。</li><li><strong>Area address(es)</strong>: 区域地址，类型为 1，长度为 2，区域地址为 10。</li><li><strong>IP Interface address(es)</strong>: IP 接口地址，类型为 132，长度为 4，IPv4 接口地址为 192.168.12.2。</li><li><strong>IP Internal reachability</strong>: IP 内部可达性信息，类型为 128，长度为 12，IPv4 前缀（网段）为 192.168.12.0&#x2F;24，cost值为10。（图中未展开，展开后有详细的cost值）</li></ul></li></ul><h2 id="LSDB"><a href="#LSDB" class="headerlink" title="LSDB"></a>LSDB</h2><p>在R1上使用<strong>display isis lsdb</strong>命令检查LSDB摘要表。由于是level-1-2路由器，因此R1与R2不仅建立了level-1关系，也建立了level-2关系。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[R1]display isis lsdb</span><br><span class="line"></span><br><span class="line">                        Database information for ISIS(1)</span><br><span class="line">                        --------------------------------</span><br><span class="line"></span><br><span class="line">                          Level-1 Link State Database</span><br><span class="line"></span><br><span class="line">LSPID                 Seq Num      Checksum      Holdtime      Length  ATT/P/OL</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">0000.0000.0001.00-00* 0x00000009   0x6105        1121          68      0/0/0   </span><br><span class="line">0000.0000.0002.00-00  0x00000005   0x7dea        1067          68      0/0/0   </span><br><span class="line">0000.0000.0002.01-00  0x00000003   0xa0e7        1067          55      0/0/0   </span><br><span class="line"></span><br><span class="line">Total LSP(s): 3</span><br><span class="line">    *(In TLV)-Leaking Route, *(By LSPID)-Self LSP, +-Self LSP(Extended), </span><br><span class="line">           ATT-Attached, P-Partition, OL-Overload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                          Level-2 Link State Database</span><br><span class="line"></span><br><span class="line">LSPID                 Seq Num      Checksum      Holdtime      Length  ATT/P/OL</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">0000.0000.0001.00-00* 0x0000000a   0x5f06        1121          68      0/0/0   </span><br><span class="line">0000.0000.0002.00-00  0x00000006   0x7beb        1067          68      0/0/0   </span><br><span class="line">0000.0000.0002.01-00  0x00000003   0xa0e7        1067          55      0/0/0   </span><br><span class="line"></span><br><span class="line">Total LSP(s): 3</span><br><span class="line">    *(In TLV)-Leaking Route, *(By LSPID)-Self LSP, +-Self LSP(Extended), </span><br><span class="line">           ATT-Attached, P-Partition, OL-Overload</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到有三条LSP，其中第一条为自己，第二条为邻居，第三条为DIS（伪节点）。</p><p>我们可以进一步使用<strong>display isis lsdb <em>LSP-ID</em> verbose</strong>命令查看指定LSP的详细信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[R1]display isis lsdb 0000.0000.0002.00-00 verbose</span><br><span class="line"></span><br><span class="line">                        Database information for ISIS(1)</span><br><span class="line">                        --------------------------------</span><br><span class="line"></span><br><span class="line">                          Level-1 Link State Database</span><br><span class="line"></span><br><span class="line">LSPID                 Seq Num      Checksum      Holdtime      Length  ATT/P/OL</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">0000.0000.0002.00-00  0x00000006   0x7beb        1184          68      0/0/0   </span><br><span class="line"> SOURCE       0000.0000.0002.00</span><br><span class="line"> NLPID        IPV4</span><br><span class="line"> AREA ADDR    10 </span><br><span class="line"> INTF ADDR    192.168.12.2</span><br><span class="line"> NBR  ID      0000.0000.0002.01  COST: 10        </span><br><span class="line"> IP-Internal  192.168.12.0    255.255.255.0    COST: 10        </span><br><span class="line"></span><br><span class="line">Total LSP(s): 1</span><br><span class="line">    *(In TLV)-Leaking Route, *(By LSPID)-Self LSP, +-Self LSP(Extended), </span><br><span class="line">           ATT-Attached, P-Partition, OL-Overload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                          Level-2 Link State Database</span><br><span class="line"></span><br><span class="line">LSPID                 Seq Num      Checksum      Holdtime      Length  ATT/P/OL</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">0000.0000.0002.00-00  0x00000007   0x79ec        1184          68      0/0/0   </span><br><span class="line"> SOURCE       0000.0000.0002.00</span><br><span class="line"> NLPID        IPV4</span><br><span class="line"> AREA ADDR    10 </span><br><span class="line"> INTF ADDR    192.168.12.2</span><br><span class="line"> NBR  ID      0000.0000.0002.01  COST: 10        </span><br><span class="line"> IP-Internal  192.168.12.0    255.255.255.0    COST: 10        </span><br><span class="line"></span><br><span class="line">Total LSP(s): 1</span><br><span class="line">    *(In TLV)-Leaking Route, *(By LSPID)-Self LSP, +-Self LSP(Extended), </span><br><span class="line">           ATT-Attached, P-Partition, OL-Overload</span><br></pre></td></tr></table></figure><p>我们也查看以下伪节点的详细信息，比较一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[R1]display isis lsdb 0000.0000.0002.01-00 verbose</span><br><span class="line"></span><br><span class="line">                        Database information for ISIS(1)</span><br><span class="line">                        --------------------------------</span><br><span class="line"></span><br><span class="line">                          Level-1 Link State Database</span><br><span class="line"></span><br><span class="line">LSPID                 Seq Num      Checksum      Holdtime      Length  ATT/P/OL</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">0000.0000.0002.01-00  0x00000004   0x9ee8        1064          55      0/0/0   </span><br><span class="line"> SOURCE       0000.0000.0002.01</span><br><span class="line"> NLPID        IPV4</span><br><span class="line"> NBR  ID      0000.0000.0002.00  COST: 0         </span><br><span class="line"> NBR  ID      0000.0000.0001.00  COST: 0         </span><br><span class="line"></span><br><span class="line">Total LSP(s): 1</span><br><span class="line">    *(In TLV)-Leaking Route, *(By LSPID)-Self LSP, +-Self LSP(Extended), </span><br><span class="line">           ATT-Attached, P-Partition, OL-Overload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                          Level-2 Link State Database</span><br><span class="line"></span><br><span class="line">LSPID                 Seq Num      Checksum      Holdtime      Length  ATT/P/OL</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">0000.0000.0002.01-00  0x00000004   0x9ee8        1064          55      0/0/0   </span><br><span class="line"> SOURCE       0000.0000.0002.01</span><br><span class="line"> NLPID        IPV4</span><br><span class="line"> NBR  ID      0000.0000.0002.00  COST: 0         </span><br><span class="line"> NBR  ID      0000.0000.0001.00  COST: 0         </span><br><span class="line"></span><br><span class="line">Total LSP(s): 1</span><br><span class="line">    *(In TLV)-Leaking Route, *(By LSPID)-Self LSP, +-Self LSP(Extended), </span><br><span class="line">           ATT-Attached, P-Partition, OL-Overload</span><br></pre></td></tr></table></figure><p>可以看到伪节点的详细信息与前面表示R2的详细信息有很大的区别。伪节点的信息只包含了伪节点的邻居。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>正如前言所说，本文只做简单介绍，尤其是配置方面。本文只做基础的配置介绍，其他诸如静默端口、路由汇总、路由渗透、认证等等都不做介绍，请移步到产品文档观看。</p><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><h3 id="创建配置IS-IS进程"><a href="#创建配置IS-IS进程" class="headerlink" title="创建配置IS-IS进程"></a>创建配置IS-IS进程</h3><ol><li><p>执行命令<strong>system-view</strong>，进入系统视图。</p></li><li><p>执行命令<strong>isis</strong> [ <em>process-id</em> ] ，创建IS-IS进程并进入IS-IS视图。</p><p>参数<em>process-id</em>用来指定一个IS-IS进程。如果不指定参数<em>process-id</em>，则系统默认的进程为1。</p></li><li><p>执行命令<strong>network-entity</strong> <em>net</em>，设置网络实体名称。</p><p>注意！<strong>该命令相当于给设备分配了区域与系统ID。</strong></p><blockquote><p><strong>NET地址是全IS-IS网络中对路由器的唯一标识符，它由区域ID+系统ID</strong>+NSAP选择器（默认为00）组成</p><p>也别忘了：IS-IS在建立Level-2邻居时，不检查区域地址是否相同，而在建立Level-1邻居时，区域地址必须相同，否则无法建立邻居。</p></blockquote></li><li><p>执行命令<strong>is-level</strong> { <strong>level-1</strong> | <strong>level-1-2</strong> | <strong>level-2</strong> }，设置设备的Level级别。</p><p>未指定时，设备的Level级别为<strong>level-1-2</strong>。</p></li></ol><h3 id="在接口启用IS-IS进程"><a href="#在接口启用IS-IS进程" class="headerlink" title="在接口启用IS-IS进程"></a>在接口启用IS-IS进程</h3><ol><li><p>执行命令<strong>system-view</strong>，进入系统视图。</p></li><li><p>执行命令<strong>interface</strong> <em>interface-type</em> <em>interface-number</em>，进入接口视图。</p></li><li><p>执行命令<strong>isis enable</strong> [ <em>process-id</em> ]，在该接口启用IS-IS功能，可选指定哪个进程。</p><p>配置该命令后，IS-IS将通过该接口建立邻居、扩散LSP报文。</p><blockquote><p>由于Loopback接口不需要建立邻居，因此如果在Loopback接口下启用IS-IS，只会将该接口所在的网段路由通过其他IS-IS接口发布出去。</p></blockquote></li><li><p>（可选）执行命令<strong>isis circuit-level</strong> [ <strong>level-1</strong> | <strong>level-1-2</strong> | <strong>level-2</strong> ]，设置接口的Level级别。</p><p>两台Level-1-2设备建立邻居关系时，默认情况下，会分别建立Level-1和Level-2邻居关系。如果只希望建立Level-1或者Level-2的邻居关系，可以通过修改接口的Level级别实现。</p></li></ol><p>与RIP、OSPF不同，IS-IS在接口启用路由协议需要去接口下配置，是因为IS-IS工作在数据链路层，它并不感知IP地址，因此无法像其他路由协议那样通过“宣告”网段的方式去批量激活接口。</p><h3 id="示例与路由引入"><a href="#示例与路由引入" class="headerlink" title="示例与路由引入"></a>示例与路由引入</h3><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/9f847be6989926cea80c1.png"></p><p>以该拓扑为例，其中R1、R2、R3、R4、R5为IS-IS网络，而R5连着一OSPF网络，其中存在R6与R7两台路由器。</p><p>IS-IS网络属于10.1.0.0&#x2F;16网段的子网，OSPF属于192.168.0.0&#x2F;16网段内的子网。</p><p>区域的划分如图中所示，其中左侧为level-1层级的区域，右侧为level-2层级的区域。</p><h4 id="基础配置-1"><a href="#基础配置-1" class="headerlink" title="基础配置"></a>基础配置</h4><p>所有路由器的配置如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">R1配置如下：</span><br><span class="line">#</span><br><span class="line"> sysname R1</span><br><span class="line">#</span><br><span class="line">isis 1</span><br><span class="line"> network-entity 49.0123.0000.0000.0001.00</span><br><span class="line">#</span><br><span class="line">interface GigabitEthernet0/0/0</span><br><span class="line"> ip address 10.1.13.1 255.255.255.0 </span><br><span class="line"> isis enable 1</span><br><span class="line"> isis circuit-level level-1</span><br><span class="line">#</span><br><span class="line">interface GigabitEthernet0/0/1</span><br><span class="line"> ip address 10.1.14.1 255.255.255.0 </span><br><span class="line"> isis enable 1</span><br><span class="line"> isis circuit-level level-2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">R2配置如下：</span><br><span class="line">#</span><br><span class="line"> sysname R2</span><br><span class="line">#</span><br><span class="line">isis 1</span><br><span class="line"> network-entity 49.0123.0000.0000.0002.00</span><br><span class="line">#</span><br><span class="line">interface GigabitEthernet0/0/0</span><br><span class="line"> ip address 10.1.23.2 255.255.255.0 </span><br><span class="line"> isis enable 1</span><br><span class="line"> isis circuit-level level-1</span><br><span class="line">#</span><br><span class="line">interface GigabitEthernet0/0/1</span><br><span class="line"> ip address 10.1.24.2 255.255.255.0 </span><br><span class="line"> isis enable 1</span><br><span class="line"> isis circuit-level level-2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">R3配置如下：</span><br><span class="line">#</span><br><span class="line"> sysname R3</span><br><span class="line">#</span><br><span class="line">isis 1</span><br><span class="line"> is-level level-1</span><br><span class="line"> network-entity 49.0123.0000.0000.0003.00</span><br><span class="line">#</span><br><span class="line">interface GigabitEthernet0/0/0</span><br><span class="line"> ip address 10.1.13.3 255.255.255.0 </span><br><span class="line"> isis enable 1</span><br><span class="line"> isis circuit-level level-1</span><br><span class="line">#</span><br><span class="line">interface GigabitEthernet0/0/1</span><br><span class="line"> ip address 10.1.23.3 255.255.255.0 </span><br><span class="line"> isis enable 1</span><br><span class="line"> isis circuit-level level-1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">R4配置如下：</span><br><span class="line">#</span><br><span class="line"> sysname R4</span><br><span class="line">#</span><br><span class="line">isis 1</span><br><span class="line"> is-level level-2</span><br><span class="line"> network-entity 49.0045.0000.0000.0004.00</span><br><span class="line">#</span><br><span class="line">interface GigabitEthernet0/0/0</span><br><span class="line"> ip address 10.1.14.4 255.255.255.0 </span><br><span class="line"> isis enable 1</span><br><span class="line">#</span><br><span class="line">interface GigabitEthernet0/0/1</span><br><span class="line"> ip address 10.1.24.4 255.255.255.0 </span><br><span class="line"> isis enable 1</span><br><span class="line">#</span><br><span class="line">interface GigabitEthernet0/0/2</span><br><span class="line"> ip address 10.1.45.4 255.255.255.0 </span><br><span class="line"> isis enable 1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">R5配置如下：</span><br><span class="line">#</span><br><span class="line"> sysname R5</span><br><span class="line">#</span><br><span class="line">isis 1</span><br><span class="line"> is-level level-2</span><br><span class="line"> network-entity 49.0045.0000.0000.0005.00</span><br><span class="line">#</span><br><span class="line">interface GigabitEthernet0/0/0</span><br><span class="line"> ip address 10.1.45.5 255.255.255.0 </span><br><span class="line"> isis enable 1</span><br><span class="line">#</span><br><span class="line">interface GigabitEthernet0/0/1</span><br><span class="line"> ip address 192.168.56.5 255.255.255.0 </span><br><span class="line">#</span><br><span class="line">interface GigabitEthernet0/0/2</span><br><span class="line"> ip address 192.168.57.5 255.255.255.0 </span><br><span class="line">#</span><br><span class="line">ospf 1 router-id 5.5.5.5 </span><br><span class="line"> area 0.0.0.0 </span><br><span class="line">  network 192.168.0.0 0.0.255.255 </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">R6配置如下：</span><br><span class="line">#</span><br><span class="line"> sysname R6</span><br><span class="line">#</span><br><span class="line">interface GigabitEthernet0/0/0</span><br><span class="line"> ip address 192.168.56.6 255.255.255.0 </span><br><span class="line">#</span><br><span class="line">ospf 1 router-id 6.6.6.6 </span><br><span class="line"> area 0.0.0.0 </span><br><span class="line">  network 192.168.56.6 0.0.0.0 </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">R7配置如下：</span><br><span class="line">#</span><br><span class="line"> sysname R7</span><br><span class="line">#</span><br><span class="line">interface GigabitEthernet0/0/0</span><br><span class="line"> ip address 192.168.57.7 255.255.255.0 </span><br><span class="line">#</span><br><span class="line">ospf 1 router-id 7.7.7.7 </span><br><span class="line"> area 0.0.0.0 </span><br><span class="line">  network 192.168.57.7 0.0.0.0 </span><br></pre></td></tr></table></figure><p>完成以上配置后，IS-IS网络内的所有路由器都能互相访问，OSPF网络内的所有路由器也能互相访问。</p><h4 id="路由引入"><a href="#路由引入" class="headerlink" title="路由引入"></a>路由引入</h4><p>但IS-IS与OSPF网络之间还无法完全互通，需要在R5上配置路由引入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[R5]isis 1</span><br><span class="line">[R5-isis-1]import-route ospf 1</span><br></pre></td></tr></table></figure><p>配置完之后，我们可以检查R5的isis路由表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[R5]display isis route </span><br><span class="line"></span><br><span class="line">                         Route information for ISIS(1)</span><br><span class="line">                         -----------------------------</span><br><span class="line"></span><br><span class="line">                        ISIS(1) Level-2 Forwarding Table</span><br><span class="line">                        --------------------------------</span><br><span class="line"></span><br><span class="line">IPV4 Destination     IntCost    ExtCost ExitInterface   NextHop         Flags</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">10.1.24.0/24         20         NULL    GE0/0/0         10.1.45.4       A/-/-/-</span><br><span class="line">10.1.14.0/24         20         NULL    GE0/0/0         10.1.45.4       A/-/-/-</span><br><span class="line">10.1.23.0/24         30         NULL    GE0/0/0         10.1.45.4       A/-/-/-</span><br><span class="line">10.1.13.0/24         30         NULL    GE0/0/0         10.1.45.4       A/-/-/-</span><br><span class="line">10.1.45.0/24         10         NULL    GE0/0/0         Direct          D/-/L/-</span><br><span class="line">     Flags: D-Direct, A-Added to URT, L-Advertised in LSPs, S-IGP Shortcut,</span><br><span class="line">                               U-Up/Down Bit Set</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                       ISIS(1) Level-2 Redistribute Table</span><br><span class="line">                       ----------------------------------</span><br><span class="line"></span><br><span class="line"> Type IPV4 Destination     IntCost    ExtCost Tag       </span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"> D    192.168.57.0/24      0          0      </span><br><span class="line"> D    192.168.56.0/24      0          0      </span><br><span class="line"></span><br><span class="line">         Type: D-Direct, I-ISIS, S-Static, O-OSPF, B-BGP, R-RIP, U-UNR</span><br></pre></td></tr></table></figure><p>R5的isis路由表中出现了Redistribute Table（重定向表）一栏，包含了引入的OSPF路由。</p><p>还记得通信是双向的吗，虽然引入了OSPF路由，IS-IS网络内的路由器是拥有了OSPF网络内的路由信息，但OSPF中的路由器没有到IS-IS网络的信息。</p><p>因此，还得在R5上的ospf进程中，引入is-is路由。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[R5]ospf</span><br><span class="line">[R5-ospf-1]import-route isis 1</span><br></pre></td></tr></table></figure><p>在R6上检查是否引入成功（OSPF里，R5作为引入者，无法查看到）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[R6]display ospf routing </span><br><span class="line"></span><br><span class="line"> OSPF Process 1 with Router ID 6.6.6.6</span><br><span class="line">  Routing Tables </span><br><span class="line"></span><br><span class="line"> Routing for Network </span><br><span class="line"> Destination        Cost  Type       NextHop         AdvRouter       Area</span><br><span class="line"> 192.168.56.0/24    1     Transit    192.168.56.6    6.6.6.6         0.0.0.0</span><br><span class="line"> 192.168.57.0/24    2     Transit    192.168.56.5    7.7.7.7         0.0.0.0</span><br><span class="line"></span><br><span class="line"> Routing for ASEs</span><br><span class="line"> Destination        Cost      Type       Tag         NextHop         AdvRouter</span><br><span class="line"> 10.1.13.0/24       1         Type2      1           192.168.56.5    5.5.5.5</span><br><span class="line"> 10.1.14.0/24       1         Type2      1           192.168.56.5    5.5.5.5</span><br><span class="line"> 10.1.23.0/24       1         Type2      1           192.168.56.5    5.5.5.5</span><br><span class="line"> 10.1.24.0/24       1         Type2      1           192.168.56.5    5.5.5.5</span><br><span class="line"> 10.1.45.0/24       1         Type2      1           192.168.56.5    5.5.5.5</span><br><span class="line"></span><br><span class="line"> Total Nets: 7  </span><br><span class="line"> Intra Area: 2  Inter Area: 0  ASE: 5  NSSA: 0 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们也去检查下IS-IS网络中R1的路由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[R1]display isis route </span><br><span class="line"></span><br><span class="line">                         Route information for ISIS(1)</span><br><span class="line">                         -----------------------------</span><br><span class="line"></span><br><span class="line">                        ISIS(1) Level-1 Forwarding Table</span><br><span class="line">                        --------------------------------</span><br><span class="line"></span><br><span class="line">IPV4 Destination     IntCost    ExtCost ExitInterface   NextHop         Flags</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">0.0.0.0/0            20         NULL   </span><br><span class="line">10.1.23.0/24         20         NULL    GE0/0/0         10.1.13.3       A/-/L/-</span><br><span class="line">10.1.13.0/24         10         NULL    GE0/0/0         Direct          D/-/L/-</span><br><span class="line">     Flags: D-Direct, A-Added to URT, L-Advertised in LSPs, S-IGP Shortcut,</span><br><span class="line">                               U-Up/Down Bit Set</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        ISIS(1) Level-2 Forwarding Table</span><br><span class="line">                        --------------------------------</span><br><span class="line"></span><br><span class="line">IPV4 Destination     IntCost    ExtCost ExitInterface   NextHop         Flags</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">10.1.24.0/24         20         NULL    GE0/0/1         10.1.14.4       A/-/-/-</span><br><span class="line">10.1.14.0/24         10         NULL    GE0/0/1         Direct          D/-/L/-</span><br><span class="line">10.1.23.0/24         30         NULL   </span><br><span class="line">10.1.13.0/24         10         NULL    GE0/0/0         Direct          D/-/L/-</span><br><span class="line">192.168.57.0/24      20         0       GE0/0/1         10.1.14.4       A/-/-/-</span><br><span class="line">10.1.45.0/24         20         NULL    GE0/0/1         10.1.14.4       A/-/-/-</span><br><span class="line">192.168.56.0/24      20         0       GE0/0/1         10.1.14.4       A/-/-/-</span><br><span class="line">     Flags: D-Direct, A-Added to URT, L-Advertised in LSPs, S-IGP Shortcut,</span><br><span class="line">                               U-Up/Down Bit Set</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[R1]ping 192.168.56.6</span><br><span class="line">  PING 192.168.56.6: 56  data bytes, press CTRL_C to break</span><br><span class="line">    Reply from 192.168.56.6: bytes=56 Sequence=1 ttl=253 time=50 ms</span><br><span class="line">    Reply from 192.168.56.6: bytes=56 Sequence=2 ttl=253 time=30 ms</span><br><span class="line">    Reply from 192.168.56.6: bytes=56 Sequence=3 ttl=253 time=30 ms</span><br><span class="line">    Reply from 192.168.56.6: bytes=56 Sequence=4 ttl=253 time=30 ms</span><br><span class="line">    Reply from 192.168.56.6: bytes=56 Sequence=5 ttl=253 time=40 ms</span><br><span class="line"></span><br><span class="line">  --- 192.168.56.6 ping statistics ---</span><br><span class="line">    5 packet(s) transmitted</span><br><span class="line">    5 packet(s) received</span><br><span class="line">    0.00% packet loss</span><br><span class="line">    round-trip min/avg/max = 30/36/50 ms</span><br></pre></td></tr></table></figure><p>可以发现没有问题，也能访问到。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文主要是让读者知道IS-IS的基础概念与基本原理，甚至能搭建一个“能通”的IS-IS网络；至于实际的报文细节、内部的处理与配置细节都大幅弱化了。</p><p>如果读者有兴趣想深入学习，建立在模拟器搭建IS-IS拓扑，在模拟器内检查各信息并配合抓包工具进行观察。</p><p>或者说去找专门的课程视频学习。</p><p>此外，本文介绍的是ipv4场景的IS-IS，ipv6场景的IS-IS以后有机会我们再介绍吧。</p><blockquote><p><del>但实际工作中，估计几乎用不到。</del></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【动态路由1】ospf详解</title>
      <link href="/2024/06/28/%E3%80%90%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B11%E3%80%91ospf%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/06/28/%E3%80%90%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B11%E3%80%91ospf%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>OSPF开放式最短路径优先（Open Shortest Path First）是IETF组织开发的一个基于<strong>链路状态</strong>的内部网关协议。本文将介绍的是OSPF v2版本。除此之外还有一个v3版本，其适用于IPv6环境。</p><p>上一篇我们讲过的RIP是基于距离矢量算法的路由协议，存在着收敛慢、路由环路、可扩展性差等问题。</p><p>OSPF作为基于链路状态的协议，能够解决RIP所面临的诸多问题，<strong>目前RIP正在被OSPF淘汰</strong>。</p><ul><li>以运行RIP为例的距离矢量路由协议的路由器是依靠周期性的泛洪自己的路由表，每台路由器都从相邻路由器学习路由，它们不清楚网络的拓扑结构，只是简单的知道前往某个网段应该从那里走，走多远（出接口是哪、跳数多少）。</li><li>而运行以OSPF为例的链路状态路由协议的路由器则清楚整个网络拓扑结构，并以此计算规划出路线，从而使得路由不易环路。它们之间会先建立邻居关系，再交换链路状态信息，它们并不交换路由信息。路由信息只由自己收集链路状态信息后计算得到。</li></ul><blockquote><p>与其说让OSPF与RIP作比较来进行学习，我认为借助STP的知识来学习会更得心应手。不过一开始还是先跟RIP比较一下，之后介绍原理的时候我们就可以试着跟STP的原理对比一下。</p></blockquote><p>因此，在介绍OSPF之前，我们就得清楚什么是链路状态。</p><h1 id="链路状态"><a href="#链路状态" class="headerlink" title="链路状态"></a>链路状态</h1><p>链路状态路由协议则是使用一些特殊的信息描述网络的拓扑结构与网段信息，这些信息称为链路状态信息（Link State）。</p><p>这些信息会被存放于链路状态数据库LSDB（Link State Database）中，LSDB可以被视为对整个网络拓扑结构以及网段信息的描绘，LSDB同步后，所有路由器拥有对网络的一致认知。</p><p>接下来路由器都会独立进行SPF(shortest path first)最短路径优先算法，以得到一颗无环的最短路径树。</p><p>这棵树以自己为根，并且可以到达网络的各个角落，最终路由器将基于这棵树产生路由，并加载到路由表中。</p><p><strong>在OSPF中，这些链路状态信息被称为LSA</strong>（Link-State Advertisement,链路状态通告），OSPF定义了多种LSA类型，我们后续会介绍学习每种LSA的用途。</p><p>一般来说，我们可以认为一台路由器a发送给路由器b的LSA中包含了<em>网段</em>，<em>发现该网段的路由器</em>，<em>到达该目标网段的接口IP</em>。</p><blockquote><p>似乎一时间无法理解这与rip协议这种距离矢量协议直接传递的路由有什么不同。</p><p>解释一下，<strong><em>“ 发现该网段的路由器 ”</em> 不一定是路由器a，可以是其他路由器</strong>，在rip中是没有这个信息。</p><p>而<em>”到达该目标网段的接口IP“</em> 则是路由器a与路由器b相连的接口的IP，这与rip中传递的路由信息的下一跳是一个意思。</p></blockquote><p>实际lsa中不止包含以上三个信息，还有其他信息，这些信息集合起来就为路由器描绘整个网络结构提供了充分条件。</p><h1 id="ospf的基础原理"><a href="#ospf的基础原理" class="headerlink" title="ospf的基础原理"></a>ospf的基础原理</h1><p>我们先粗略的过一遍ospf的原理，再不断扩宽框架，有一个完整框架之后再由浅入深。</p><blockquote><p>OSPF适用于多种网络类型中（点对点、点对多点、多点对多点），本文未做特别说明的情况下，默认为介绍在多点对多点的网络（常见的以太网）下的情景。</p></blockquote><h2 id="原理简述"><a href="#原理简述" class="headerlink" title="原理简述"></a>原理简述</h2><p> OSPF 的工作原理简述：</p><ol><li><p><strong>邻居发现</strong>：OSPF 路由器通过发送 Hello 报文来发现相邻的路由器。当两台路由器在相互发送 Hello 报文确认彼此可达时，它们就成为邻居。</p></li><li><p><strong>链路状态广播</strong>：一旦建立邻居关系，路由器将定期发送链路状态更新报文（LSU），其中包含本地路由器所知道的网络拓扑信息（LSA）。</p></li><li><p><strong>路由计算</strong>：收到 LSU 报文后，每台路由器将更新其链路状态数据库（LSDB），并使用 Dijkstra 算法计算出最短路径树（SPF Tree），确定到达目的网络的最佳路径。</p></li><li><p><strong>路由表生成</strong>：根据 SPF Tree 计算结果，每台路由器生成自己的路由表，记录到达各个目的网络的最佳路径和下一跳信息。</p></li><li><p><strong>路由更新</strong>：如果网络拓扑发生变化，比如链路断开或恢复，路由器将重新计算最短路径树，并将这些链路状态信息的更新通过 LSU 报文广播给相邻路由器，以便网络中的所有路由器都能及时了解变化。</p></li></ol><blockquote><p>上述提到的广播并不是真正严格意义上的<em>广播（目标地址全1）</em>，OSPF是通过<strong>组播</strong>的方式进行通信的。</p></blockquote><h2 id="DR、router-id"><a href="#DR、router-id" class="headerlink" title="DR、router-id"></a>DR、router-id</h2><p>但如果每两台路由器都进行完整的LSA传递（包括后续的定期报文与更新报文），那么对网络资源是不小的占用。为此，OSPF中引入了类似于STP根桥的主备机制；同时为了标识路由器，也引入了类似于STP桥id的概念。</p><ul><li><strong>OSPF定义了<em>指定路由器DR</em>和<em>备份指定路由器BDR</em>。</strong></li></ul><blockquote><p>通过选举产生DR（Designated Router）后，所有路由器都只将信息发送给DR，由DR将网络链路状态LSA广播出去。如果DR由于某种故障而失效，则网络中的路由器必须重新选举DR，并与新的DR同步。这需要较长的时间，在这段时间内，路由的计算有可能是不正确的。</p><p>为了能够缩短这个过程，OSPF提出了BDR（Backup Designated Router）的概念。BDR是对DR的一个备份，在选举DR的同时也选举出BDR。当DR失效后，BDR会立即成为DR。由于不需要重新选举，并且关系已建立，所以这个过程非常短暂，这时还需要再重新选举出一个新的BDR，虽然一样需要较长的时间，但此时已经有新DR在工作了，并不会影响网络通信。</p></blockquote><ul><li><strong>OSPF定义了Router-ID (Router Identification，路由器标识)。</strong></li></ul><blockquote><p>router-id是一个32bit长度的数值，通常使用点分十进制表示（与IPv4地址一样），用于一个OSPF区域内表示唯一的一台路由器。也就是说router-id不能重复，冲突会导致无法建立关系。</p><p>一般router-id会自动根据路由器已配置的ip地址选定；但由于router-id不能重复，且与STP中的桥id类似，会影响<strong>根</strong>的选举，所以推荐手动配置router-id。</p></blockquote><ul><li>OSPF中DR&#x2F;BDR的选举规则</li></ul><blockquote><p>STP选举根桥的规则是先比较优先级值，优先级值一样，再比较mac。</p><p>OSPF与之类似，也是先比较优先级值，不过后比较的不是mac值而是router-id。</p><p>当处于同一网段的两台路由器同时宣布自己是DR时，DR优先级高者胜出。</p><p>如果优先级相等，则Router ID大者胜出。如果一台路由器的优先级为0，则它不会被选举为DR或BDR。</p></blockquote><ul><li>DR的选举不具备抢占性，当网络中有设备已经是DR的情况下，新接入的设备即便优先级更高，也还是认之前的DR路由器。</li></ul><h2 id="报文发送方式"><a href="#报文发送方式" class="headerlink" title="报文发送方式"></a>报文发送方式</h2><p>OSPF协议报文封装于IP协议报文中，协议号89。OSPF常使用两个组播地址进行数据通信。（目的地址）</p><ul><li>224.0.0.5：该组播地址指向所有OSPF路由器。</li><li>224.0.0.6：该组播地址指向DR&#x2F;BDR路由器。</li></ul><p>举个例子，在OSPF关系稳定后，普通OSPF路由器向DR发布链路更新报文使用224.0.0.6地址，而DR周期性的向所有路由发布定期报文或更新报文就采用224.0.0.5的地址</p><blockquote><p>不使用广播地址的原因就是为了不影响其他的非OSPF设备。而不使用同一个组播地址的原因则是为了上一节说的DR机制。</p></blockquote><p>注意，因为OSPF是使用组播地址进行通信，<strong>组播地址也可以算作一种广播，是会被网段隔离的，无法跨网段传输</strong>。因此选举DR与BDR，只能在一个网段内进行。</p><p>因此，<strong>在OSPF中，每个网段都会选举DR&#x2F;BDR</strong>，也就是说总体上看，可能会出现多个DR。</p><h2 id="邻居与邻接关系"><a href="#邻居与邻接关系" class="headerlink" title="邻居与邻接关系"></a>邻居与邻接关系</h2><p>我们一般会根据是否发送后续LSA更新来判断两台OSPF路由器是处于邻居还是邻接关系。</p><p>邻居关系是指两台路由器之间都能基于OSPF进行通信，也就是都拥有对方的信息（router-id）</p><p>而邻接关系是值两台路由器之间会进行LSA的交换并且LSDB最终都保持相同。</p><p>一般一个OSPF区域中，所有路由器两两之间都处于邻居关系；与DR以及BDR之间则处于邻接关系。</p><blockquote><p>事实上，也正是设定了DR、BDR的机制后才有了邻居与邻接的区分，否则邻居关系只是一个过程罢了。</p></blockquote><h3 id="邻居表"><a href="#邻居表" class="headerlink" title="邻居表"></a>邻居表</h3><p>一个路由器的接口激活OSPF后，该接口将会周期性的发送OSPF hello报文。</p><p>当OSPF接口收到hello报文，也就是发现邻居后，该hello报文中的信息将会被写入到路由器的OSPF邻居表中。</p><p>在邻居表中我们就可以看到“邻居”是处于邻居关系还是邻接关系。</p><blockquote><p> 有关hello报文的内容稍后介绍。</p></blockquote><h2 id="OSPF域"><a href="#OSPF域" class="headerlink" title="OSPF域"></a>OSPF域</h2><p>现在我们知道<strong>OSPF至少会维护三张数据表</strong>，分别是存放LSA信息的LSDB表、存放邻居信息的邻居表、存放计算得到的路由信息的路由表。</p><p>如果一个OSPF进程中存在十几台路由器、上百个网段，基于LSDB必须全路由器同步的机制，那么每台路由器维护的LSDB表将会很大，而根据LSDB计算而来的路由表也小不了。如果路由器数量更多，那么会更加庞大，同步这些表信息则会占用大量的网络资源，根据如此庞大的表信息进行计算也会消耗大量的设备性能。</p><p>因此，<strong>OSPF引入了区域的概念（Area</strong>），每个区域内部维护自己LSDB表，LSA的泛洪限制在区域内，避免对区域外部造成影响。</p><p>处于区域之间的路由器则额外负责进行LSA的整合，为连接的两个区域发布聚合的信息，以保证两个区域之间仍可进行通信。</p><p>但为了避免路由环路，所以设立了骨干区域（中心区域），只有<em>一侧处于骨干区域的路由器</em> 才拥有发布跨区域LSA的权限。</p><p>因此，每个区域都必须与骨干区域相连，否则没有<em>一侧处于骨干区域的路由器</em> 的帮助，缺少其他区域的LSA信息，则该区域无法与外界通信，成为一座“孤岛”。</p><blockquote><p>似乎有点抽象，我们比喻一下。</p><p>让快递小哥记忆全国所有城市的街道信息、楼栋信息这很难。</p><p>实际快递小哥只需要知道他负责区域的详细地理信息即可，超过他负责范围的快递件，他就拿回站点。</p><p>该快递件由站点直接发送给本市的分拣中心，在这里被发到转运中心。</p><p>由转运中心发往目标城市的分拣中心，最后再通过该城市的站点与快递小哥送达收件人手中。</p></blockquote><h3 id="区域的格式"><a href="#区域的格式" class="headerlink" title="区域的格式"></a>区域的格式</h3><p>Area-id与router-id一样，也是32bit的按点分十进制表示的数，例如：area0.0.0.1。</p><p>但实际上我们更常用完全的十进制来表示，例如area0.0.0.1写为area1，area0.0.1.0写为area256。</p><p><strong>骨干区域为area0.0.0.0也就是area0。</strong></p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>DR和BDR的选举是在每个OSPF区域上进行的，而不是在整个OSPF进程中进行的。这意味着在一个OSPF进程中可能存在多个DR和BDR。</p><h2 id="OSPF路由器的角色"><a href="#OSPF路由器的角色" class="headerlink" title="OSPF路由器的角色"></a>OSPF路由器的角色</h2><p>了解了以上的各种概念后，我们就可以来介绍一下OSPF中路由器一共有哪些角色。（除开表示根的DR与BDR）</p><blockquote><p>虽然会叫某某OSPF路由器，但请记住所有的协议进程都是以接口为主来运行的。</p></blockquote><ul><li><p>内部路由器(Internal Router，<strong>IR</strong>)：所有接口都接入同一个OSPF区域的路由器。</p></li><li><p>区域边界路由器(Area Border Router，<strong>ABR</strong>)：接入多个区域的路由器且至少一个接口在Area0中激活的路由器。<strong>ABR负责在区域之间传递路由信息，因此ABR必须连接到Area0，并同时连接着其他区域。</strong></p></li><li><p>骨干路由器(Backbone Router，<strong>BR</strong>)：接入Area0的路由器。ABR也是骨干路由器。</p></li><li><p>AS边界路由器 (AS Boundary Router，<strong>ASBR</strong>)：ASBR将OSPF域外的路由引入本域，使得外部路由在整个OSPF 域内传递。</p><p>比如说一台路由器除了接入OSPF网络，它还接入了一个RIP网络，如果它将自己路由表中通过RIP学习到的路由重分发到了OSPF 中，那它就是ASBR。（是先干了这事，它才成为ASBR）</p><p>并不是同时运行多种路由协议的OSPF路由器就一定是ASBR，<strong>ASBR一定是将外部路由重分发到OSPF，或者执行了路由重分发操作的路由器。</strong></p></li></ul><blockquote><p>虽然BR、ABR、ASBR这三者看起来都带了“BR”的名头，但它们并不是同一个意思。（所以标注了英文全称）</p><p>实际IR并没有什么特别的用途，只需记忆其他三个角色即可。</p></blockquote><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/49b5393707524f8e5d699.png" alt="一图展示区域与路由器类型"></p><h2 id="LSA类型1-5"><a href="#LSA类型1-5" class="headerlink" title="LSA类型1-5"></a>LSA类型1-5</h2><p>正因为OSPF划分了区域，并设计了ABR与ASBR的机制，因此我们可以为各路由器间发布的LSA进行一个分类。（实际后续还有其他类型，我们由浅到深慢慢展开介绍。）</p><blockquote><p>我们一般直接使用“类型几”这个称呼，几乎不使用完整的全称。</p></blockquote><table><thead><tr><th>LSA类型</th><th>LSA作用</th></tr></thead><tbody><tr><td>Router-LSA（Type1）</td><td>每个设备都会产生，描述了设备的链路状态和开销，在所属的区域内传播。</td></tr><tr><td>Network-LSA（Type2）</td><td>由DR产生，描述本网段的链路状态，在所属的区域内传播。（相当于DR对区域内所有路由器信息的汇总）</td></tr><tr><td>Network-summary-LSA（Type3）</td><td>由ABR产生，描述区域内某个网段的路由，并通告给其他区域。</td></tr><tr><td>ASBR-summary-LSA（Type4）</td><td>由ABR产生，描述到ASBR的路由，通告给除ASBR所在区域的其他相关区域。</td></tr><tr><td>AS-external-LSA（Type5）</td><td>由ASBR产生，描述到AS外部的路由，通告到所有的区域。</td></tr></tbody></table><p>type-4也就是对于type-5的补充与售后，其他区域的路由器即便知道了到达ospf区域外的网段要通过ASBR，但它们不知道如何到达ASBR，就需要与ASBR同区域的ABR去传播到达该ASBR的路由信息。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们目前是粗略的过一遍基础概念原理，还不够理解的，不必在意，<strong>稍后会详细介绍</strong>。</p><p>总的来说：</p><ol><li>OSPF会进行区域划分，有一个骨干区域Area0，其他区域必须与骨干区域相连。</li><li>OSPF中会对每台路由器分配一个router-id用于标识路由器身份。</li><li>每个区域内会基于router-id选举DR负责对区域内LSA的统合更新。</li><li>区域内的路由器通过类型1与类型2的LSA完成区域内LSDB的同步。</li><li>骨干区域与区域之间通过ABR的类型3LSA进行跨区域的信息传递。</li><li>如果某一台路由器连接了其他网络，并将该网络的路由信息引入到OSPF中，它会发布类型5的LSA告知其他路由器，同时它就宣布自己是一台ASBR。（全体目光向我看齐，我宣布个事，我是ASBR，去这个外部网络就来找我嗷。）</li><li>与该路由器同处一区域的ABR会自行产生并传播一条类型4的LSA用于告知其他路由器如何到达这台ASBR。</li></ol><p>除此之外，OSPF还有其他还没有提到的知识点，我们稍后会以有什么需求，因此有什么解决方案的方式来一一展开讲解。</p><h1 id="OSPF的报文格式、邻居状态、邻居-邻接建立过程"><a href="#OSPF的报文格式、邻居状态、邻居-邻接建立过程" class="headerlink" title="OSPF的报文格式、邻居状态、邻居&#x2F;邻接建立过程"></a>OSPF的报文格式、邻居状态、邻居&#x2F;邻接建立过程</h1><h2 id="OSPF的报文类型"><a href="#OSPF的报文类型" class="headerlink" title="OSPF的报文类型"></a>OSPF的报文类型</h2><table><thead><tr><th>报文类型</th><th>报文作用</th></tr></thead><tbody><tr><td>Hello报文</td><td>周期性发送，用来发现和维持OSPF邻居关系。</td></tr><tr><td>DD报文（Database <strong>Description</strong> packet）</td><td>描述本地LSDB（Link State Database）的摘要信息，用于两台设备进行数据库同步。</td></tr><tr><td>LSR报文（Link State <strong>Request</strong> packet）</td><td>用于向对方请求所需的LSA。设备只有在OSPF邻居双方成功交换DD报文后才会向对方发出LSR报文。</td></tr><tr><td>LSU报文（Link State <strong>Update</strong> packet）</td><td>用于向对方发送其所需要的LSA。</td></tr><tr><td>LSAck报文（Link State <strong>Acknowledgment</strong> packet）</td><td>用来对收到的LSA进行确认。</td></tr></tbody></table><blockquote><p>LSA是链路状态信息，是报文内部的信息，注意不要混淆了名称。</p></blockquote><h2 id="OSPF的邻居状态"><a href="#OSPF的邻居状态" class="headerlink" title="OSPF的邻居状态"></a>OSPF的邻居状态</h2><p>OSPF的邻居共有8种状态，分别是：Down、Attempt、Init、2-way、Exstart、Exchange、Loading、Full。</p><ul><li><strong>Down</strong>：邻居会话的初始阶段，或者是没有在邻居失效时间间隔内收到来自邻居路由器的Hello数据包。</li><li>Attempt：该状态仅发生在非广播的多路网络中（帧中继那一类，但基本被淘汰了），表明对端在邻居失效时间间隔（dead interval）超时前仍然没有回复Hello报文。此时路由器依然每发送轮询Hello报文的时间间隔（poll interval）向对端发送Hello报文。</li><li><strong>Init</strong>：收到Hello报文后状态为Init。</li><li><strong>2-way</strong>：<strong>收到的Hello报文中包含有自己的Router ID，则状态为2-way</strong>；<strong>如果不需要形成邻接关系则邻居状态机就停留在此状态，否则进入Exstart状态。</strong></li><li><strong>Exstart</strong>：开始协商主从关系，并确定DD的序列号，此时状态为Exstart。</li><li><strong>Exchange</strong>：主从关系协商完毕后开始交换DD报文，此时状态为Exchange。</li><li><strong>Loading</strong>：DD报文交换完成即Exchange done，此时状态为Loading。</li><li><strong>Full</strong>：LSR重传列表为空，此时状态为Full。full也表示邻接关系建立完毕。</li></ul><h2 id="建立邻居关系"><a href="#建立邻居关系" class="headerlink" title="建立邻居关系"></a>建立邻居关系</h2><p>如图所示为路由器R1与路由器R2的邻居关系建立过程。其中路由器R1的router-id为1.1.1.1，路由器R2的router-id为2.2.2.2。</p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/81c89f47a43e6a4fb40f1.png" style="zoom: 67%;" /><ol><li><p>R1的一个连接到广播类型网络的接口上激活了OSPF协议，并发送了一个Hello报文（目的地址使用组播地址224.0.0.5；源地址为接口IP：10.1.12.1）</p><p>同时该报文内包含了router-id（指代发送人），区域id，<strong>网络掩码（与源ip结合起来得到该接口的网段）</strong>，OSPF的一些定时器，以及最重要的<strong>已发现邻居列表</strong>。（当前未发现，则为空）。</p></li><li><p>R2收到R1发送的Hello报文后，学习到R1的router-id，计入进邻居表中，同时对外发布hello报文，并且在报文中的Neighbors Seen字段中填入R1的Router ID（Neighbors Seen&#x3D;1.1.1.1），表示我知道有你这个邻居了，然后R2邻居状态机置为Init。</p></li><li><p>当R1收到R2回应的Hello报文，因报文内的邻居列表有自己的router-id，于是将邻居状态机置为2-way状态，同时也因为学习到了R2的id，会对外再发送一个更新的hello报文。</p><p>R2收到R1发送的最新Hello报文后，在报文内也发现了自己router-id，也将邻居状态机置为2-way状态</p></li></ol><blockquote><p>总结一下：收到hello报文，报文内没有自己的router-id，则状态为int；收到hello报文，报文内有自己的router-id，则状态为2-way。</p><p>这两个状态并不是连续的，上图中，RouterA的状态就是从Dowm直接过渡到2-way。</p></blockquote><p>除开router-id，hello报文内的其他信息是构建邻居关系的重要条件；区域id、网段（源ip与掩码计算得出）、hello间隔、失效间隔哪怕有一项不相同，也无法构建邻居关系。</p><p>另外，当两台路由器构建完毕邻居关系（都标记为“2-way”状态），将会开始DR&#x2F;BDR的选举。</p><h2 id="建立邻接关系"><a href="#建立邻接关系" class="headerlink" title="建立邻接关系"></a>建立邻接关系</h2><p>当路由器确定好DR&#x2F;BDR后，如果两台路由器之间都是非DR&#x2F;BDR，则关系停留在邻居。</p><p>如果其中一台路由器为DR&#x2F;BDR，则会交换LSA信息，最终发展为邻接关系。</p><blockquote><p>此过程是以单播的形式进行交互，不采用OSPF默认的组播地址。</p></blockquote><p>在交换LSA之前，路由器之间会协商主&#x2F;从关系，然后先交换简要的LSA信息，待确定需要LSA信息后，会请求对方给出该简要信息的全部完整信息。</p><blockquote><p>为了提高发送的效率，R1和R2首先了解对端数据库中哪些LSA是需要更新的，如果某一条LSA在LSDB中已经存在，就不再需要请求更新了。</p><p>为了达到这个目的，R1和R2先发送DD报文，DD报文中包含了对LSDB中LSA的摘要描述（每一条摘要可以唯一标识一条LSA）。</p><p>为了保证在传输的过程中报文传输的可靠性，在DD报文的发送过程中需要确定双方的主从关系，作为Master的一方定义一个序列号Seq，每发送一个新的DD报文将Seq加一，作为Slave的一方，每次发送DD报文时使用接收到的上一个Master的DD报文中的Seq。（类似TCP的机制）</p></blockquote><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/964bf40ddc36f5592ef84.png" style="zoom:67%;" /><ol><li><p>R1首先发送一个DD报文，宣称自己是Master（MS&#x3D;1），并规定序列号Seq&#x3D;X（图中假定为200）.</p><p>I&#x3D;1表示这是第一个的DD报文，报文中并不包含LSA的摘要，只是为了协商主从关系。</p><p>M&#x3D;1说明这不是最后一个报文，后续还有DD报文要发送。</p></li><li><p>R2在收到R1的DD报文后，将R1的邻居状态机改为Exstart，并且回应了一个DD报文（该报文中同样不包含LSA的摘要信息）。</p><p>由于R2的router-id较大，所以在报文中R2认为自己是Master，并且重新规定了序列号Seq&#x3D;Y（图中假定为300）。</p></li><li><p>R1收到报文后，同意了R2为Master，并将R2的邻居状态机改为Exchange。</p><p>R1使用R2的序列号Seq&#x3D;300来发送新的DD报文，该报文开始正式地传送LSA的摘要。</p><p>在报文中R1将MS&#x3D;0，说明自己是Slave。</p></li><li><p>R2收到报文后，将R1的邻居状态机改为Exchange，并发送新的DD报文开始描述自己的LSA摘要，此时R2将报文的序列号改为Seq&#x3D;300+1。</p></li><li><p>如果双方的LSDB包含的LSA信息数量很多，一条DD报文无法简述完毕，则会重复以上的交互，即：master路由器R2将DD序列号逐次加一，发送新的DD报文；slave路由器R1则使用前者的DD序列号发送自己的DD报文。</p></li></ol><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/a2db7359b0f999f800bcc.png" style="zoom:67%;" /><ol><li><p>当R1将把自己的<em>LSA摘要</em> 都发送完毕，也就是发送最后一个DD报文时，会将M比特位设置位0，表示这是最后一个DD报文。</p></li><li><p>R2收到R1的最后一个DD报文的时候，恰好也是要发送最后一个报文了，同样将M比特位设置位0。</p></li><li><p>R1收到R2的最后一个<em>序列号为309</em> 的DD报文后，即便它已经没有<em>LSA摘要</em> 需要发布了，但它仍需要对R2的报文进行回复确认（DD序列号相同即为确认），则它会向R2发送一个空的序号为309的DD报文。</p></li><li><p>R1发送完毕DD报文且收到R2的最后一个DD报文后，就会开始查看R2的<em>LSA摘要</em>，R1发现其中有许多LSA是自己没有的，将邻居状态机改为Loading状态。</p><p>R1发送LSR报文向R2请求更新LSA。</p></li><li><p>R2用LSU报文来回应R1的请求。</p></li><li><p>同样的，如果R2需要向R1请求LSA，也会发送LSR报文。</p></li><li><p>R1收到R2的LSU报文后，发送LSAck报文确认。收到R2的LSR请求则发送LSU报文。</p></li></ol><p>上述过程持续到R1&#x2F;R2发现已经没有LSA需要向对方请求，同时R1&#x2F;R2会将邻居状态机改为Full状态。</p><p>当R1与R2都将对方设置为Full状态，此时邻接关系建立完成。</p><h1 id="OSPF的度量值——cost"><a href="#OSPF的度量值——cost" class="headerlink" title="OSPF的度量值——cost"></a>OSPF的度量值——cost</h1><p>每种路由协议对度量值的规定是不同的，RIP是采用跳数，而在OSPF中，是使用cost（开销、代价）作为路由度量值。</p><p>cost值越小，则路由越优，其含义是走该路由所需的开销&#x2F;代价&#x2F;成本最低。</p><p>这个东西与STP协议中计算到根桥的路径开销值是差不多的概念。</p><p>在STP里，链路开销是按链路带宽给一个固定值。</p><p>而在ospf里，链路开销cost是用一个带宽参考值除以链路带宽得到的，如果值小于1则计为1。</p><p>为了让路由器能分清千兆、万兆的链路，所以会将带宽参考值设置的大一些，以避免千兆与万兆的cost值计算出来都为1。</p><h1 id="特殊区域（末梢区域）"><a href="#特殊区域（末梢区域）" class="headerlink" title="特殊区域（末梢区域）"></a>特殊区域（末梢区域）</h1><p>ospf使用了区域的划分来限制LSA在网络中的泛洪，减小路由器内部表的规模，但我们还可以更进一步。</p><h2 id="Stub-Area-（末梢区域）"><a href="#Stub-Area-（末梢区域）" class="headerlink" title="Stub Area （末梢区域）"></a>Stub Area （末梢区域）</h2><p>当一个<strong>非area0</strong>的普通区域只有一个出口（也就是只有一个ABR），那么该区域就可以被配置为Stub区域。</p><p>当一个区域被配置为Stub区域，这个区域的ABR会拦截type-5 LSA（指向外部网络的路由）。同时，该ABR会以type-3 LSA的形式发布一条默认路由，让区域内路由器学习。</p><blockquote><p>当然，发布的还是LSA，只是该LSA内的信息会被计算为默认路由。</p><p>另外既然拦截了type-5，那么type-4也没有存在意义，因此也会一并拦截。</p></blockquote><p>也就是说，这台ABR作为唯一出口，那么其他路由器访问外部网络直接默认指向它就可以，不需要拥有指定网段的路由，反正最后也是要经过它。这样就缩小了LSA与路由表项模。</p><h2 id="Totally-Stub-Area（完全末梢区域）"><a href="#Totally-Stub-Area（完全末梢区域）" class="headerlink" title="Totally Stub Area（完全末梢区域）"></a>Totally Stub Area（完全末梢区域）</h2><p><strong>在stub区域的基础上</strong>，因为只有一个出口，那么我们很简单就可以想到，包括前往其他区域的路由也都是经过这个出口，那么也可以在本区域取消到其他区域的信息。</p><p>为此就提出了完全末梢区域，该区域的ABR会将区域路由也一并拦截，只发布一条type-3LSA——描述指向自己的默认路由给区域内的路由器。</p><p>这样一来，该区域内仅存在type-1与type-2、以及唯一一条type-3的LSA。</p><h2 id="NSSA-Not-So-Stubby-Area，非完全末梢区域"><a href="#NSSA-Not-So-Stubby-Area，非完全末梢区域" class="headerlink" title="NSSA (Not-So-Stubby Area，非完全末梢区域)"></a>NSSA (Not-So-Stubby Area，非完全末梢区域)</h2><p>不管是普通的Stub区域还是Totally Stub区域，都是会拦截type-4与type-5的LSA。</p><p>但假设该末梢区域内某台路由直接连接着一个外部网络（比如RIP网络），那么与该路由器同属于一个ospf网络的其他区域路由器就无法学习到该外部RIP网络，因为相关的LSA被拦截了。</p><p>如果要传递出去，那只能取消了末梢区域，可我们又想保留限制其他区域传来外部路由，有没有什么办法呢。</p><p>NSSA，非完全末梢区域就是为了解决这种情况出现的。</p><p>在NSSA中，启用了一种新的LSA类型，type-7：NSSA LSA。该类型LSA由ASBR产生，描述到AS外部的路由，仅在NSSA区域内传播。</p><p>而该区域的ABR会将该type-7LSA转化为type-5LSA再发送给其他区域，以便该描述外部路由的链路信息能在整个OSPF网络中通告。</p><h2 id="Totally-NSSA"><a href="#Totally-NSSA" class="headerlink" title="Totally NSSA"></a>Totally NSSA</h2><p>NSSA对标的是普通Stub区域，其并不拦截type-3LSA。如果需要像Totally Stub区域一样，拦截type-3LSA，就可以配置为Totally NSSA区域。</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>区域与其可允许出现的LSA类型：</p><table><thead><tr><th></th><th>type-1</th><th>type-2</th><th>type-3</th><th>type-4</th><th>type-5</th><th>type-7</th></tr></thead><tbody><tr><td>常规区域</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>Stub区域</td><td>√</td><td>√</td><td>√</td><td>×</td><td>×</td><td>×</td></tr><tr><td>Totally Stub区域</td><td>√</td><td>√</td><td>×</td><td>×</td><td>×</td><td>×</td></tr><tr><td>NSSA</td><td>√</td><td>√</td><td>√</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Totally NSSA</td><td>√</td><td>√</td><td>×</td><td>×</td><td>×</td><td>√</td></tr></tbody></table><blockquote><p>两个Totally区域禁用type-3区域后，会由ABR发布一条type-3的描述指向自己的默认路由的LSA。全区域内仅存在这一条type-3LSA信息。</p></blockquote><h1 id="OSPF的维护"><a href="#OSPF的维护" class="headerlink" title="OSPF的维护"></a>OSPF的维护</h1><p>一般来说，OSPF中的路由器会周期性的发布hello报文以及时发现邻居以及表示自身还存活着。</p><p>当路由器在规定的失效时间内还没有收到邻居的周期性hello报文，则会认为邻居挂了。（失效时间能在hello报文中查看）</p><p>当路由器会在发现网络拓扑发生变更时，像RIPv2那样触发更新，发布LSU报文给DR，以便网络更快地收敛。</p><h1 id="LSA详解"><a href="#LSA详解" class="headerlink" title="LSA详解"></a>LSA详解</h1><p>先简单过一遍各种类型的名称与作用：</p><table><thead><tr><th>LSA类型</th><th>LSA作用</th></tr></thead><tbody><tr><td>Router-LSA（Type1）</td><td>每个设备都会产生，描述了设备的链路状态和开销，在所属的区域内传播。</td></tr><tr><td>Network-LSA（Type2）</td><td>由DR产生，描述本网段的链路状态，在所属的区域内传播。（相当于DR对区域内所有路由器信息的汇总）</td></tr><tr><td>Network-summary-LSA（Type3）</td><td>由ABR产生，描述区域内某个网段的路由，并通告给其他区域。</td></tr><tr><td>ASBR-summary-LSA（Type4）</td><td>由ABR产生，描述到ASBR的路由，通告给除ASBR所在区域的其他相关区域。</td></tr><tr><td>AS-external-LSA（Type5）</td><td>由ASBR产生，描述到AS外部的路由，通告到所有的区域。</td></tr><tr><td>NSSA-LSA（Type7）</td><td>仅用于NSSA区域，由该区域的ASBR产生，用于描述到AS外部的路由，仅通告给该区域。</td></tr></tbody></table><p>虽然我们总是说成发送一个type-*的报文，但实际呢，我们回忆一下邻接关系的报文交互，<strong>LSA信息是通过LSU报文传递的</strong>。</p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/627a02faee9f1cd93d917.png" style="zoom:80%;" /><p>其中，LSA的头部格式如下图所示：</p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/85521da41d930c3d800d0.png" style="zoom:80%;" /><p>需要关注的是以下三个字段，这三个字段唯一的标识一个LSA：</p><ul><li>链路状态类型（Link-State Type）：指示本条LSA的类型。</li><li>链路状态ID（Link-State ID）：LSA的标识。不同类型的LSA对该字段的定义不同。</li><li>通告路由器（Advertising Router）：产生该条LSA的路由器的router-id。</li></ul><blockquote><p>如果有两条LSA的这三个字段都一样，这表明这是同一条LSA，但他们肯定有新旧之分。而链路状态序列号、校验和、老化时间这三个字段就是为了判断LSA的“新鲜程度”。</p></blockquote><p>接下来我们以下面这个网络拓扑为基础，详细的介绍每种LSA。请注意，我们要讲的是一个LSU报文中的数据内容里的LSA内的数据部分；也就是默认剥离了LSU的包头，LSA的头部。（有点绕口，在看一下上面的图理解一下。）</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/9d21f2b585b7bd9964316.png"></p><blockquote><p>设定R3为area 0的DR。</p></blockquote><h2 id="type-1-LSA"><a href="#type-1-LSA" class="headerlink" title="type-1 LSA"></a>type-1 LSA</h2><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/653fc670928be51ea1a85.png" style="zoom: 80%;" /><p>对于Router LSA，也就是type-1LSA，其LSA头部中的”链路状态类型“字段的值为1，”<strong>链路状态ID</strong>“字段的值为产生该LSA的路由器router-id。</p><p>除开LSA的头部信息，type-1 LSA包含的数据部分的内容（红框）如下：</p><blockquote><ul><li><p>**V 位(Virtual Link Endpoint Bit)**：如果该比特位被设置为 1，则表示该路由器为 Virtual Link（虚链路）的端点。 </p></li><li><p>**E 位(External Bit)**：如果 E 比特位被设置为 1，则表示该路由器为 ASBR。 在 Stub区域中，不允许出现E比特位被设置为1的Type-1 LSA，因此Stub区域内不允许出现ASBR。</p></li><li><p>**B 位(Border Bit)**：如果 B 比特位被设置为 1，则表示该路由器为两个区域的边界路由器（即使该路由器为连接Area0），字母 B 意为 Border(边界)。</p></li><li><p>**链路数量(Links Number)**：该 Type-1 LSA 所描述的 Link(链路)数量。 </p><p>我们已经知道每台路由器都会产生 Type-1 LSA，而且该 LSA 描述了路由器直连接口的状况和 Cost 值，实际上路由器正是采用包含在Type-1 LSA中的Link来描述直连接口的。</p><p> “链路数量”字段指明在该Type-1 LSA中，包含了几条Link。 每条Link均包含“链路类型”、 “链路ID” 、”链路数据”以及“度量值”这几个关键信息。 路由器可能会采用一个或者多个Link 来描述某个接口。 </p></li><li><p>**链路类型(Link Type)**：本条 Link 的类型值，该值与 Link 的类型相关。 OSPF定义了多种链路类型,这些链路类型与接口的网络类型也是有关的。下表中罗列了 OSPF 定义的各种链路类型及对应的链路ID、链路数据的描述。</p><table><thead><tr><th>链路类型</th><th>描述</th><th>链路ID</th><th>链路数据</th></tr></thead><tbody><tr><td>1</td><td>点对点协议的方式<br />连接到另一台路由器</td><td>对端路由器的<br />router-id</td><td>产生该LSA的接口IP地址</td></tr><tr><td>2</td><td>多路访问的方式（比如以太网）<br />连接到一个传输网络</td><td>区域内DR的<br />接口IP地址</td><td>产生该LSA的接口IP地址</td></tr><tr><td>3</td><td>连接到一个末梢网络<br />（该接口没有连接其他OSPF路由器）</td><td>网络地址（网段）</td><td>子网掩码</td></tr><tr><td>4</td><td>虚链路</td><td>对端路由器的<br />router-id</td><td>产生该LSA的接口IP地址</td></tr></tbody></table></li><li><p>**链路ID(Link ID)**：Link 的标识,不同的链路类型,对链路 ID 值的定义是不同的。</p></li><li><p>**链路数据(Link Data)**：不同的链路类型对链路数据的定义是不同的。</p></li><li><p>**度量值(Metric)**：Cost 值。</p></li><li><p>TOS相关字段是ospf v1版本遗留下来的，为了做兼容，所以没有删除，目前已经不再使用了，因此可以忽略。（其他LSA内也有该字段，之后不再重复说明了）</p></li></ul></blockquote><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>网络中的每台路由器都会产生type-1 LSA。</p><h4 id="以R1为例："><a href="#以R1为例：" class="headerlink" title="以R1为例："></a>以R1为例：</h4><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/95f1b79af02d7815226e7.png"></p><p>其在GE0&#x2F;0&#x2F;0与GE0&#x2F;0&#x2F;1口启用了OSPF，因此它会产生一个用于描述这两个接口状况的type-1 LSA，并将该LSA泛洪到所在区域内。</p><ul><li><p>接口GE0&#x2F;0&#x2F;0连接的是以太网，ip为192.168.123.1&#x2F;24，该接口上有其他OSPF邻居（R2、R3）。因此描述该接口的关键信息为：链路类型&#x3D;2，链路ID&#x3D;192.168.123.3（R3为DR），链路数据&#x3D;192.168.123.1，度量值&#x3D;1（GE口表示千兆以太网）。</p></li><li><p>接口GE0&#x2F;0&#x2F;1连接的是以太网，ip为192.168.1.254&#x2F;24，该接口上没有其他OSPF邻居，属于一个末梢网络。因此描述该接口的关键信息为：链路类型&#x3D;3，链路ID&#x3D;192.168.1.0，链路数据&#x3D;255.255.255.0，度量值&#x3D;1（GE口表示千兆以太网）。</p></li><li><p>使用 <strong>display ospf Isdb router</strong> 命令可以查看 LSDB 中的 Type-1 LSA。</p><p>如果在该命令后再增加 <strong>originate-router</strong> 关键字则可以查看指定的 OSPF 路由器（填入router-id）产生的 Type-1 LSA。</p></li></ul><p>例如查看R1的type-1 LSA：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[R1]dis ospf lsdb router originate-router 1.1.1.1</span><br><span class="line"></span><br><span class="line"> OSPF Process 1 with Router ID 1.1.1.1</span><br><span class="line">         Area: 0.0.0.0</span><br><span class="line"> Link State Database </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Type      : Router</span><br><span class="line">  Ls id     : 1.1.1.1</span><br><span class="line">  Adv rtr   : 1.1.1.1  </span><br><span class="line">  Ls age    : 0 </span><br><span class="line">  Len       : 48 </span><br><span class="line">  Options   :  E  </span><br><span class="line">  seq#      : 80000006 </span><br><span class="line">  chksum    : 0x19e3</span><br><span class="line">  Link count: 2</span><br><span class="line">   * Link ID: 192.168.123.3 </span><br><span class="line">     Data   : 192.168.123.1 </span><br><span class="line">     Link Type: TransNet     </span><br><span class="line">     Metric : 1</span><br><span class="line">   * Link ID: 192.168.1.0  </span><br><span class="line">     Data   : 255.255.255.0 </span><br><span class="line">     Link Type: StubNet      </span><br><span class="line">     Metric : 1 </span><br><span class="line">     Priority : Low</span><br></pre></td></tr></table></figure><p>可以看到其中包含了两条link，信息就是我们前面分析过的。</p><h4 id="以R3为例："><a href="#以R3为例：" class="headerlink" title="以R3为例："></a>以R3为例：</h4><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/6289d5482ce798368cb00.png"></p><p>R3两个接口分别处于area0与area1，因为规定type-1 LSA只能在区域内传播，因此R3会产生两个type-1 LSA。</p><p>描述GE0&#x2F;0&#x2F;0接口的LSA在area0内传播，描述S1&#x2F;0&#x2F;0接口的LSA在area1内传播。</p><p>我们主要看area1的这个LSU报文，其中的LSA包含了两条link信息。</p><blockquote><p>其中一条link的链路类型&#x3D;1（表示点对点协议网络），链路ID&#x3D;4.4.4.4（对端路由器id），链路数据&#x3D;192.168.34.3（本端接口ip），度量值&#x3D;48（华为的串口默认速率计算过来就是48）。</p><p>另一条link的链路类型&#x3D;3，链路ID&#x3D;192.168.34.0，链路数据&#x3D;255.255.255.0，度量值&#x3D;48。</p></blockquote><p>之所以使用两条link信息来描述，是为了帮助其他路由器绘制网络拓扑：</p><blockquote><p>第一条link用于告诉该串口对端设备的id与ip地址，第二条link是告诉该链路的网段是多少。</p><p>第一条只能说明ip地址，缺少掩码去推导网段。</p><p>而如果只使用第二条又不能告诉其他路由器这是点对点通信链路。</p></blockquote><p>我们也查看一下R3的type-1 LSA详细信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[R3]dis ospf lsdb router originate-router o 3.3.3.3</span><br><span class="line"></span><br><span class="line"> OSPF Process 1 with Router ID 3.3.3.3</span><br><span class="line">         Area: 0.0.0.0</span><br><span class="line"> Link State Database </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Type      : Router</span><br><span class="line">  Ls id     : 3.3.3.3</span><br><span class="line">  Adv rtr   : 3.3.3.3  </span><br><span class="line">  Ls age    : 68 </span><br><span class="line">  Len       : 36 </span><br><span class="line">  Options   :  ABR  E  </span><br><span class="line">  seq#      : 80000008 </span><br><span class="line">  chksum    : 0x7de5</span><br><span class="line">  Link count: 1</span><br><span class="line">   * Link ID: 192.168.123.3 </span><br><span class="line">     Data   : 192.168.123.3 </span><br><span class="line">     Link Type: TransNet     </span><br><span class="line">     Metric : 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         Area: 0.0.0.1</span><br><span class="line"> Link State Database </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Type      : Router</span><br><span class="line">  Ls id     : 3.3.3.3</span><br><span class="line">  Adv rtr   : 3.3.3.3  </span><br><span class="line">  Ls age    : 25 </span><br><span class="line">  Len       : 48 </span><br><span class="line">  Options   :  ABR  E  </span><br><span class="line">  seq#      : 80000002 </span><br><span class="line">  chksum    : 0x2878</span><br><span class="line">  Link count: 2</span><br><span class="line">   * Link ID: 4.4.4.4      </span><br><span class="line">     Data   : 192.168.34.3 </span><br><span class="line">     Link Type: P-2-P        </span><br><span class="line">     Metric : 48</span><br><span class="line">   * Link ID: 192.168.34.0 </span><br><span class="line">     Data   : 255.255.255.0 </span><br><span class="line">     Link Type: StubNet      </span><br><span class="line">     Metric : 48 </span><br><span class="line">     Priority : Low</span><br></pre></td></tr></table></figure><h2 id="type-2-LSA"><a href="#type-2-LSA" class="headerlink" title="type-2 LSA"></a>type-2 LSA</h2><p>在type-1 LSA中，描述传输网络的链路类型的link信息内仅含有接口ip地址，并没有子网掩码，也因此不知道有多少路由器是在同一网段上。</p><p>因此就需要使用到type-2 LSA了。</p><p>OSPF的机制里，每个网段的路由器都会自行选举DR，未成为DR的路由器与DR构建邻接关系，并且邻居建立过程中的hello报文就包含了子网掩码的信息。因此对于DR来说，它清楚自己所处的网段以及与它相连的所有同网段路由器的接口ip地址与router-id。</p><p>所以，直接规定type-2 LSA由DR来产生并通告出去。</p><blockquote><p>实际上，type-1的LSA也是经由DR来泛洪传播的。</p><p>R1的type-1LSA不会直接发给R2，而是发送给由身为DR的R3（使用224.0.0.6的组播地址）；之后R3与R2再进行LSA的更新（使用224.0.0.5的组播地址）。</p></blockquote><h3 id="报文格式-1"><a href="#报文格式-1" class="headerlink" title="报文格式"></a>报文格式</h3><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/9e1687d25469a6ccaa167.png" style="zoom:80%;" /><p>在Type-2 LSA中，LSA头部中的“链路状态类型”字段的值为2，<strong>“链路状态ID”字段的值为产生这个Type-2 LSA的DR的接口ip地址。</strong></p><p>除开LSA的头部信息，Type-2 LSA包含的数据部分的内容（红框）如下：</p><blockquote><ul><li><p>**网络掩码(Network Mask)**：该接口所连网络的网络掩码。</p></li><li><p><strong>相连的路由器(Attached Router)的 Router-ID</strong>：连接到该网络的路由器的 Router-ID。</p><p>如果有多台路由器接入该网络，则使用多个字段描述。(至少包含了DR 自己的 Router-ID、以及与该 DR 建立了邻接关系的邻居的 Router-ID)</p></li></ul></blockquote><p><strong>在OSPF中，因为使用的是组播地址，无法跨网段传输，所以每个网段都会选举DR。</strong></p><p><strong>因此仅需要在LSA头部信息里写明了该网段的DR的ip地址，再配合LSA数据部分的子网掩码，就可以得到网段了。</strong></p><h3 id="举例说明-1"><a href="#举例说明-1" class="headerlink" title="举例说明"></a>举例说明</h3><p>我们先给之前的拓扑多加一台R5：192.168.15.5 &#x2F;24 连接在R1右侧。</p><p>也就是说area0中存在了两个网段，而R1同时连接了这两个网段。</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/7c0e0882b85b466188554.png"></p><p>这次我们先直接查看LSDB表跟邻居表，以R1为视角：</p><blockquote><p>在R1上输入<strong>display ospf peer</strong> 检查邻居信息。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[R1]display ospf peer </span><br><span class="line"></span><br><span class="line"> OSPF Process 1 with Router ID 1.1.1.1</span><br><span class="line"> Neighbors </span><br><span class="line"></span><br><span class="line"> Area 0.0.0.0 interface 192.168.123.1(GigabitEthernet0/0/0)&#x27;s neighbors</span><br><span class="line"> Router ID: 2.2.2.2          Address: 192.168.123.2   </span><br><span class="line">   State: Full  Mode:Nbr is  Master  Priority: 1</span><br><span class="line">   DR: 192.168.123.3  BDR: 192.168.123.2  MTU: 0    </span><br><span class="line">   Dead timer due in 36  sec </span><br><span class="line">   Retrans timer interval: 5 </span><br><span class="line">   Neighbor is up for 00:09:26     </span><br><span class="line">   Authentication Sequence: [ 0 ] </span><br><span class="line"></span><br><span class="line"> Router ID: 3.3.3.3          Address: 192.168.123.3   </span><br><span class="line">   State: Full  Mode:Nbr is  Master  Priority: 1</span><br><span class="line">   DR: 192.168.123.3  BDR: 192.168.123.2  MTU: 0    </span><br><span class="line">   Dead timer due in 38  sec </span><br><span class="line">   Retrans timer interval: 0 </span><br><span class="line">   Neighbor is up for 00:09:30     </span><br><span class="line">   Authentication Sequence: [ 0 ] </span><br><span class="line"></span><br><span class="line"> Neighbors </span><br><span class="line"></span><br><span class="line"> Area 0.0.0.0 interface 192.168.15.1(GigabitEthernet0/0/2)&#x27;s neighbors</span><br><span class="line"> Router ID: 5.5.5.5          Address: 192.168.15.5    </span><br><span class="line">   State: Full  Mode:Nbr is  Master  Priority: 1</span><br><span class="line">   DR: 192.168.15.5  BDR: 192.168.15.1  MTU: 0    </span><br><span class="line">   Dead timer due in 37  sec </span><br><span class="line">   Retrans timer interval: 5 </span><br><span class="line">   Neighbor is up for 00:09:26     </span><br><span class="line">   Authentication Sequence: [ 0 ] </span><br></pre></td></tr></table></figure><p>可以看到R1邻居信息中分了两块【Neighbors 】：</p><ul><li>第一块里内容是R2与R3，其中DR: 192.168.123.3  BDR: 192.168.123.2。</li><li>第二块内容是R5，其中DR: 192.168.15.5  BDR: 192.168.15.1</li></ul><blockquote><p>查看type-2 LSA的命令为<strong>display ospf lsdb network</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[R1]display ospf lsdb network </span><br><span class="line"></span><br><span class="line"> OSPF Process 1 with Router ID 1.1.1.1</span><br><span class="line">         Area: 0.0.0.0</span><br><span class="line"> Link State Database </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Type      : Network</span><br><span class="line">  Ls id     : 192.168.123.3</span><br><span class="line">  Adv rtr   : 3.3.3.3  </span><br><span class="line">  Ls age    : 380 </span><br><span class="line">  Len       : 36 </span><br><span class="line">  Options   :  E  </span><br><span class="line">  seq#      : 80000004 </span><br><span class="line">  chksum    : 0x281f</span><br><span class="line">  Net mask  : 255.255.255.0</span><br><span class="line">  Priority  : Low</span><br><span class="line">     Attached Router    3.3.3.3</span><br><span class="line">     Attached Router    1.1.1.1</span><br><span class="line">     Attached Router    2.2.2.2</span><br><span class="line"></span><br><span class="line">  Type      : Network</span><br><span class="line">  Ls id     : 192.168.15.5</span><br><span class="line">  Adv rtr   : 5.5.5.5  </span><br><span class="line">  Ls age    : 370 </span><br><span class="line">  Len       : 32 </span><br><span class="line">  Options   :  E  </span><br><span class="line">  seq#      : 80000007 </span><br><span class="line">  chksum    : 0x3278</span><br><span class="line">  Net mask  : 255.255.255.0</span><br><span class="line">  Priority  : Low</span><br><span class="line">     Attached Router    5.5.5.5</span><br><span class="line">     Attached Router    1.1.1.1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为存在两个DR，所以有两条type-2 LSA。</p><p>以第一条为例：</p><ul><li><p>Ls id : 192.168.123.3 —— 描述的该网段的DR的ip地址。</p></li><li><p>Net mask : 255.255.255.0 —— 描述该网段的子网掩码，配合上一条的ip地址即可得到网段地址。</p></li><li><p>Attached Router    3.3.3.3</p><p>Attached Router    1.1.1.1</p><p>Attached Router    2.2.2.2 —— 该网段内的ospf路由器的router-id。</p></li></ul><p>得益于type-1与type-2 LSA在区域内泛洪，区域内的路由器LSDB表都是完全一致的，OSPF路由器就能够描绘一个区域内的完整拓扑，并发现各个网段，最终准确的计算出到达各个网段的最佳路径。</p><h2 id="type-3-LSA"><a href="#type-3-LSA" class="headerlink" title="type-3 LSA"></a>type-3 LSA</h2><p>type-1与type-2解决了区域内的路由器计算，而要实现区域间路由的传递，就必须借助type-3 LSA。</p><p>type-3 LSA是为了解决区域间的路由问题，那么自然是由处于区域间的ABR来产生。</p><h3 id="报文格式-2"><a href="#报文格式-2" class="headerlink" title="报文格式"></a>报文格式</h3><blockquote><p>不再用红框标注了，深色的为固定的LSA头部，浅色的为指定类型的LSA内容。</p><p>同样的，非必要不会在附上LSA的简述拓扑图，相信经过两个LSA的讲解，应该能理解怎么看LSDB表里LSA信息。</p></blockquote><p>type-3 LSA是对区域内的type-1与type-2进行汇总归纳的LSA，其报文格式如下：</p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/83715f493faccd333dbd6.png" style="zoom:80%;" /><p>在Type-3 LSA中，”<strong>链路状态ID</strong>”字段的值为区域间路由的<strong>目的网络地址</strong>，其他字段及其含义如下。</p><blockquote><ul><li>**网络掩码(Netmask)**：区域间路由的目的网络掩码。</li><li>**度量值(Metric)**：路由的 Cost。</li></ul></blockquote><h3 id="举例说明-2"><a href="#举例说明-2" class="headerlink" title="举例说明"></a>举例说明</h3><p>以R3为例，检查其LSDB中的type-3 LSA：</p><blockquote><p>命令：<strong>display ospf lsdb summary</strong> </p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">[R3]display ospf lsdb summary </span><br><span class="line"></span><br><span class="line"> OSPF Process 1 with Router ID 3.3.3.3</span><br><span class="line"> </span><br><span class="line">         Area: 0.0.0.0</span><br><span class="line"> Link State Database </span><br><span class="line"></span><br><span class="line">  Type      : Sum-Net</span><br><span class="line">  Ls id     : 192.168.34.0</span><br><span class="line">  Adv rtr   : 3.3.3.3  </span><br><span class="line">  Ls age    : 21 </span><br><span class="line">  Len       : 28 </span><br><span class="line">  Options   :  E  </span><br><span class="line">  seq#      : 80000001 </span><br><span class="line">  chksum    : 0xc9cb</span><br><span class="line">  Net mask  : 255.255.255.0</span><br><span class="line">  Tos 0  metric: 48</span><br><span class="line">  Priority  : Low</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">         Area: 0.0.0.1</span><br><span class="line"> Link State Database </span><br><span class="line"></span><br><span class="line">  Type      : Sum-Net</span><br><span class="line">  Ls id     : 192.168.123.0</span><br><span class="line">  Adv rtr   : 3.3.3.3  </span><br><span class="line">  Ls age    : 21 </span><br><span class="line">  Len       : 28 </span><br><span class="line">  Options   :  E  </span><br><span class="line">  seq#      : 80000001 </span><br><span class="line">  chksum    : 0x1b50</span><br><span class="line">  Net mask  : 255.255.255.0</span><br><span class="line">  Tos 0  metric: 1</span><br><span class="line">  Priority  : Low</span><br><span class="line"></span><br><span class="line">  Type      : Sum-Net</span><br><span class="line">  Ls id     : 192.168.15.0</span><br><span class="line">  Adv rtr   : 3.3.3.3  </span><br><span class="line">  Ls age    : 21 </span><br><span class="line">  Len       : 28 </span><br><span class="line">  Options   :  E  </span><br><span class="line">  seq#      : 80000001 </span><br><span class="line">  chksum    : 0xcd09</span><br><span class="line">  Net mask  : 255.255.255.0</span><br><span class="line">  Tos 0  metric: 2</span><br><span class="line">  Priority  : Low</span><br><span class="line"></span><br><span class="line">  Type      : Sum-Net</span><br><span class="line">  Ls id     : 192.168.2.0</span><br><span class="line">  Adv rtr   : 3.3.3.3  </span><br><span class="line">  Ls age    : 23 </span><br><span class="line">  Len       : 28 </span><br><span class="line">  Options   :  E  </span><br><span class="line">  seq#      : 80000001 </span><br><span class="line">  chksum    : 0x5d86</span><br><span class="line">  Net mask  : 255.255.255.0</span><br><span class="line">  Tos 0  metric: 2</span><br><span class="line">  Priority  : Low</span><br><span class="line"></span><br><span class="line">  Type      : Sum-Net</span><br><span class="line">  Ls id     : 192.168.1.0</span><br><span class="line">  Adv rtr   : 3.3.3.3  </span><br><span class="line">  Ls age    : 26 </span><br><span class="line">  Len       : 28 </span><br><span class="line">  Options   :  E  </span><br><span class="line">  seq#      : 80000001 </span><br><span class="line">  chksum    : 0x687c</span><br><span class="line">  Net mask  : 255.255.255.0</span><br><span class="line">  Tos 0  metric: 2</span><br><span class="line">  Priority  : Low</span><br></pre></td></tr></table></figure><p>总结下来，R3往area0发送了一条type-3 LSA，用于描述area1里 R3-R4所处的网段。</p><p>R3往area1发送了4条type-3 LSA，用于描述area0里的4个网段。</p><p>值得注意的是，R3在发布type-3 LSA时，会附加上自己到达该网段的cost值（表中的“Tos 0  metric”字段）。</p><p>例如到达192.168.34.0是48，到达192.168.123.0是1，到达其他三个网段是2（需要经过两条千兆链路，1+1&#x3D;2，交换机处不计算，因为对于ospf来说它感知不到经过了交换机以及经过了多少台交换机）</p><blockquote><p>虽然说是多条LSA，但我们回顾一下LSU的报文格式。一条LSU报文内可以包含多条LSA，所以实际不等于路由器真的发了多条数据包。</p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/627a02faee9f1cd93d917.png" style="zoom:80%;" /></blockquote><p>基于type-1、type-2、type-3 LSA，一个OSPF网络内所有的路由器就都可以互相访问了。（只要配置符合ospf的规则）</p><h3 id="type-3-LSA的防环机制"><a href="#type-3-LSA的防环机制" class="headerlink" title="type-3 LSA的防环机制"></a>type-3 LSA的防环机制</h3><p>type-3 LSA内的信息，我们可以提取为ABR的router-id、目标网段、目标网段的掩码、cost值。对于收到该LSA的路由器来说，它能明白的就是前往该目标网段的下一跳是router-id为多少的路由器。</p><p>这么一说，你可能发现了，这和RIP协议非常相似——将自己路由表内的路由信息发送给邻居，下一跳会设置为自己。</p><p>因此，使用type-3 LSA是存在与RIP相似的“环路”隐患。</p><p>为此，ospf“借鉴”了RIP的“水平分割”——ABR只能将自己所连接的区域内路由通告给area0，而不能将从其他区域学习到路由再通告给area0。</p><h2 id="type-4、type-5-LSA"><a href="#type-4、type-5-LSA" class="headerlink" title="type-4、type-5 LSA"></a>type-4、type-5 LSA</h2><p>我认为这两强相关的LSA放一起比较合适。</p><h3 id="以新拓扑分析描述"><a href="#以新拓扑分析描述" class="headerlink" title="以新拓扑分析描述"></a>以新拓扑分析描述</h3><p>让我们更新一下网络拓扑——让R4接入一个RIP网络中。(右上角)</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/a71783268130ad8709f5e.png"></p><p>显然，对于ospf网络中的路由器来说，它们并没有前往RIP网络的路由。</p><p>这时就需要R4将RIP的路由引入到ospf网络中，当我们在R4上执行引入路由的操作后，R4就认为自己是一台ASBR。</p><p>身为ASBR的R4会基于协议要求，会产生描述到达RIP网络的type-5 LSA。</p><p>该LSA经过路由器之间的LSU报文最终传遍ospf网络内的所有路由器，使得它们能知道前往RIP网络要经过R4。</p><p>但是对于area0区域的ospf路由器来说，它们仅拥有前往area1区域的type-3 LSA，而没有精准到达R4的LSA信息，因此它们还是无法路由到RIP网络。</p><p>对于R3来说，它与R4同属于area1，基于type-1 LSA，它清楚到达R4的路由。</p><p>因此ospf里规定了，同属一个区域的ABR（也就是R3），需要产生一条type-4 LSA，用于描述到达ASBR（也就是R4）的路由。</p><p>type-4 LSA会像type-5 LSA一样传遍所有路由器，结合起来，使其他路由器都能路由到RIP网络。</p><h3 id="type-5-LSA"><a href="#type-5-LSA" class="headerlink" title="type-5 LSA"></a>type-5 LSA</h3><p>接下来我们就实际验证一下，首先我们在R4上进行路由引入，并检查type-5 LSA：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[R4]ospf 1</span><br><span class="line">[R4-ospf-1]import-route rip 1</span><br><span class="line">[R4-ospf-1]display ospf lsdb ase</span><br><span class="line"></span><br><span class="line"> OSPF Process 1 with Router ID 4.4.4.4</span><br><span class="line"> Link State Database</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Type      : External</span><br><span class="line">  Ls id     : 192.168.78.0</span><br><span class="line">  Adv rtr   : 4.4.4.4  </span><br><span class="line">  Ls age    : 196 </span><br><span class="line">  Len       : 36 </span><br><span class="line">  Options   :  E  </span><br><span class="line">  seq#      : 80000001 </span><br><span class="line">  chksum    : 0x7791</span><br><span class="line">  Net mask  : 255.255.255.0 </span><br><span class="line">  TOS 0  Metric: 1 </span><br><span class="line">  E type    : 2</span><br><span class="line">  Forwarding Address : 0.0.0.0 </span><br><span class="line">  Tag       : 1 </span><br><span class="line">  Priority  : Low</span><br><span class="line"></span><br><span class="line">  Type      : External</span><br><span class="line">  Ls id     : 192.168.47.0</span><br><span class="line">  Adv rtr   : 4.4.4.4  </span><br><span class="line">  Ls age    : 196 </span><br><span class="line">  Len       : 36 </span><br><span class="line">  Options   :  E  </span><br><span class="line">  seq#      : 80000001 </span><br><span class="line">  chksum    : 0xcd5a</span><br><span class="line">  Net mask  : 255.255.255.0 </span><br><span class="line">  TOS 0  Metric: 1 </span><br><span class="line">  E type    : 2</span><br><span class="line">  Forwarding Address : 0.0.0.0 </span><br><span class="line">  Tag       : 1 </span><br><span class="line">  Priority  : Low</span><br></pre></td></tr></table></figure><p>RIP网络中192.168.78.0&#x2F;24与192.168.47.0&#x2F;24两个网段都描述出来了。</p><p>看的出来其报文格式应该就是：</p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/446418aceb0bc687f49fa.png" style="zoom:80%;" /><p>对于Type-5 LSA， <strong>“链路状态ID”</strong>字段的值是<strong>外部路由的目的网络地址</strong>。其他主要字段的描述如下。</p><blockquote><ul><li>网络掩码(Netmask)：外部路由的目的网络掩码。</li><li>E 位：用于表示该外部路由使用的度量值类型。OSPF 定义了两种外部路由度量值类型，分别是 Metric-Type-1 和 Metric-Type-2。值为0表示Metric-Type-1，1表示Metric-Type-2。关于这两种度量值类型的区别，本文将在后续小节中阐述。</li><li>度量值(Metric)：该外部路由的Cost。</li><li>转发地址(Forwarding Address， FA)：<strong>当 FA 为 0.0.0.0 时，则到达该外部网段的流量会被发往引入这条外部路由的ASBR</strong>(即LSA头部的通告路由器)。而如果FA不为0.0.0.0,则流量会被发往这个转发地址。</li><li>外部路由标记(External Route Tag)：这是一个只有外部路由才能够携带的标记，常被用于部署路由策略。</li></ul></blockquote><p>我们再抓个包看一下，都没直接抓过OSPF报文呢。这是在交换机处抓到的R3发送出来的OSPF报文：</p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/11125548e2d7a42510d1e.png" style="zoom: 50%;" /><p>这是一个OSPF报文，在这个OSPF报文中是LSU报文信息，LSU内包含了两条type-5 LSA。至于内容就不重复讲了。</p><h3 id="type-4-LSA"><a href="#type-4-LSA" class="headerlink" title="type-4 LSA"></a>type-4 LSA</h3><p>在type-5 LSA内是描述了外部路由，以及发现该外部路由的路由器的router-id。</p><p>对于R1来说，它并不知道4.4.4.4这个router-id是谁——指示router-id的LSA是type-1 LSA，而type-1 LSA是不能跨区域的。</p><p>我们也可以直接使用<strong>display ospf peer</strong>命令查看R1的邻居表，也是找不到4.4.4.4的。</p><p>因此需要有人去发布type-4 LSA来告知area0区域内的路由器4.4.4.4这个路由器在哪。</p><p>我们在R1上去检查下type-4 LSA：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[R1]display ospf lsdb asbr</span><br><span class="line"></span><br><span class="line"> OSPF Process 1 with Router ID 1.1.1.1</span><br><span class="line">         Area: 0.0.0.0</span><br><span class="line"> Link State Database </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Type      : Sum-Asbr</span><br><span class="line">  Ls id     : 4.4.4.4</span><br><span class="line">  Adv rtr   : 3.3.3.3  </span><br><span class="line">  Ls age    : 458 </span><br><span class="line">  Len       : 28 </span><br><span class="line">  Options   :  E  </span><br><span class="line">  seq#      : 80000001 </span><br><span class="line">  chksum    : 0x2ce3</span><br><span class="line">  Tos 0  metric: 48</span><br></pre></td></tr></table></figure><p>可以看到标识了4.4.4.4，以及发现者3.3.3.3。也就是说要去找4.4.4.4这个路由器，可以让3.3.3.3代劳。</p><p>我们也抓个包看看，这次我两个报文一起放出来，R3会发布两条OSPF报文，一条是通告type-5 LSA的，另一条是通告type-4 LSA的：</p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/2a2ed4493733fc78c71e6.png" style="zoom:50%;" /><p>实际上type-4 LSA的报文结构就是type-3 LSA的结构，只不过链路状态ID填写为ASBR的router-id，且子网掩码字段的值填为0。</p><h2 id="type-7-LSA"><a href="#type-7-LSA" class="headerlink" title="type-7 LSA"></a>type-7 LSA</h2><p>type-7 LSA是用于NSSA *(Not-So-Stubby Area，非完全末梢区域)*内的一种特殊LSA。</p><p>在stub区域内是禁止type-4与type-5 LSA的(包括自己本区域自主产生也是禁止的)。</p><p>如果想要仅拒绝其他区域传外部路由进入，但不妨碍自己本区域传外部路由出去，那么就可以配置该stub区域为NSSA。</p><p>在NSSA中，启用了type-7 LSA用于代替type -5 LSA。</p><p>也因此，作为代替品的type-7 LSA仅出现在NSSA中，该type-7 LSA在ABR处会被转化为type-5 LSA，再发布给其他区域。</p><p>同时，正因为是用于代替type-5 LSA的，所以type-7 LSA的报文格式与type-5 LSA一样，仅仅是链路类型从5改成了7。</p><h3 id="再更新一遍拓扑，介绍type-7-LSA的原理"><a href="#再更新一遍拓扑，介绍type-7-LSA的原理" class="headerlink" title="再更新一遍拓扑，介绍type-7 LSA的原理"></a>再更新一遍拓扑，介绍type-7 LSA的原理</h3><p>让我们最后一次修改一下拓扑——将RIP网络删除，改为R4下直连了一个网段192.168.4.0 &#x2F;24，同时将area1配置为NSSA。</p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/7d9ddc5bd5fa46ea0bb47.png" style="zoom: 50%;" /><p>NSSA的配置需要在待修改区域的所有路由器上进行，因此在R3与R4配置如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[R3]ospf 1</span><br><span class="line">[R3-ospf-1]area 1</span><br><span class="line">[R3-ospf-1-area-0.0.0.1]nssa</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[R4]ospf 1</span><br><span class="line">[R4-ospf-1]area 1</span><br><span class="line">[R4-ospf-1-area-0.0.0.1]nssa</span><br></pre></td></tr></table></figure><p>现在，让我们在R4上配置引入外部路由（此处为直连路由）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[R4-ospf-1-area-0.0.0.1]quit </span><br><span class="line">[R4-ospf-1]import-route direct </span><br></pre></td></tr></table></figure><blockquote><p>区域视图下是无法引入路由的，要退回到ospf进程视图下。</p></blockquote><p>这时让我们看下刚刚在area1的串口链路上抓到的包：</p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/684bcf3a3125614f1c711.png" style="zoom: 50%;" /><blockquote><p>LSA类型为7，链路状态ID为引入的192.168.4.0&#x2F;24网段。（眼尖的会看到LSA数量为3，只是因为直接导入了直连路由，所以包括192.168.34.0&#x2F;24也引入进去了）</p></blockquote><p>再看一下R3发布到area0的LSA：</p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/b41e61b5427f78b40bdc6.png" style="zoom:50%;" /><blockquote><p>LSA类型为3，网段依旧是192.168.4.0&#x2F;24，不过通告路由器改为了3.3.3.3。</p></blockquote><h1 id="基础配置命令与解决方案"><a href="#基础配置命令与解决方案" class="headerlink" title="基础配置命令与解决方案"></a>基础配置命令与解决方案</h1><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><h3 id="启用OSPF"><a href="#启用OSPF" class="headerlink" title="启用OSPF"></a>启用OSPF</h3><ol><li><p>执行命令<strong>system-view</strong>，进入系统视图。</p></li><li><p>执行命令<strong>ospf</strong> [ <em>process-id</em> | <strong>router-id</strong> <em>router-id</em> ] ，创建并进入OSPF进程视图。</p><p>第一个可选参数为进程id，默认为1。该进程id仅作用于本地，也就是说两台配置进同一个ospf网络的路由器可以进程名不一样。</p><p>第二个可选参数为手动配置router-id，默认使用本地上配置的最大的ip地址。手动配置Router ID时，必须保证任意两台路由器的router-id不相同。<strong>router-id也可以在创建ospf进程之前配置。</strong></p></li><li><p>执行命令<strong>area</strong> <em>area-id</em>，进入OSPF区域视图。</p></li><li><p>执行命令<strong>network</strong> <em>ip-address</em> <em>wildcard-mask</em>，在OSPF区域中配置包含的网段，属于该网段的接口会自动启用OSPF功能。第二个参数配置的为通配符，而不是子网掩码。</p><p>通配符掩码中，0表示要检查的位，1表示不需要检查的位。如果不理解，可以当作是“反掩码”，比如通配符的0.0.0.255可以理解位子网掩码的255.255.255.0。</p><p>不过严谨来说，它并不是直接指示网络位与主机位的。举个例子，通配符可以写成0.0.0.254，这个通配符不仅表示了&#x2F;24的子网，还可以筛选单数或者双数。（如果哪天发现了ip地址双数的能上网，单数的上不了网，记得去检查是不是哪里的通配符打错成254了）</p><p>”宣告“也只是指定设备上的什么接口开启ospf功能加入该进程该区域（接口的ip地址符合宣告的规则）。</p><p>如果计划宣告的接口不多，其实我们可以直接以 <em>接口的ip地址</em> + <em>通配符0.0.0.0</em> 来直接指定单个接口。</p><blockquote><p>通配符0.0.0.0即表示严格匹配前者，而前者填写为接口的ip地址，即为直接指定该接口。</p></blockquote></li></ol><h3 id="引入外部路由"><a href="#引入外部路由" class="headerlink" title="引入外部路由"></a>引入外部路由</h3><ol><li>执行命令<strong>system-view</strong>，进入系统视图。</li><li>执行命令<strong>ospf</strong>，进入OSPF进程视图。</li><li>执行命令<strong>import-route</strong> { <strong>bgp</strong> [ <strong>permit-ibgp</strong> ] | <strong>direct</strong> | <strong>unr</strong> | <strong>rip</strong> [ <em>process-id-rip</em> ] | <strong>static</strong> | <strong>isis</strong> [ <em>process-id-isis</em> ] | <strong>ospf</strong> [ <em>process-id-ospf</em> ] } [ <strong>cost</strong> <em>cost</em> | <strong>type</strong> <em>type</em> | <strong>tag</strong> <em>tag</em> | <strong>route-policy</strong> <em>route-policy-name</em> ]，引入其它协议的路由信息。<ul><li>[ <strong>cost</strong> <em>cost</em> | <strong>type</strong> <em>type</em> | <strong>tag</strong> <em>tag</em> | <strong>route-policy</strong> <em>route-policy-name</em> ] 这一段是可选对引入的外部路由进行一些自定义——cost值，类型，标记，路由策略。</li></ul></li></ol><h3 id="检查配置"><a href="#检查配置" class="headerlink" title="检查配置"></a>检查配置</h3><ul><li>在任意视图下执行<strong>display ospf</strong> [ <em>process-id</em> ] <strong>peer</strong>命令，查看指定OSPF进程的邻居信息。</li><li>在任意视图下执行<strong>display ospf</strong> [ <em>process-id</em> ] <strong>interface</strong>命令，查看指定OSPF进程的接口信息。</li><li>在任意视图下执行<strong>display ospf</strong> [ <em>process-id</em> ] <strong>routing</strong>命令，查看指定OSPF进程的路由表信息。</li><li>在任意视图下执行<strong>display ospf</strong> [ <em>process-id</em> ] <strong>lsdb</strong>命令，查看指定OSPF进程的LSDB信息。</li></ul><h2 id="路由汇总与默认路由"><a href="#路由汇总与默认路由" class="headerlink" title="路由汇总与默认路由"></a>路由汇总与默认路由</h2><h3 id="路由汇总"><a href="#路由汇总" class="headerlink" title="路由汇总"></a>路由汇总</h3><p>ABR向其它区域发送路由信息时，以网段为单位生成Type3 LSA。</p><p>当区域中存在连续的网段（具有相同前缀的路由信息）时，可以通过<strong>abr-summary</strong>命令将这些网段聚合成一个网段。</p><p>ABR<strong>向其他区域只发送一条聚合后的LSA</strong>（对于自己本身依旧保持原有的LSA），所有指定的聚合网段范围的LSA将不会再被单独发送。</p><p>从而有效减少路由表中的条目，减小对系统资源的占用，不影响系统的性能。</p><ul><li><p>配置ABR路由聚合</p><ol><li>执行命令<strong>system-view</strong>，进入系统视图。</li><li>执行命令<strong>ospf</strong> [ <em>process-id</em> ]，进入OSPF进程视图。</li><li>执行命令<strong>area</strong> <em>area-id</em>，进入OSPF区域视图。</li><li>执行命令<strong>abr-summary</strong> <em>ip-address</em> <em>mask</em>  [ <strong>cost</strong> { <em>cost</em> | <strong>inherit-minimum</strong> }  ] ，配置OSPF的ABR路由聚合。</li></ol></li><li><p>配置ASBR路由聚合</p><ol><li>执行命令<strong>system-view</strong>，进入系统视图。</li><li>执行命令<strong>ospf</strong> [ <em>process-id</em> ]，进入OSPF进程视图。</li><li>执行命令<strong>asbr-summary</strong> <em>ip-address</em> <em>mask</em> [ <strong>cost</strong> <em>cost</em> |  <strong>tag</strong> <em>tag</em>  ] ，配置OSPF的ASBR路由聚合。</li></ol></li></ul><h3 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h3><p>为了减少路由表的容量，还可以配置引入默认路由，保证网络的高可用性。</p><ul><li><p>配置OSPF将默认路由通告到OSPF路由区域</p><ol><li><p>执行命令<strong>system-view</strong>，进入系统视图。</p></li><li><p>执行命令<strong>ospf</strong> [ <em>process-id</em> ]，进入OSPF进程视图。</p></li><li><p>执行命令<strong>default-route-advertise</strong> [ [ <strong>always</strong> | <strong>permit-calculate-other</strong> ] | <strong>cost</strong> <em>cost</em> | <strong>type</strong> <em>type</em> | <strong>route-policy</strong> <em>route-policy-name</em> [ <strong>match-any</strong> ] ] ，将默认路由通告到OSPF路由区域。</p><p><strong>always</strong>表示无论本机是否存在激活的非本OSPF进程的默认路由，都会产生并发布一个描述默认路由的LSA。</p><p><strong>permit-calculate-other</strong>表示在发布默认路由后，仍允许计算其他路由器发布的默认路由。</p></li></ol></li></ul><h2 id="虚链路（Virtual-link）"><a href="#虚链路（Virtual-link）" class="headerlink" title="虚链路（Virtual link）"></a>虚链路（Virtual link）</h2><p>OSPF里规定了所有区域都必须与骨干区域area0相连，否则LSA的泛洪就会出现问题，非直连区域会成为“孤岛”。</p><p>一般来说，我们都是要区域重新划分，保证区域直连area0。</p><p>但现网中，有的时候条件并不允许，无法重新规划为直连area0。</p><p>这时就可以考虑一种临时方案——虚链路。</p><p>虚链路是指在逻辑上虚拟出一条链路，使得该链路两台的设备能直接通信，直接尝试构建邻接关系。</p><p>而虚链路本身是承载在先有物理链路上的，我们可以理解为套娃、套壳。</p><p>使用虚链路让区域内一台路由器“直连”到area0里，该路由器则作为ABR负责该区域的LSA汇总。</p><p><strong>操作步骤</strong></p><ol><li><p>执行命令<strong>system-view</strong>，进入系统视图。</p></li><li><p>执行命令<strong>ospf</strong> [ <em>process-id</em> ]，进入OSPF进程视图。</p></li><li><p>执行命令<strong>area</strong> <em>area-id</em>，进入OSPF区域视图。</p></li><li><p>执行命令<strong>vlink-peer</strong> <em>router-id</em> [ <strong>smart-discover</strong> | <strong>hello</strong> <em>hello-interval</em> | <strong>retransmit</strong> <em>retransmit-interval</em> | <strong>trans-delay</strong> <em>trans-delay-interval</em> | <strong>dead</strong> <em>dead-interval</em> | [ <strong>simple</strong> [ <strong>plain</strong> <em>plain-text</em> | [ <strong>cipher</strong> ] <em>cipher-text</em> ] | { <strong>md5</strong> | <strong>hmac-md5</strong> | <strong>hmac-sha256</strong> } [ <em>key-id</em> { <strong>plain</strong> <em>plain-text</em> | [ <strong>cipher</strong> ] <em>cipher-text</em> } ] | <strong>authentication-null</strong> | <strong>keychain</strong> <em>keychain-name</em> ] ] ，创建到达指定路由器的虚连接。</p><p><strong>在另一端的路由器上也需要配置此命令。</strong></p></li></ol><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="OSPF邻居建立不起来？"><a href="#OSPF邻居建立不起来？" class="headerlink" title="OSPF邻居建立不起来？"></a>OSPF邻居建立不起来？</h2><p>以下各项的答案为“是”，才是正常的。</p><blockquote><p>实际本质就是两端的hello报文能互相发送给对方，并且hello报文内信息除了标识router-id要不同以外，其他的信息需要一样。</p></blockquote><ol><li><p><strong>检查邻居两端的接口物理和协议状态是否UP，状态是否稳定，接口是否不丢包，两边互ping大包是否能通。</strong></p><blockquote><p>若物理接口不Up或是不稳定（有振荡现象），请排查物理链路和链路层协议，确保物理和协议状态都是Up，并且接口无错误计数。</p><p>可以通过ping测试，长ping测试是否存在丢包现象，ping大包（1500字节以上）测试是否存在大包不通的现象。</p></blockquote></li><li><p><strong>检查链路两端OSPF进程的Router ID是否唯一。</strong></p><blockquote><p>分别在链路两端的设备上执行命令<strong>display ospf</strong> [ <em>process-id</em> ] <strong>brief</strong>，查看OSPF进程的Router ID。</p><p>RouterID尽量保证全网唯一，否则有可能邻居不能正常建立、路由信息不正确的问题。建议在设备上单独为每个OSPF进程配置全网唯一的Router ID。</p><p>如果链路两端OSPF进程的Router ID冲突，请在系统视图下执行命令<strong>ospf</strong> [ <em>process-id</em> ] <strong>router-id</strong> <em>router-id</em>，修改OSPF进程的Router ID以保证不冲突。</p><p>修改OSPF进程的Router ID之后，必须在用户视图下执行命令<strong>reset ospf</strong>[ <em>process-id</em> ] <strong>process</strong>重启进程后，新配置的Router ID才会生效。</p></blockquote></li><li><p><strong>检查链路两端OSPF区域ID是否一致。</strong></p><blockquote><p>分别在链路两端的设备上执行命令<strong>display ospf</strong> [ <em>process-id</em> ] <strong>brief</strong>，查看OSPF的区域ID。</p><p>如果链路两端的OSPF区域ID不一致，请在OSPF视图下执行命令<strong>area</strong> <em>area-id</em>，修改OSPF区域ID以保证一致。</p></blockquote></li><li><p><strong>检查链接两端OSPF接口的网络类型是否一致。</strong></p><blockquote><p>分别在链路两端的设备上执行命令<strong>display ospf</strong> [ <em>process-id</em> ] <strong>interface</strong>，查看OSPF接口的接口类型。</p><p>一般情况下，链路两端的OSPF接口的网络类型必须一致，否则双方不能正常建立起OSPF邻居关系。</p><ul><li>当链路两端的OSPF接口的网络类型一端是广播网（以太网）而另一端是P2P时，双方仍可以正常的建立起邻居关系，但互相学不到路由信息。</li><li>当链路两端的OSPF接口的网络类型一端是P2MP而另一端是P2P时，双方仍可以正常的建立起邻居关系，但互相学不到路由信息。为了相互学到路由信息，此时需要在链路两端的OSPF接口上配置相同的Hello报文发送间隔和邻居失效时间。</li></ul><p>如果OSPF接口的网络类型不一致，请在运行OSPF协议的接口视图下执行命令<strong>ospf network-type</strong> { <strong>broadcast</strong> | <strong>nbma</strong> | <strong>p2mp</strong> | <strong>p2p</strong> }，修改OSPF接口的网络类型以保证一致。</p><p>如果链路两端OSPF接口的网络类型都是NBMA，则必须在OSPF视图下执行命令<strong>peer</strong> <em>ip-address</em> [ <strong>dr-priority</strong> <em>priority</em> ]，配置NBMA网络的OSPF邻居。</p></blockquote></li><li><p><strong>检查链路两端OSPF接口的IP地址的掩码是否一致。</strong></p><blockquote><p>分别在链路两端的设备上执行命令<strong>display current-configuration</strong> <strong>interface</strong> <em>interface-type</em> <em>interface-number</em>，查看OSPF接口的IP地址。</p><p>一般情况下，链路两端的OSPF接口的IP地址的掩码必须一致，否则双方不能正常建立OSPF邻居关系。</p><p>但在P2MP网络中，可以通过在运行OSPF协议的接口视图下配置命令<strong>ospf p2mp-mask-ignore</strong>来使设备忽略对网络掩码的检查，从而正常建立OSPF邻居关系。</p><p>如果OSPF接口的IP地址的掩码不一致，请在运行OSPF协议的接口视图下执行命令<strong>ip address</strong> <em>ip-address</em> { <em>mask</em> | <em>mask-length</em> }，修改OSPF接口的IP地址以保证掩码一致。</p></blockquote></li><li><p><strong>检查链路两端OSPF接口的IP地址所在网段是否包含在区域内配置的network内。</strong></p><blockquote><p>也就是检查接口是否激活了OSPF。</p><p>分别在链路两端的设备上执行命令<strong>display current-configuration</strong> <strong>interface</strong> <em>interface-type</em> <em>interface-number</em>，查看OSPF接口的IP地址；执行命令<strong>display current-configuration</strong> <strong>configuration</strong> <strong>ospf</strong>，查看OSPF进程的配置。</p><p>满足下面两个条件，OSPF协议才能在接口上运行：</p><ul><li>接口的IP地址掩码长度≥<strong>network</strong>命令中的掩码长度。OSPF使用反掩码，例如0.0.0.255表示掩码长度24位。</li><li>接口的主IP地址必须在<strong>network</strong>命令指定的网段范围之内。</li></ul><p>如果检查发现接口IP地址与配置的<strong>network</strong>不满足上述条件，请在运行OSPF协议的接口视图下执行命令<strong>ip address</strong> <em>ip-address</em> { <em>mask</em> | <em>mask-length</em> }，修改接口的IP地址；或者在OSPF进程对应的区域视图下执行命令<strong>network</strong>，修改配置的网段，保证满足上述条件。</p></blockquote></li><li><p><strong>检查链路两端OSPF接口的DR优先级是否非零。</strong></p><blockquote><p>分别在链路两端的设备上执行命令<strong>display ospf</strong> [ <em>process-id</em> ] <strong>interface</strong>，查看OSPF接口的DR优先级。</p><p>对于广播和NBMA类型网络，链路中至少要有一个OSPF接口的DR优先级不为0，这样才能正常选举出DR。否则两边的邻居状态只能达到<strong>2-Way</strong>。</p><p>如果链路两端OSPF接口的DR优先级都为0，请在运行OSPF协议的接口视图下执行命令<strong>ospf dr-priority</strong> <em>priority</em>，修改OSPF接口的DR优先级以保证至少有一个接口的DR优先级不为0。</p></blockquote></li></ol><h2 id="报文认证"><a href="#报文认证" class="headerlink" title="报文认证"></a>报文认证</h2><p>为了避免有攻击者通过接入非法路由器并启用OSPF，向我方OSPF网络中注入大量无用的LSA，可以在OSPF中配置报文认证。</p><p>OSPF 支持三种类型的认证方式，分别是空认证（Null Authentication）、简单口令认证（Simple Password）、密文认证（Ctyptograhpic Authentication），这三种认 证方式对应的“认证类型”字段值分别为0、1和2。</p><p><strong>空认证</strong>：</p><ul><li>空认证即不做认证，这是OSPF接口的默认设置。</li></ul><p><strong>简单口令认证</strong>：</p><ul><li><p>简单口令认证又称明文认证，OSPF报文的认证数据字段中会填写为配置的明文口令（密码），接口收到该OSPF报文就会去检查包含的口令是否正确。</p><p>但因为此种认证是采用明文的方式，存在被截获口令的隐患，并不安全。</p></li></ul><p><strong>密文认证</strong>：</p><ul><li>密文认证是对口令进行了加密，报文中传输的是加密后的口令。（虽然加密对安全性没有太多的帮助，依旧可以截获并使用报文中的口令，只是无法得知加密前的口令是什么）</li><li>密文认证还增加了密码序列号这一字段以预防重放攻击（截获正常报文，重复发送）</li></ul><blockquote><p>命令不作介绍了，有兴趣可以查看文档，在模拟器上测试一轮。</p></blockquote><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>OSPF还有其他非常多的配置命令，碍于篇幅，以及一般都不会使用的原因，本文不做介绍。</p><p>感兴趣的可以查看产品手册参考可配置命令，其中大多数都是进行优先的命令。<del>但实际现网中，能通就行，真有次优路由也无妨</del></p><p>另外，本文弱化了网络类型的概念，OSPF可以在多种网络类型中使用，但个人认为其他网络类型目前使用场景太少了，现在是以太网一统天下的时代，因此本文是默认为以太网环境下进行介绍的。</p><p>此外，本文还是默认为ipv4环境，使用的是OSPF Version 2。OSPF还有一个OSPF Version 3，是针对ipv6场景的，有机会的话我们再介绍。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【科普】（软件向）网络运维工具的介绍与使用技巧</title>
      <link href="/2024/06/19/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%EF%BC%88%E8%BD%AF%E4%BB%B6%E5%90%91%EF%BC%89%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2024/06/19/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%EF%BC%88%E8%BD%AF%E4%BB%B6%E5%90%91%EF%BC%89%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本系列面向基础日常的网络故障，不涉及运营商那一块的故障，适合广大政企&#x2F;高校的网络运维人员。</p><p>工欲善其事，必先利其器。</p><p>本篇会介绍处理网络的相关基础命令与软件。</p><blockquote><p>起个大纲挖个坑，之后慢慢填</p></blockquote><h1 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h1><h2 id="ipconfig"><a href="#ipconfig" class="headerlink" title="ipconfig"></a>ipconfig</h2><h3 id="ipconfig-1"><a href="#ipconfig-1" class="headerlink" title="ipconfig"></a>ipconfig</h3><h3 id="ipconfig-all"><a href="#ipconfig-all" class="headerlink" title="ipconfig &#x2F;all"></a>ipconfig &#x2F;all</h3><h3 id="ipconfig-renew"><a href="#ipconfig-renew" class="headerlink" title="ipconfig &#x2F;renew"></a>ipconfig &#x2F;renew</h3><h3 id="ipconfig-flushdns"><a href="#ipconfig-flushdns" class="headerlink" title="ipconfig &#x2F;flushdns"></a>ipconfig &#x2F;flushdns</h3><h2 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h2><h3 id="t"><a href="#t" class="headerlink" title="-t"></a>-t</h3><h3 id="n"><a href="#n" class="headerlink" title="-n"></a>-n</h3><h3 id="l"><a href="#l" class="headerlink" title="-l"></a>-l</h3><h3 id="批量ping"><a href="#批量ping" class="headerlink" title="批量ping"></a>批量ping</h3><h2 id="tracert命令"><a href="#tracert命令" class="headerlink" title="tracert命令"></a>tracert命令</h2><h2 id="arp命令"><a href="#arp命令" class="headerlink" title="arp命令"></a>arp命令</h2><h3 id="a"><a href="#a" class="headerlink" title="-a"></a>-a</h3><h3 id="d"><a href="#d" class="headerlink" title="-d"></a>-d</h3><h3 id="绑定ip地址与mac地址"><a href="#绑定ip地址与mac地址" class="headerlink" title="绑定ip地址与mac地址"></a>绑定ip地址与mac地址</h3><h2 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h2><h3 id="e"><a href="#e" class="headerlink" title="-e"></a>-e</h3><h3 id="s"><a href="#s" class="headerlink" title="-s"></a>-s</h3><h3 id="r"><a href="#r" class="headerlink" title="-r"></a>-r</h3><h2 id="telnet命令"><a href="#telnet命令" class="headerlink" title="telnet命令"></a>telnet命令</h2><h2 id="第三方命令——tcping命令"><a href="#第三方命令——tcping命令" class="headerlink" title="第三方命令——tcping命令"></a>第三方命令——tcping命令</h2><h1 id="图形化界面工具"><a href="#图形化界面工具" class="headerlink" title="图形化界面工具"></a>图形化界面工具</h1><h2 id="网络适配器"><a href="#网络适配器" class="headerlink" title="网络适配器"></a>网络适配器</h2><h3 id="查看网络信息"><a href="#查看网络信息" class="headerlink" title="查看网络信息"></a>查看网络信息</h3><h3 id="修改网络ip地址、子网掩码、网关、dns"><a href="#修改网络ip地址、子网掩码、网关、dns" class="headerlink" title="修改网络ip地址、子网掩码、网关、dns"></a>修改网络ip地址、子网掩码、网关、dns</h3><h3 id="修改mac地址"><a href="#修改mac地址" class="headerlink" title="修改mac地址"></a>修改mac地址</h3><h3 id="修改跃点数（网络优先级）"><a href="#修改跃点数（网络优先级）" class="headerlink" title="修改跃点数（网络优先级）"></a>修改跃点数（网络优先级）</h3><h2 id="资源监视器"><a href="#资源监视器" class="headerlink" title="资源监视器"></a>资源监视器</h2><h3 id="打开方式"><a href="#打开方式" class="headerlink" title="打开方式"></a>打开方式</h3><h3 id="界面介绍"><a href="#界面介绍" class="headerlink" title="界面介绍"></a>界面介绍</h3><h1 id="第三方工具"><a href="#第三方工具" class="headerlink" title="第三方工具"></a>第三方工具</h1><p>一般我很少用第三方工具，这是个人之前在银行工作养成的习惯。</p><p>能用系统自带的就用系统自带的，无论你多么确定使用的第三方工具多么安全，但风险总归不是0，不适合在银行生产网内使用。</p><p>这类工具我都只是装在自己的笔记本中，不会在工作电脑以及用户电脑上安装。</p><p>这部分内容不会展开太多，请将本文作为目录参考，具体还需要读者自行搜索学习使用方法。</p><h2 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h2><h3 id="wires-hark"><a href="#wires-hark" class="headerlink" title="wires hark"></a>wires hark</h3><h3 id="科来网络分析系统"><a href="#科来网络分析系统" class="headerlink" title="科来网络分析系统"></a>科来网络分析系统</h3><h2 id="ip扫描工具"><a href="#ip扫描工具" class="headerlink" title="ip扫描工具"></a>ip扫描工具</h2><h3 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h3><h3 id="Angry-IP-Scanner"><a href="#Angry-IP-Scanner" class="headerlink" title="Angry IP Scanner"></a>Angry IP Scanner</h3><h2 id="设备扫描工具"><a href="#设备扫描工具" class="headerlink" title="设备扫描工具"></a>设备扫描工具</h2><p>具体不做介绍，一般都看工作需求，在对应设备厂家官网下载厂家的设备扫描工具。</p><p>比如摄像头厂家海康和大华，在官网都能找到工具下载。</p><h2 id="串口调试工具"><a href="#串口调试工具" class="headerlink" title="串口调试工具"></a>串口调试工具</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【科普】（硬件向）网络运维工具的介绍与使用技巧</title>
      <link href="/2024/06/17/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%EF%BC%88%E7%A1%AC%E4%BB%B6%E5%90%91%EF%BC%89%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2024/06/17/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%EF%BC%88%E7%A1%AC%E4%BB%B6%E5%90%91%EF%BC%89%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本系列面向基础日常的网络故障，不涉及运营商那一块的故障，适合广大政企&#x2F;高校的网络运维人员。</p><p>工欲善其事，必先利其器。</p><p>本篇会介绍处理网络的相关基础工具与使用技巧（硬件向）。</p><p>后续会的第二章节介绍常见的网络故障成因，第三章节会介绍遇到网络报障时，如何快速高效的判断故障点。</p><h1 id="水晶头与网线钳"><a href="#水晶头与网线钳" class="headerlink" title="水晶头与网线钳"></a>水晶头与网线钳</h1><p>水晶头是网线末端的接头，网线钳是将水晶头固定在网线上的工具。</p><h2 id="水晶头的类型"><a href="#水晶头的类型" class="headerlink" title="水晶头的类型"></a>水晶头的类型</h2><h3 id="网络水晶头"><a href="#网络水晶头" class="headerlink" title="网络水晶头"></a>网络水晶头</h3><p>一般我们会接触到就是五类线与六类线，其最明显的区别就是<strong>五类线线芯细</strong>、没有软骨；<strong>六类线线芯粗硬、中心有十字白色软骨</strong>。</p><p>长距离上六类线肯定是优于五类线的，尤其是因为带有中心软骨，提供了很好的”耐操性“。</p><p>但是<strong>短距离（1-2米），五类线与六类线实际没有多少差距</strong>，包括带宽（最大传输速度）也是没有什么差距的。</p><blockquote><p>我平时携带在包里的成品线是五类线（没有软骨更便携更好盘起来收纳）。</p><p>有次到一个项目，因为需要临时搭个小局域网，我就一起掏了几根网线出来，没想到我的五类成品线被人吐槽“什么垃圾线，这么细，传不快不要”。（问题是你这拿的TP家塑料外壳的那款千兆交换机，这小局域网的网速瓶颈是它不是线）。</p><p>科普一点：成品线是机器打的，出厂检测过的，其电气性能是优于人工手打的平均水平。</p></blockquote><p>为什么在讲五类线与六类线呢，那是因为他们搭配的水晶头有所不同。</p><p>因为六类线的线芯比五类的粗，如果与五类线一样保持齐平，那么其宽度也就五类线大。</p><p>而我们设备的网口大小是固定，因此只能让六类线的线芯保持一上一下错落排列。</p><p>上一张图对比一下：</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/3d797fa6c40d9297e8026.png" alt="水晶头对比"></p><p>如果使用五类线搭配六类水晶头，洞大线细，可能导致金属片下压后没有很充分的接触到线芯内芯，进而导致虚接、有概率出现接触不良的情况（但总体来说，这种搭配出现影响网络的情况很少）</p><p>而如果使用六类线搭配五类水晶头，洞小线粗，这水晶头打的很费手，线芯非常难插到底，如果插不到底，那就会导致接触不良甚至断芯。</p><blockquote><p> 关于带屏蔽网线与带屏蔽水晶头，甚至说七类线，很抱歉，我手头上没有，无法展示，所以不做介绍。（视频网站上有很多相关的这类水晶头制作教程，有需要的可自行观看）</p><p>请记住，如果哪天遇上了带屏蔽层的网线（外侧一层金属薄膜皮），那么水晶头也要用带屏蔽水晶头，其外壳是金属的。</p></blockquote><h3 id="电话水晶头"><a href="#电话水晶头" class="headerlink" title="电话水晶头"></a>电话水晶头</h3><p><strong>一般电话线只采用两芯进行通信（水晶头中间两芯）</strong>，且<strong>电话不分线序</strong>，没有说一个是正极另一个是负极。</p><p>电话水晶头是比网络水晶头小一圈的一种水晶头，可以接入四条线芯，但由于电话通信一般只需要两芯，所以市面上有大量的两芯电话线与两芯水晶头。</p><p>电话线、电话水晶头、网络水晶头的合影：</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/5f9040fb7caf1b20fb8eb.png"></p><p><strong>电话水晶头中间这两芯的位置是正好对应网络水晶头中间两芯的位置的（4、5芯）</strong>。这是重点，之后要考。</p><blockquote><p>一般这种规格大小的水晶头可以叫做4p或者6p。而网线水晶头就叫做8p。</p></blockquote><h2 id="网线钳的功能与推荐"><a href="#网线钳的功能与推荐" class="headerlink" title="网线钳的功能与推荐"></a>网线钳的功能与推荐</h2><p>网线钳的样式有很多，但万变不离其宗，我们截取三种款式的网线钳看一下。</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/8e0a2536741db4b16af19.png" alt="三种网线钳"></p><p>这三种都是比较常见的款式，简单来说都是带有剥线、剪线、压水晶头三个功能。</p><p>剥线、剪线没什么好说的，说实话，我是不喜欢用网线钳的这两个功能，甚至想过把刀片拆了，以免哪天割伤自己或者划伤包里的什么线。</p><p>压水晶头这个功能：</p><p>左侧黄色网线钳是左右夹压的，虽然是使用了连杆来保证角度垂直，但是微观上，他还是处于一种先上后下的夹击式。如果使用久了，连杆不牢固，角度无法保持，就<em>有可能导致下方的线芯夹不到位</em>。（此事在<a href="https://www.bilibili.com/video/BV1vY411M7yY">小胡视频</a>中亦有记载）</p><p>中间的网线钳是垂直式直上直下的压接，这种就很稳固，而且是网线钳的边框做限位，完全杜绝了使用久了角度偏移的情况。</p><p>第三种是现在很流行的款式，这种也是垂直压接的，不过它<em>直上直下的是金属小铁片</em>，不是第二款那种整个大部件一起动的。（我不敢说是哪种方式更好）。这种款式是带切换的，可以在常规的五类&#x2F;六类水晶头与七类水晶头之间切换。这两类水晶头的区别的就是线径导致的上下大小增大，所以<em>压接深度浅，因此通过螺丝卡位限制小铁片的长度来达到切换的作用</em>。也是因为带有这个切换功能，这种新款式才流行起来。</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/c586f10d4cd8b0766e8f8.png"></p><p>要推荐的，就是第二款与第三款。但私心主观来说，我推荐第二款，使用起来的手感比第三款好。我个人还认为第二款会比第三款耐用。（这是单纯的主观评价）</p><blockquote><p>我刚入行时买的第一把就是左侧那把。。肉疼，还丢了。</p></blockquote><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/206da0ce1b0d55621801f.png" alt="呜呜"></p><h2 id="水晶头的安装原理"><a href="#水晶头的安装原理" class="headerlink" title="水晶头的安装原理"></a>水晶头的安装原理</h2><p>一颗未使用的水晶头如下图所示，其前端的金属铜片是突出的，金属铜片的末端是相互交错的三岔。</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/d4784f4ee553d335cfba8.png" alt="水晶头近照"></p><p>我们压接水晶头就是将网线线芯塞入槽内，将这8个铜片压进线芯里，三岔尖头会刺破线皮并接触线芯内的铜丝，达到电路连通。</p><p>演示一下：</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/038d4e4f78a1a59b420a4.png" alt="压接水晶头"></p><p>新手小白第一次压接水晶头可能会分不清插入网线钳的正方面。请记住，网线钳带齿状的一侧对准水晶头的金属铜片。</p><p>铜片被压入水晶头内，这就算压接完毕了，个人推荐压接动作重复两次（也就是手柄夹握两次），多压几次坏不了，但是只压一次可能导致没压好，接触不良。</p><p>压接完毕后，铜片会刺入到线槽的根部，同时可以注意到，靠尾部的地方，有块塑料被顶出来了。这块塑料就是用来卡住完整的网线的（包含最外层的线皮）</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/eb08434b6c5d21893df23.png"></p><blockquote><p>注意，压接之后金属铜片也就不突出来了，这才是网线端水晶头的常规样式；因此压接后的水晶头可以插入网口，而未压接的水晶头无法插入网口。</p><p>如果你要将水晶头作为一个网口防尘塞，请将网线先进行一次压接。</p></blockquote><h2 id="实战水晶头的压接"><a href="#实战水晶头的压接" class="headerlink" title="实战水晶头的压接"></a>实战水晶头的压接</h2><h3 id="网线线序与实操"><a href="#网线线序与实操" class="headerlink" title="网线线序与实操"></a>网线线序与实操</h3><p>行业内标准的线序有两种：568A与568B。当前我们<strong>只需要记忆568B</strong>即可，现在的网络设备都<strong>支持自动翻转，不需要再制作“交叉线”了</strong>。</p><p>568B标准的线序为 <em>白橙、橙；白绿、蓝；白蓝、绿；白棕、棕</em>。</p><p>一图流，单网线钳打水晶头（六类线）</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/df24bbcf91b1d458283e1.png" alt="打水晶头过程"></p><p>注意事项：</p><ol><li>使用网线钳对网线线皮进行环切一定要估好深浅，<strong>不要把内芯的线皮也刮了</strong>，甚至把内芯铜丝给割开口子（我接触的网线有粗有细，因此才不爱用网线钳进行剥线）</li><li>拽线皮是<strong>环切完毕</strong>了，拿出网线后才<strong>手拽</strong>线皮，<em>不是特么的用网线钳夹住，稍微转转就直接用钳子硬拽硬拉！！</em>（你要这么干也别拿我的钳子干！！<del>伤网线线芯就算了，伤了我自己买的网线钳怎么办</del>）</li><li>剪去不要的软骨与尼龙线注意不要把钳子怼太近，不然会把线芯削掉一部分线皮，甚至刮去一部分铜丝。（加上这个，我才不用网线钳的刀片）</li><li>解双绞不要用螺丝刀插到底部，然后硬拉出来，把线拉开。</li><li>捋直线我个人是左手捏住网线线芯根部，右手捏住线芯外侧头部，然后上下扭（看图）</li><li>估算长度是为了<strong>让水晶头的塑料卡槽能卡住最外层的线皮</strong>，这样拉拽网线的时候是拽的线皮跟软骨，而不是8条内芯与金属铜片的接触点在受力。</li><li>塞入水晶头后<strong>，一要检查线序还对不对，有没有因为塞的时候错位了；二要确认线芯是否插到底部（看图，头部的铜芯都在反光了）；三要看外侧线皮是否插入到塑料卡槽位置</strong></li><li>上一步检查无误后，插入网线钳压接（前面提到了，<strong>金属铜片一端对准网线钳的齿状一侧</strong>）</li></ol><h3 id="电话线实操"><a href="#电话线实操" class="headerlink" title="电话线实操"></a>电话线实操</h3><p>电话线很细，两芯线的话一般是扁的，四芯电话线的话就是圆的（我现在手头没四芯电话线）</p><p>因为电话线尺寸小且不太规则，一般不适合用网线钳的刀片剥线（倒也不是不行，不好用罢了）</p><p>电话线内部线芯很细很软，用剪刀夹着剥线很容易把其中一条线芯剪了，所以我一般都是使用剪刀前端在四周剪一圈小口子，再用手拽出外层线皮。</p><p>介绍一下我爱用的工具——斜口钳</p><h4 id="斜口钳"><a href="#斜口钳" class="headerlink" title="斜口钳"></a>斜口钳</h4><p>我最早是驻点的，所以当时是买的7寸大的斜口钳，挺好使的。</p><p>现在经常在项目地，工具都是随身的，所以换了一把5寸大小的斜口钳，正好插卷纸筒里携带。<del>（怕被尖嘴扎到）</del></p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/ff3d79d86c9a44e3ef7cd.png" alt="斜口钳展示" style="zoom:50%;" /><p>使用斜口钳对电话线进行剥皮：</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/c5c8a293cc045bc634a7f.png" alt="剥电话线"></p><p>有的时候我们剥线会剥的太短了，这时如果有斜口钳，那么可以顶着线芯把外皮往下剪，不伤线芯：</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/dbe6c0d04d14a193ec9f6.png" alt="斜口钳往下挪线皮"></p><blockquote><p>以上操作也可以在网线上进行，而且因为是尖嘴的剪六类的软骨也很方便。</p></blockquote><h4 id="打电话水晶头"><a href="#打电话水晶头" class="headerlink" title="打电话水晶头"></a>打电话水晶头</h4><p>把电话线剥好皮之后，还是一样的估算一下长度。（还有齿状对应金属铜片）</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/8e9a721d107d37f1b7b9d.png" alt="制作电话水晶头"></p><h3 id="网线与电话线的混合使用"><a href="#网线与电话线的混合使用" class="headerlink" title="网线与电话线的混合使用"></a>网线与电话线的混合使用</h3><h3 id="其他与线材相关的工具"><a href="#其他与线材相关的工具" class="headerlink" title="其他与线材相关的工具"></a>其他与线材相关的工具</h3><h4 id="剥线刀"><a href="#剥线刀" class="headerlink" title="剥线刀"></a>剥线刀</h4><h4 id="剥线器"><a href="#剥线器" class="headerlink" title="剥线器"></a>剥线器</h4><h4 id="捋线棒"><a href="#捋线棒" class="headerlink" title="捋线棒"></a>捋线棒</h4><h1 id="寻线仪-测线器"><a href="#寻线仪-测线器" class="headerlink" title="寻线仪&#x2F;测线器"></a>寻线仪&#x2F;测线器</h1>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【路由基础】静态路由、RIP协议</title>
      <link href="/2024/06/04/%E3%80%90%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80%E3%80%91%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E3%80%81RIP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2024/06/04/%E3%80%90%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80%E3%80%91%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E3%80%81RIP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="路由概述"><a href="#路由概述" class="headerlink" title="路由概述"></a>路由概述</h1><p>本文将介绍路由相关知识，也就是路由器相关的内容。(假定你已经熟悉了ip地址、子网掩码、ARP等基础知识)</p><p>上篇介绍的交换与vlan都是二层技术，基于mac地址信息所在的数据帧。</p><p>而路由是三层技术（网络层），是基于ip地址信息所在的数据包。</p><h2 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h2><p><strong>在科普篇我们知道了网段的概念，同一网段内的设备之间可以使用ip地址直接互联。</strong></p><p><strong>而不同网段之间的设备如果也要互联，就需要借助网关。</strong></p><p><strong>网关会根据数据包内的ip地址信息，转发数据包到另一个网段，这个过程就是路由。</strong></p><p>路由是数据通信网络中最基本的要素。路由信息就是指导数据包发送的路径信息，路由的过程就是数据包转发的过程。</p><p>交换是基于mac地址进行转发，路由是基于ip地址进行转发。本质都是根据目的地址转发数据报文到目标所在位置的过程。</p><p>接下来会以直连路由——静态路由——动态路由的大框架开始讲解。其他的不是不讲，而是都会包括在里面。</p><p>其中，动态路由本文只讲RIP协议，其他的碍于篇幅，留作之后另开一文单独讲解。</p><h2 id="路由设备的接口ip"><a href="#路由设备的接口ip" class="headerlink" title="路由设备的接口ip"></a>路由设备的接口ip</h2><p>在讲路由之前还需要补充一个知识点。路由设备的接口是三层接口，可以配置ip地址。</p><p>与我们日常接触的一个设备只有一个ip地址不同，路由设备的ip地址是基于接口的，是<strong>一个接口一个ip地址</strong>。</p><blockquote><p>实际平时接触的设备也可以配置多个ip地址，只是一般不这么做。</p></blockquote><p>跟之前介绍交换机vlan接口时一样，请记住不要讲路由设备当作一个整体，<strong>通信都是基于接口的</strong>。</p><p>就像交换机不同接口可以连接不同vlan一样，<strong>路由设备的不同接口也可以处于不同的网段</strong>。（拥有不同的ip地址）</p><blockquote><p>我们平时家里接触到的家庭路由器是集成了路由器加交换机加无线AP的设备。</p><p>其路由部分就是一个wan口加一个看不见的接口；这个接口连接了交换部分，再成为我们看到的lan口。</p></blockquote><h2 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h2><blockquote><p>直接叫路由器吧，前面说路由设备是因为不止路由器有路由功能。</p><p>比如之前说的三层交换机，再比如硬件防火墙，甚至我们的电脑本身也具备路由功能。</p><p>这边为了方便，本文后面篇幅都直接叫路由器了。</p></blockquote><p>路由表就是路由器内部维护的转发表，与交换机内部的交换转发表类似，都是用来指定数据报文的转发路径。</p><p>交换表是查找目标mac地址在哪个接口，而路由表是查看前往某网段需要经过哪个ip&#x2F;接口。</p><p>在计算机网络中，我们常把这路由表指定的下一个通信方向叫做“出接口”或“下一跳”。</p><p>但其实它们具体意义并不一样，出接口特指<strong>本</strong>路由器的接口（从该接口转发出去），下一跳特指<strong>下一台</strong>路由器（以ip地址为标识）</p><p><strong>当一台路由器收到一个IP报文时，它会在自己的路由表中执行路由查询，寻找匹配该报文的路由条目。</strong></p><ul><li><strong>如果找到了匹配的路由条目，则路由器会按照该条目所指示的出接口&#x2F;下一跳地址转发该报文；</strong></li><li><strong>如果没有找到匹配的路由条目，则表示路由器没有可用于指导报文转发的信息，无法转发报文，因此该报文会被丢弃。</strong></li></ul><p>我们的电脑内部当然也有路由表，Windows里使用命令<em>route print</em>就可以查看路由表。</p><p>下面摘抄几条：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IPv4 路由表</span><br><span class="line">===========================================================================</span><br><span class="line">活动路由:</span><br><span class="line">  网络目标          网络掩码             网关             接口             跃点数</span><br><span class="line">  <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>          <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>            <span class="number">172</span>.<span class="number">25</span>.<span class="number">167</span>.<span class="number">254</span>   <span class="number">172</span>.<span class="number">25</span>.<span class="number">167</span>.<span class="number">25</span>   <span class="number">25</span></span><br><span class="line">  <span class="number">172</span>.<span class="number">25</span>.<span class="number">164</span>.<span class="number">0</span>     <span class="number">255</span>.<span class="number">255</span>.<span class="number">252</span>.<span class="number">0</span>      在链路上          <span class="number">172</span>.<span class="number">25</span>.<span class="number">167</span>.<span class="number">25</span>   <span class="number">281</span></span><br><span class="line">  <span class="number">172</span>.<span class="number">25</span>.<span class="number">167</span>.<span class="number">25</span>    <span class="number">255</span>.<span class="number">255</span>.<span class="number">255</span>.<span class="number">255</span>    在链路上          <span class="number">172</span>.<span class="number">25</span>.<span class="number">167</span>.<span class="number">25</span>   <span class="number">281</span></span><br></pre></td></tr></table></figure><p>能看出第一列是网络号，第二列是子网掩码。(第三列的“在链路上”指不需要经过网关，同网段)</p><p>但我们能发现有几个特殊的地方，网络号0.0.0.0与子网掩码255.255.255.255？</p><h2 id="缺省路由与主机路由"><a href="#缺省路由与主机路由" class="headerlink" title="缺省路由与主机路由"></a>缺省路由与主机路由</h2><p><strong>0.0.0.0</strong>一般用来配置缺省路由所使用的地址，这个地址<strong>表示任意ip地址</strong>。</p><p>缺省路由，也就是默认的路由。</p><p><strong>在路由表中找不到的网段，就会走0.0.0.0这一条默认路由。</strong></p><p>我电脑设置的网关是172.25.167.254，所以就有这一条信息。这样不管我的电脑访问什么外网的ip地址，都会通过网关去访问。</p><p><strong>如果没了这一条缺省路由，我们就会发现电脑无法连上”外网“</strong>，因为电脑查不到路由，数据包不知道发给谁。</p><p>掩码255.255.255.255，这是指全匹配，也就是说这一行的第一列不是网络号，而是一个完全的ip地址。这一条路由是主机路由。</p><p>那么什么是匹配呢？</p><h2 id="最长匹配原则"><a href="#最长匹配原则" class="headerlink" title="最长匹配原则"></a>最长匹配原则</h2><p>路由器收到一个数据包，查找路由表时，会拿着ip地址与路由表中的网段进行逐一匹配。</p><p>在这个过程中，<strong>会匹配掩码最长的、最准确的一条路由信息。</strong></p><p>为了形象一点，把子网掩码转成前缀的书写方式，路由会匹配数字最大的那一条。</p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/cc4abe2c2fc1ae86e9415.png" alt="图1——最长匹配路由" style="zoom:50%;" /><blockquote><p>形象比喻一下，就是：</p><blockquote><p>广东省广州市OO区××街道%%巷##号</p><p>广东省广州市OO区××街道</p><p>广东省广州市</p><p>广东省</p><p>要找我，那最好就是按第一条信息来找最为精准。</p></blockquote></blockquote><p>以前面那张我电脑的路由表来说：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IPv4 路由表</span><br><span class="line">===========================================================================</span><br><span class="line">活动路由:</span><br><span class="line">  网络目标         网络掩码            网关             接口            跃点数</span><br><span class="line">  <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>         <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>           <span class="number">172</span>.<span class="number">25</span>.<span class="number">167</span>.<span class="number">254</span>  <span class="number">172</span>.<span class="number">25</span>.<span class="number">167</span>.<span class="number">25</span>   <span class="number">25</span></span><br><span class="line">  <span class="number">172</span>.<span class="number">25</span>.<span class="number">164</span>.<span class="number">0</span>    <span class="number">255</span>.<span class="number">255</span>.<span class="number">252</span>.<span class="number">0</span>     在链路上         <span class="number">172</span>.<span class="number">25</span>.<span class="number">167</span>.<span class="number">25</span>   <span class="number">281</span></span><br><span class="line">  <span class="number">172</span>.<span class="number">25</span>.<span class="number">167</span>.<span class="number">25</span>   <span class="number">255</span>.<span class="number">255</span>.<span class="number">255</span>.<span class="number">255</span>   在链路上         <span class="number">172</span>.<span class="number">25</span>.<span class="number">167</span>.<span class="number">25</span>   <span class="number">281</span></span><br></pre></td></tr></table></figure><blockquote><p>如果访问172.25.167.25这个ip地址，电脑查找路由表就会匹配第三条路由（172.25.167.25&#x2F;32）。</p><p>如果访问172.25.167.20这个ip地址，电脑查找路由表就会匹配第二条路由（172.25.164.0&#x2F;22）。</p><p>如果访问172.25.1.20这个ip地址，电脑查找路由表就会匹配第一条路由（0.0.0.0&#x2F;0）。</p></blockquote><h2 id="优先级与度量值"><a href="#优先级与度量值" class="headerlink" title="优先级与度量值"></a>优先级与度量值</h2><p>如果存在多条路由信息，且掩码长度一样，无法依靠最长匹配原则分出孰优孰劣。则会比较优先级与度量值。</p><p>优先级是按路由类型划分的，常见的见下表：</p><p>当路由类型一致，则会比较度量值，所谓度量值，也可以称为开销（cost），是到达目标网段的消耗度、代价值。</p><p>实际上，叫做度量值更为准确，因为个别路由类型并不是使用cost作为参考值，例如后面会介绍的RIP协议是采用跳数（hop）作为参考值。</p><h2 id="路由匹配机制"><a href="#路由匹配机制" class="headerlink" title="路由匹配机制"></a>路由匹配机制</h2><p>总结一下，当路由器收到一个待转发的数据包时，它会去查找路由表，如果路由表没有该数据包目的地址所在的信息，则会丢弃。</p><p>如果有相应的路由条目，则按照最长匹配原则转发。</p><p>当最长匹配原无法筛出唯一的路由条目，则再按照优先级比较（越小越优先）</p><p>若还无法确定，则按度量值进行匹配（也是越小越优先）</p><p>万一还是无法确定，则确定为等价路由，随机走其中一条路由。</p><h1 id="直连路由"><a href="#直连路由" class="headerlink" title="直连路由"></a>直连路由</h1><p>直连路由非常的简单，当你给路由器的接口配置了ip地址，那它就会自动生成一条直连路由的信息。</p><p><strong>因为配置ip地址，也就是指明了该接口所处的网段，那么对路由器来说，收到前往该网段的路由的出接口就是经过该接口</strong>。</p><p>对于直连路由来说，由于设定是接口就处于该网段，也就是说数据包无需传递给下一台路由器，数据包的下一个接收对象就是接收方了（忽略掉不感知IP地址的二层交换机）。因此路由器转发该数据包的时候，会直接使用ARP广播查找目标主机，获取到目标主机的回应后，直接将数据包发送给目标主机。</p><p>在ensp上开一台路由器试试</p><p>使用<em><strong>dis ip routing-table</strong></em> 可以查看路由表信息，默认只有本地地址的信息（127.0.0.0网段的）</p><p>进入接口<em><strong>int</strong></em> g0&#x2F;0&#x2F;0，使用<em><strong>ip address</strong></em> 10.1.1.1 8 添加一个IP地址（子网前缀为8）</p><p>这时再查看一次路由表，会发现。。什么新东西都没有。</p><p>不急，这是因为该接口未被启用，使用<em><strong>dis int brief</strong></em> 查看接口状态，就能看到接口都是“<em>down</em>”。</p><p>再添加一台路由器，用线缆连接路由器的0号口，再查看接口状态就是“<em>up</em>”了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[magiku]dis int brief </span><br><span class="line">PHY: Physical</span><br><span class="line">*down: administratively down</span><br><span class="line">(l): loopback</span><br><span class="line">(s): spoofing</span><br><span class="line">(b): BFD down</span><br><span class="line">^down: standby</span><br><span class="line">(e): ETHOAM down</span><br><span class="line">(d): Dampening Suppressed</span><br><span class="line">InUti/OutUti: input utility/output utility</span><br><span class="line">Interface                   PHY   Protocol InUti OutUti   inErrors  outErrors</span><br><span class="line">GigabitEthernet0/0/0        up    up          0%     0%          0          0</span><br><span class="line">GigabitEthernet0/0/1        down  down        0%     0%          0          0</span><br><span class="line">GigabitEthernet0/0/2        down  down        0%     0%          0          0</span><br><span class="line">NULL0                       up    up(s)       0%     0%          0          0</span><br></pre></td></tr></table></figure><p>这时再去查看路由表，就能发现出现3条10网段的路由信息了。（网段路由，主机路由与广播路由）</p><p>同时可以看到“Proto”一列标注为“Direct”，意为直接的。</p><blockquote><p>插播一条知识点，“Flags”一列的“D”，意为download，是指下载到了<em>转发表</em>。是的，除了路由表，还有转发表。<br>路由器实际工作时是以转发表为准，路由器将路由表内的路由信息进行简单处理加载进电路中的转发表，方便进行高速转发，减少中间迭代路由的操作，这有点类似于CPU的cache。<br>但因为一般没有什么区别，也为了方便，还是统一描述为“路由器根据路由表进行转发”。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[magiku]dis ip routing-table</span><br><span class="line">Route Flags: R - relay, D - download to fib</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Routing Tables: Public</span><br><span class="line">         Destinations : 7        Routes : 7        </span><br><span class="line"></span><br><span class="line">Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</span><br><span class="line"></span><br><span class="line">       10.0.0.0/8   Direct  0    0           D   10.1.1.1        GigabitEthernet0/0/0</span><br><span class="line">       10.1.1.1/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/0</span><br><span class="line"> 10.255.255.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/0</span><br><span class="line">      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br></pre></td></tr></table></figure><p>注意，我第二台路由器未做任何配置，但这还是有直连路由出现。</p><p>现在我们把第二台路由器配置一下ip</p><blockquote><p>int g0&#x2F;0&#x2F;0</p><p>ip add 10.1.1.2 8</p></blockquote><p>这两台路由器就可以互相访问了。</p><p>我们再在路由器1底下连接一个PC，IP设置为192.168.1.2 &#x2F;24 。路由器对应接口配置为192.168.1.1&#x2F;24。</p><p>现在路由器1与pc之间也能互相访问。</p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/defe2f1913374cfac9a7b.png" alt="图2——直连路由的缺点" style="zoom:67%;" /><p>可以看到AR1ping的通AR2，也ping的通PC1；问题来了，PC与AR2互通吗？</p><p>PC访问10.1.1.2，检测不是同网段，会发包给AR1；而AR1有到AR2的直连路由，那应该ok？</p><p>但很遗憾，不行</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PC&gt;<span class="built_in">ping</span> <span class="number">10</span>.<span class="number">1</span>.<span class="number">1</span>.<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Ping</span> <span class="number">10</span>.<span class="number">1</span>.<span class="number">1</span>.<span class="number">2</span>: <span class="number">32</span> data bytes, Press Ctrl_C to <span class="built_in">break</span></span><br><span class="line">Request timeout!</span><br><span class="line">Request timeout!</span><br></pre></td></tr></table></figure><p>原因很简单，AR2没有到PC所在的192.168.1.0网段的路由信息，也没有默认路由去AR1。（没有路由就无法转发，无法转发也就会丢弃报文）</p><p>PC可以发包给AR2，AR2不能回包给PC。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[AR2]dis ip rout</span><br><span class="line">Route Flags: R - relay, D - download to fib</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Routing Tables: Public</span><br><span class="line">         Destinations : 7        Routes : 7        </span><br><span class="line"></span><br><span class="line">Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</span><br><span class="line"></span><br><span class="line">       10.0.0.0/8   Direct  0    0           D   10.1.1.2        GigabitEthernet0/0/0</span><br><span class="line">       10.1.1.2/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/0</span><br><span class="line"> 10.255.255.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/0</span><br><span class="line">      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br></pre></td></tr></table></figure><p>为此我们就需要手动配置一条路由信息进去。</p><h1 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h1><p>手动配置的路由就是静态路由。</p><p>上面那个拓扑中，想让AR2访问PC，就需要配置到达192.168.1.0的静态路由。</p><blockquote><p><strong>ip route-static</strong> 192.168.1.0 24 10.1.1.1</p></blockquote><p>后面的参数分别是网段、子网掩码、路由地址（下一跳）。</p><p>在AR2中配置完该命令后，AR2与PC就能相互通信了。</p><blockquote><p>实际上，该命令可以指定出接口，但并不推荐。因为指定出接口的话，会被路由器当成该网段就处于指定的接口下（直连），因而转发数据包的时候，会直接采用ARP查找主机，再直接发送给主机。</p></blockquote><h2 id="静态路由的使用案例"><a href="#静态路由的使用案例" class="headerlink" title="静态路由的使用案例"></a>静态路由的使用案例</h2><p>假设一台电脑同时连接了有线网络与无线WiFi网络，而在这两个网络中分别有一台服务器。</p><p>如果优先使用有线网络，就无法访问无线网络中的服务器，反之亦然。</p><blockquote><p>Windows中的路由优先级的设置就是高级设置中的跃点数</p></blockquote><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/bee680e5e61c1bf1f3dbc.png" alt="图3——跃点数"></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IPv4 路由表</span><br><span class="line">===========================================================================</span><br><span class="line">活动路由:</span><br><span class="line">  网络目标        网络掩码          网关       接口   跃点数</span><br><span class="line">  <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>          <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>     <span class="number">192</span>.<span class="number">168</span>.<span class="number">31</span>.<span class="number">1</span>   <span class="number">192</span>.<span class="number">168</span>.<span class="number">31</span>.<span class="number">146</span>     <span class="number">10</span></span><br><span class="line">  <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>          <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>  <span class="number">192</span>.<span class="number">168</span>.<span class="number">197</span>.<span class="number">178</span>  <span class="number">192</span>.<span class="number">168</span>.<span class="number">197</span>.<span class="number">251</span>     <span class="number">25</span></span><br></pre></td></tr></table></figure><p>目前我在笔记本上连接了无线网络（192.168.31.0&#x2F;24）与有线网络（192.168.197.0&#x2F;24），且已修改为WiFi优先。</p><p>我在有线网络上配置了一台共享服务器10.249.203.64。</p><p>测试一下到达服务器的路径与连通性：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\magiku&gt; tracert <span class="number">10</span>.<span class="number">249</span>.<span class="number">203</span>.<span class="number">64</span></span><br><span class="line"></span><br><span class="line">通过最多 <span class="number">30</span> 个跃点跟踪到 <span class="number">10</span>.<span class="number">249</span>.<span class="number">203</span>.<span class="number">64</span> 的路由</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>     <span class="number">5</span> ms     <span class="number">5</span> ms    <span class="number">17</span> ms  <span class="number">192</span>.<span class="number">168</span>.<span class="number">31</span>.<span class="number">1</span></span><br><span class="line">  <span class="number">2</span>     <span class="number">7</span> ms     <span class="number">5</span> ms     <span class="number">8</span> ms  <span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">1</span></span><br><span class="line">PS C:\Users\magiku&gt; <span class="built_in">ping</span> <span class="number">10</span>.<span class="number">249</span>.<span class="number">203</span>.<span class="number">64</span></span><br><span class="line"></span><br><span class="line">正在 <span class="built_in">Ping</span> <span class="number">10</span>.<span class="number">249</span>.<span class="number">203</span>.<span class="number">64</span> 具有 <span class="number">32</span> 字节的数据:</span><br><span class="line">请求超时。</span><br><span class="line">请求超时。</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>.<span class="number">249</span>.<span class="number">203</span>.<span class="number">64</span> 的 <span class="built_in">Ping</span> 统计信息:</span><br><span class="line">    数据包: 已发送 = <span class="number">2</span>，已接收 = <span class="number">0</span>，丢失 = <span class="number">2</span> (<span class="number">100</span>% 丢失)，</span><br><span class="line">Control-C</span><br></pre></td></tr></table></figure><p>是走的无线网络，而且可以看到无法访问。</p><p>接下来就配置一条静态路由（Windows的配置命令与华为VRP的命令不一样，但还是那么个理）</p><blockquote><p>ip10.249.203.64，掩码255.255.255.255的目的地址 就从有线网络192.168.197.178路由出去</p></blockquote><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\magiku&gt; route add <span class="number">10</span>.<span class="number">249</span>.<span class="number">203</span>.<span class="number">64</span> mask <span class="number">255</span>.<span class="number">255</span>.<span class="number">255</span>.<span class="number">255</span> <span class="number">192</span>.<span class="number">168</span>.<span class="number">197</span>.<span class="number">178</span></span><br><span class="line"> 操作完成!</span><br><span class="line">PS C:\Users\magiku&gt; <span class="built_in">ping</span> <span class="number">10</span>.<span class="number">249</span>.<span class="number">203</span>.<span class="number">64</span></span><br><span class="line"></span><br><span class="line">正在 <span class="built_in">Ping</span> <span class="number">10</span>.<span class="number">249</span>.<span class="number">203</span>.<span class="number">64</span> 具有 <span class="number">32</span> 字节的数据:</span><br><span class="line">来自 <span class="number">10</span>.<span class="number">249</span>.<span class="number">203</span>.<span class="number">64</span> 的回复: 字节=<span class="number">32</span> 时间=<span class="number">2</span>ms TTL=<span class="number">64</span></span><br><span class="line">来自 <span class="number">10</span>.<span class="number">249</span>.<span class="number">203</span>.<span class="number">64</span> 的回复: 字节=<span class="number">32</span> 时间=<span class="number">2</span>ms TTL=<span class="number">64</span></span><br><span class="line">来自 <span class="number">10</span>.<span class="number">249</span>.<span class="number">203</span>.<span class="number">64</span> 的回复: 字节=<span class="number">32</span> 时间=<span class="number">3</span>ms TTL=<span class="number">64</span></span><br><span class="line">来自 <span class="number">10</span>.<span class="number">249</span>.<span class="number">203</span>.<span class="number">64</span> 的回复: 字节=<span class="number">32</span> 时间=<span class="number">2</span>ms TTL=<span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>.<span class="number">249</span>.<span class="number">203</span>.<span class="number">64</span> 的 <span class="built_in">Ping</span> 统计信息:</span><br><span class="line">    数据包: 已发送 = <span class="number">4</span>，已接收 = <span class="number">4</span>，丢失 = <span class="number">0</span> (<span class="number">0</span>% 丢失)，</span><br><span class="line">往返行程的估计时间(以毫秒为单位):</span><br><span class="line">    最短 = <span class="number">2</span>ms，最长 = <span class="number">3</span>ms，平均 = <span class="number">2</span>ms</span><br></pre></td></tr></table></figure><p>上浏览器实测，也确实可以正常访问服务器。</p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/38cea6ff75c6386d32000.png" alt="图4——服务器验证" style="zoom:67%;" /><h2 id="浮动路由"><a href="#浮动路由" class="headerlink" title="浮动路由"></a>浮动路由</h2><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/a3bbcb54a80e8f5f326b2.png" alt="图5——浮动路由拓扑" style="zoom:67%;" /><p>以这个拓扑为例子，存在3个网段，假设ip地址都配置好了。</p><p>那么我们需要在R1与R4上各补充两条路由才能保证R1到R4网络互通。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[R1]ip route-static 192.168.1.0 24 10.0.12.2</span><br><span class="line">[R1]ip route-static 192.168.1.0 24 10.0.13.3</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[R4]ip route-static 10.0.12.0 24 192.168.1.2</span><br><span class="line">[R4]ip route-static 10.0.13.0 24 192.168.1.3</span><br></pre></td></tr></table></figure><p>事实也如此。</p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/292ebae1fba28a24af93d.png" alt="图6——R4配置图" style="zoom: 67%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[R1]display ip routing-table </span><br><span class="line">Route Flags: R - relay, D - download to fib</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Routing Tables: Public</span><br><span class="line">         Destinations : 11       Routes : 12       </span><br><span class="line"></span><br><span class="line">Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</span><br><span class="line"></span><br><span class="line">      10.0.12.0/24  Direct  0    0           D   10.0.12.1       GigabitEthernet0/0/0</span><br><span class="line">      10.0.12.1/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/0</span><br><span class="line">    10.0.12.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/0</span><br><span class="line">      10.0.13.0/24  Direct  0    0           D   10.0.13.1       GigabitEthernet0/0/1</span><br><span class="line">      10.0.13.1/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/1</span><br><span class="line">    10.0.13.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/1</span><br><span class="line">      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">    192.168.1.0/24  Static  60   0          RD   10.0.12.2       GigabitEthernet0/0/0</span><br><span class="line">                    Static  60   0          RD   10.0.13.3       GigabitEthernet0/0/1</span><br><span class="line">255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们把焦点落到这条路由条目上，对于前往R4所在的192.168.1.0&#x2F;24网段，有两个下一跳与出接口，这就是等价路由。</p><pre><code>192.168.1.0/24  Static  60   0          RD   10.0.12.2       GigabitEthernet0/0/0                Static  60   0          RD   10.0.13.3       GigabitEthernet0/0/1</code></pre><p>因为我们配置的都是静态路由，且都没做任何其他修改。等价路由的好处就是可以实现负载分担，让流量能分摊到两条链路中。</p><p>但有时我们希望流量只走一条链路，另一条链路作为备用的，当主链路故障时，再自动切换到备用链路。</p><p>这很好理解，就是设置优先级，就像我们前面修改Windows系统中网络的跃点数，让WiFi优先于有线网络一样。</p><p>我们也可以手动设置静态路由的优先级。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[R1]ip route-static 192.168.1.0 24 10.0.12.2 preference 10</span><br></pre></td></tr></table></figure><p>接下来再看一次R1的路由表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[R1]display ip routing-table </span><br><span class="line">Route Flags: R - relay, D - download to fib</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Routing Tables: Public</span><br><span class="line">         Destinations : 11       Routes : 11       </span><br><span class="line"></span><br><span class="line">Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</span><br><span class="line"></span><br><span class="line">      10.0.12.0/24  Direct  0    0           D   10.0.12.1       GigabitEthernet0/0/0</span><br><span class="line">      10.0.12.1/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/0</span><br><span class="line">    10.0.12.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/0</span><br><span class="line">      10.0.13.0/24  Direct  0    0           D   10.0.13.1       GigabitEthernet0/0/1</span><br><span class="line">      10.0.13.1/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/1</span><br><span class="line">    10.0.13.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/1</span><br><span class="line">      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">    192.168.1.0/24  Static  10   0          RD   10.0.12.2       GigabitEthernet0/0/0</span><br><span class="line">255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br></pre></td></tr></table></figure><p>我们可以看到只剩下刚刚修改了优先级的那一条，另外一条不见了。但其实那条路由还存在数据库里，是“潜藏”起来了。</p><p>而当该链路故障时（这边直接使用关闭接口的命令模拟），该静态路由就会失效。而另一条路由则“浮现”出来了。</p><p>因为这种现象，虽然仅仅只是对静态路由修改了优先级，但这种配置方式叫做“<strong>浮动路由</strong>”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[R1]interface g0/0/0</span><br><span class="line">[R1-GigabitEthernet0/0/0]shutdown </span><br><span class="line">[R1-GigabitEthernet0/0/0]q</span><br><span class="line">[R1]display ip routing-table </span><br><span class="line">Route Flags: R - relay, D - download to fib</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Routing Tables: Public</span><br><span class="line">         Destinations : 8        Routes : 8        </span><br><span class="line"></span><br><span class="line">Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</span><br><span class="line"></span><br><span class="line">      10.0.13.0/24  Direct  0    0           D   10.0.13.1       GigabitEthernet0/0/1</span><br><span class="line">      10.0.13.1/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/1</span><br><span class="line">    10.0.13.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/1</span><br><span class="line">      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">    192.168.1.0/24  Static  60   0          RD   10.0.13.3       GigabitEthernet0/0/1</span><br><span class="line">255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br></pre></td></tr></table></figure><blockquote><p>实际上，在R2与R3上最好要配上到达R1的另一个网段的静态路由。不然可能出现以下现象：</p><p>假设交换机SW1底下连接一台PC，网关设置为R3。</p><blockquote><p>当使用R1去ping PC，当前路由优先级让R1到达192.168.1.0&#x2F;24网段走R1-R2的链路，PC就处于R2的直连路由底下，因此从R1到PC的去程是通的；</p><p>而返程的时候，因为去程是走的R1-R2的链路，报文中的源ip地址也就是10.0.12.1，PC回包的时候，填写的目的也就是该地址，且由于与该ip地址处于不同网段，PC会将该回包发给它的网关R3，但R3并没有到达10.0.0.12.1的路由，因此该回程报文会在此被丢弃。</p><p>最终，R1 ping不通PC。</p></blockquote><p>而当使用PC去ping R1的时候，如果使用的是R1的10.0.13.1的ip地址，那么PC是能ping通R1的。</p></blockquote><h3 id="”不浮动的浮动路由“"><a href="#”不浮动的浮动路由“" class="headerlink" title="”不浮动的浮动路由“"></a>”不浮动的浮动路由“</h3><p>其实以上需求除了配置浮动路由之外，还有另外一个方式，那就是修改路由的目标网段子网掩码大小，本质还是让等价路由不再等价。</p><blockquote><p>当然，行业里没有”不浮动的浮动路由“这个叫法，是我的比喻。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[R1]ip route-static 192.168.1.0 24 10.0.12.2</span><br><span class="line">[R1]ip route-static 192.168.0.0 23 10.0.13.3</span><br><span class="line">[R1]display ip routing-table </span><br><span class="line">Route Flags: R - relay, D - download to fib</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Routing Tables: Public</span><br><span class="line">         Destinations : 12       Routes : 12       </span><br><span class="line"></span><br><span class="line">Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</span><br><span class="line"></span><br><span class="line">      10.0.12.0/24  Direct  0    0           D   10.0.12.1       GigabitEthernet0/0/0</span><br><span class="line">      10.0.12.1/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/0</span><br><span class="line">    10.0.12.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/0</span><br><span class="line">      10.0.13.0/24  Direct  0    0           D   10.0.13.1       GigabitEthernet0/0/1</span><br><span class="line">      10.0.13.1/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/1</span><br><span class="line">    10.0.13.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/1</span><br><span class="line">      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">    192.168.0.0/23  Static  60   0          RD   10.0.13.3       GigabitEthernet0/0/1</span><br><span class="line">    192.168.1.0/24  Static  60   0          RD   10.0.12.2       GigabitEthernet0/0/0</span><br><span class="line">255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br></pre></td></tr></table></figure><p>这样的话，同时加载&#x2F;23与&#x2F;24的路由，根据最长匹配原则，就会优先走&#x2F;24的主链路。</p><p>同样的，当主链路故障后，主链路的路由失效，就会匹配到&#x2F;23的路由，从而走备用链路转发报文。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[R1]interface g0/0/0</span><br><span class="line">[R1-GigabitEthernet0/0/0]shutdown</span><br><span class="line">[R1-GigabitEthernet0/0/0]q</span><br><span class="line">[R1]display ip routing-table </span><br><span class="line">Route Flags: R - relay, D - download to fib</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Routing Tables: Public</span><br><span class="line">         Destinations : 8        Routes : 8        </span><br><span class="line"></span><br><span class="line">Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</span><br><span class="line"></span><br><span class="line">      10.0.13.0/24  Direct  0    0           D   10.0.13.1       GigabitEthernet0/0/1</span><br><span class="line">      10.0.13.1/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/1</span><br><span class="line">    10.0.13.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet0/0/1</span><br><span class="line">      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">    192.168.0.0/23  Static  60   0          RD   10.0.13.3       GigabitEthernet0/0/1</span><br><span class="line">255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br></pre></td></tr></table></figure><h2 id="汇总路由与黑洞路由"><a href="#汇总路由与黑洞路由" class="headerlink" title="汇总路由与黑洞路由"></a>汇总路由与黑洞路由</h2><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/5cafdb92eaa0ed084232a.png" style="zoom:50%;" /><p>我们修改一下拓扑到现在这个状态，R1直连互联网，作为出口路由器。因此配置了默认路由（缺省路由）指向外网。</p><p>则R2与R3也需要配置指向R1的默认路由。</p><p>在此基础上，R2底下连有3个网段，R3底下连有4个网段。</p><p>则我们需要在R1上配置如下静态路由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[R1]ip route-static 192.168.1.0 24 10.0.12.2</span><br><span class="line">[R1]ip route-static 192.168.2.0 24 10.0.12.2</span><br><span class="line">[R1]ip route-static 192.168.3.0 24 10.0.12.2</span><br><span class="line">[R1]</span><br><span class="line">[R1]ip route-static 192.168.4.0 24 10.0.13.3</span><br><span class="line">[R1]ip route-static 192.168.5.0 24 10.0.13.3</span><br><span class="line">[R1]ip route-static 192.168.6.0 24 10.0.13.3</span><br><span class="line">[R1]ip route-static 192.168.7.0 24 10.0.13.3</span><br></pre></td></tr></table></figure><p>在R2与R3也需要配置相应的路由，这就很繁琐了。</p><p>而仔细观察我们的网络规划，可以发现网段都是连续的，这就可以通过“反向子网划分”，扩大网段的方式把多条路由信息聚合成单条路由。</p><p>比如R1的配置就可以修改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[R1]ip route-static 192.168.0.0 22 10.0.12.2</span><br><span class="line">[R1]</span><br><span class="line">[R1]ip route-static 192.168.4.0 22 10.0.13.3</span><br></pre></td></tr></table></figure><p>这种方式称为汇总路由&#x2F;聚合路由&#x2F;路由汇总（总之这个意思的叫法都行）</p><h3 id="黑洞路由"><a href="#黑洞路由" class="headerlink" title="黑洞路由"></a>黑洞路由</h3><p>但是就当前拓扑来说，这个方案存在一点缺陷：192.168.0.0 &#x2F;22这个大网段中包含了192.168.0.0–192.168.0.255这一段ip地址，而原本的拓扑中，R2并不拥有该段地址。</p><p>如果这一段地址，该区域其他路由器有在使用，我们还可以配置192.168.0.0&#x2F;24的静态路由，依靠最长匹配原则让数据报能走到正确的位置。</p><p>但如果该区域内就是没有使用这段ip，一般情况下没有问题，但这是一个潜在的安全隐患。</p><p>假设网络中突然存在送达给192.168.0.233的数据包，该数据包会被路由到R2。</p><p>但是R2检查自己的路由表，匹配不到192.168.0.0&#x2F;24的路由，且因为之前配置了0.0.0.0的默认路由指向R1。则数据包会按默认路由的方向转发给R1。</p><p>对于R1来说，它又会继续按照192.168.0.0&#x2F;22的路由转发回R2。</p><p>这个数据包就此在R1与R2之间来回循环，知道数据包内TTL值归0.</p><p>这个漏洞如果被蓄意攻击者发现，则会导致网络资源被大量消耗。</p><p>要解决这个问题，可以为该网段配置静态路由，出接口设置为null 0。意为直接丢弃该数据包。</p><p>这酷似黑洞，不管来多少数据包，通通都会消失，因此这种配置方式叫做黑洞路由。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[R1]ip route-static 192.168.0.0 24 NULL 0</span><br></pre></td></tr></table></figure><h2 id="静态路由的改善"><a href="#静态路由的改善" class="headerlink" title="静态路由的改善"></a>静态路由的改善</h2><p>静态路由一般用于小型网络，因为其不具备灵活变动的特性，遇上网络变动&#x2F;故障，就会导致通信失效。</p><blockquote><p>上面介绍浮动路由那里看起来似乎是带有灵活变动的特性啊？</p><p>这个是因为静态路由需要使用出接口，而当出接口的状态为“dowm”时，使用到该出接口的路由也就失效了。</p><p>但是很多时候，路由器检测到的直连链路状态是否正常不意味着，路由是否正常。</p><p>比如说路由器A——交换机S——路由器B，这样的连接模式，路由器A只能检测它到交换机S的链路状态，如果故障出在交换机S到路由器B之间，那么路由器A是无法感知的。</p></blockquote><p>取前面浮动路由的拓扑，我们调皮一下，R1与R2之间加一台交换机，然后不连接交换机到R2的链路。</p><p>可以看到，R1对于到达R2的直连路由和经过R2的静态路由都没有删除，依旧保留着。</p><p>这种情况下，即便配备了浮动路由，由于检测不到网络变动，也达不到主备切换。</p><p>虽然有备用链路，但还是造成了局部断网的现象。</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/e2a3cce5d658fb7b969a4.png" alt="静态路由不感知网络变动"></p><p>为此，有两种解决方法，一是采用动态路由，二是为静态路由绑定BFD。</p><p>第一种是我们的重点学习内容，之后会专门介绍；</p><p>第二种是让静态路由绑定检测工具，检测到网络故障，就删除静态路由；网络恢复就恢复静态路由。</p><blockquote><p>NQA也可以实现BFD对于静态路由的增删功能，但BFD的检测速度更快，且一般支持BFD协议的设备更多。</p></blockquote><h3 id="BFD的介绍与简单配置"><a href="#BFD的介绍与简单配置" class="headerlink" title="BFD的介绍与简单配置"></a>BFD的介绍与简单配置</h3><p>双向转发检测BFD（Bidirectional Forwarding Detection）是一种快速检测链路或节点故障的协议；</p><p>通常用于路由器、交换机等网络设备之间进行链路状态检测。</p><p>由于 BFD 能够提供快速的故障检测和快速的路由切换，因此在网络设备中得到了广泛的支持。</p><p>BFD在两台网络设备上建立会话，用来检测网络设备间的双向转发路径，为上层应用服务。</p><p>BFD本身并没有邻居发现机制，而是靠<em>被服务的上层应用</em>通知其邻居信息以建立会话。</p><p>会话建立后会周期性地快速发送BFD报文，如果在检测时间内没有收到BFD报文则认为该双向转发路径发生了故障，通知被服务的上层应用进行相应的处理。</p><p>简单的配置命令为</p><ul><li><strong>bfd</strong>  &#x2F;&#x2F;开启bfd功能</li><li><strong>bfd</strong> <em>session-name</em> <strong>bind</strong> <strong>peer-ip</strong> <em>ip-address</em> <strong>interface</strong> <em>interface-type</em> <em>interface-number</em> &#x2F;&#x2F;创建BFD会话的绑定信息，自定义参数分别为自定义会话名称、对端设备接口ip、本端设备的出接口。</li><li><strong>discriminator local</strong> <em>discr-value</em>  &#x2F;&#x2F;配置BFD会话的本地标识符。</li><li><strong>discriminator remote</strong> <em>discr-value</em>  &#x2F;&#x2F;配置BFD会话的远端标识符。 </li><li><strong>commit</strong>   &#x2F;&#x2F;提交配置</li></ul><blockquote><p>会话名称完全自定义，两端不需要名称相同。但标识符就需要彼此对应。</p></blockquote><p>以下一小节的拓扑为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;AR1&gt;system-view </span><br><span class="line">[AR1]bfd</span><br><span class="line">[AR1-bfd]bfd magiku bind peer-ip 10.1.1.2 interface g0/0/0</span><br><span class="line">[AR1-bfd-session-magiku]discriminator local 1</span><br><span class="line">[AR1-bfd-session-magiku]discriminator remote 2</span><br><span class="line">[AR1-bfd-session-magiku]commit </span><br><span class="line">[AR1-bfd-session-magiku]q</span><br><span class="line">[AR1]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;AR2&gt;system-view </span><br><span class="line">[AR2]bfd</span><br><span class="line">[AR2-bfd]bfd magiku030 bind peer-ip 10.1.1.1 interface g0/0/0 </span><br><span class="line">[AR2-bfd-session-magiku030]discriminator local 2</span><br><span class="line">[AR2-bfd-session-magiku030]discriminator remote 1</span><br><span class="line">[AR2-bfd-session-magiku030]commit </span><br><span class="line">[AR2-bfd-session-magiku030]q</span><br><span class="line">[AR2]</span><br></pre></td></tr></table></figure><blockquote><p>标识符是一一对应的，AR1的本地标识符就是AR2上的对端标识符。</p></blockquote><p>配置后，执行命令<strong>display bfd session all</strong>，检查BFD会话是否建立：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[AR1]display bfd session all</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">Local Remote     PeerIpAddr      State     Type        InterfaceName            </span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">1     2          10.1.1.2        Up        S_IP_IF     GigabitEthernet0/0/0     </span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">     Total UP/DOWN Session Number : 1/0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[AR2]display bfd session all</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">Local Remote     PeerIpAddr      State     Type        InterfaceName            </span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">2     1          10.1.1.1        Up        S_IP_IF     GigabitEthernet0/0/0     </span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">     Total UP/DOWN Session Number : 1/0</span><br></pre></td></tr></table></figure><h4 id="单臂回声BFD"><a href="#单臂回声BFD" class="headerlink" title="单臂回声BFD"></a>单臂回声BFD</h4><p>如果链路两端的路由器只有一端支持BFD功能，那么就可以配置为单臂回声BFD（华为ensp模拟器中不支持该功能）。</p><p>操作步骤</p><ol><li><p>执行命令<strong>bfd</strong> &#x2F;&#x2F;开启bfd功能</p></li><li><p>执行命令<strong>bfd</strong> <em>session-name</em> <strong>bind peer-ip</strong> <em>peer-ip</em> <strong>interface</strong> <em>interface-type interface-number</em> <strong>one-arm-echo</strong> &#x2F;&#x2F;创建单臂回声功能的BFD会话。自定义参数分别为自定义会话名称、对端设备接口ip、本端设备的出接口。</p></li><li><p>执行命令<strong>discriminator</strong> <strong>local</strong> <em>discr-value</em> &#x2F;&#x2F; 配置单臂回声功能的BFD会话的标识符。</p><p>由于只能在支持BFD功能的一端设备上配置单臂回声功能，所以，配置单臂回声功能的BFD会话时，只需要配置本地标识符，无需配置远端标识符。</p></li><li><p>执行命令<strong>commit</strong>  &#x2F;&#x2F;提交配置。</p></li></ol><blockquote><p>但单臂回声BFD因为只能用在一端设备，所以对于解决静态路由灵活性的帮助不大。这边就当简单了解一下吧。</p></blockquote><h3 id="静态路由绑定BFD"><a href="#静态路由绑定BFD" class="headerlink" title="静态路由绑定BFD"></a>静态路由绑定BFD</h3><p><strong>ip route-static</strong> <em>ip-address</em> <em>mask</em>  <em>nexthop-address</em>  <strong>track bfd-session</strong> <em>bfd-name</em> ，为IPv4静态路由绑定静态BFD会话。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[AR1]ip route-static 192.168.2.0 24 10.1.1.2 track bfd-session magiku</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[AR2]ip route-static 192.168.1.0 24 10.1.1.1 track bfd-session magiku030</span><br></pre></td></tr></table></figure><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/c6ddcc1d10589fdb5d101.png" alt="图5——静态路由与BFD拓扑测试"></p><p>配置完毕后，网络通信正常。至于链路故障后，路由是否删除；链路恢复后，路由是否也恢复；碍于篇幅在此就不作测试了。</p><h3 id="实际作用"><a href="#实际作用" class="headerlink" title="实际作用"></a>实际作用</h3><p>你也许会在想，设置这个联动有什么用，链路都故障了，路由删不删不是还一样通不了。（如果不是等价路由的情境下）</p><p>那是因为我们是用的两台路由器做讲解，如果加入第三台路由器，情况会如何呢。</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/3e60125980173cf5748a9.png" alt="图6——静态路由中的三台路由器拓扑"></p><p>AR1与AR2都配置一条192.168.0.0 &#x2F;16的路由指向AR3。</p><p>AR3中配置到达192.168.1.0 &#x2F;24  与 192.168.2.0 &#x2F;24的路由信息。</p><ul><li><p>当AR1到AR2的链路正常时，根据最长匹配原则，优先匹配&#x2F;24的路由，走该链路。</p></li><li><p>当链路AR1-AR2故障后：</p><ul><li><p>如果没有配置BFD，依旧匹配AR1-AR2的路径，则网络不可达。</p></li><li><p>如果配置了BFD，AR1与AR2都匹配&#x2F;16的路由走AR1-AR3-AR2的路径，网络通信正常。</p></li></ul></li></ul><h1 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h1><p>动态路由相对于静态路由来说，配置简单且具备动态自动增删路由的功能。</p><p>目前常用的动态路由有RIP、OSPF、IS-IS、BGP。</p><p>RIP是过时的技术，但实际现网中还在使用，主要用于小型网络。</p><p>OSPF则覆盖小中大型网络，用于淘汰RIP的新技术。</p><p>IS-IS与BGP用于大型、骨干型网络，一般公司几乎接触不到，多用在运营商网络中。</p><p><strong>一般来说，学习重点在OSPF。</strong></p><blockquote><p>实际能接触到的，还是静态路由比较多（笑</p></blockquote><h2 id="距离矢量路由协议与链路状态路由协议"><a href="#距离矢量路由协议与链路状态路由协议" class="headerlink" title="距离矢量路由协议与链路状态路由协议"></a>距离矢量路由协议与链路状态路由协议</h2><p>动态路由按大类型，分为以下两种。</p><h3 id="距离矢量路由"><a href="#距离矢量路由" class="headerlink" title="距离矢量路由"></a>距离矢量路由</h3><p>矢量一词在物理学上的释义:既有大小又有方向的量。</p><p>所谓的距离矢量路由便是以距离长度与方向为参考计算的动态路由协议。</p><p>长度是指到达目标网络的度量值，而方向指的是到达该目标网络的下一跳。</p><p>距离矢量路由比喻起来就是在街上问路，好心人告诉你往哪个方向再走多久就能到达。</p><p>你把这句话记录下来，这就是动态路由信息。</p><p>本文后续介绍的RIP协议便是距离矢量路由协议</p><h3 id="链路状态路由"><a href="#链路状态路由" class="headerlink" title="链路状态路由"></a>链路状态路由</h3><p>链路状态路由协议则是使用一些特殊的信息描述网络的拓扑结构与网段信息，这些信息称为链路状态信息（Link State）。</p><p>这些信息会被存放于链路状态数据库（Link State Database）中，之后路由器会基于LSDB去计算出一个以自己为根的无环的最短路径树，并根据该树状网络得到路由信息。（可以说是于STP很相近的一种思路）</p><p>链路状态路由比喻起来就是收集了几个景点的周边地图与公交地铁路线图，之后计算规划出了最省时间，路程最少的旅游攻略。</p><p>去每个景点的过程路线便是动态路由信息。</p><p>链路状态路由协议的代表就是OSPF，后续单独介绍。</p><p>动态路由协议还有其他的分类方式，但我认为那并不重要，就不展开介绍了。</p><p>本文先介绍RIP，其他的路由协议比较复杂，适合一个一个出文章细细道来。</p><h2 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h2><p><strong>RIP</strong>、Routing Information Protocol（路由信息协议）是一种较为简单的内部网关协议（<strong>IGP</strong>、Interior Gateway Protocol）。</p><p>RIP是一种基于距离矢量（Distance-Vector）算法的协议，它使用跳数（Hop Count）作为度量来衡量到达目的网络的距离。</p><p>RIP通过端口号520的UDP报文进行路由信息的交换。</p><p>RIP诞生于 1988 年；在1993 年时，RIP 的版本升级到v2，增加了一些功能和改进，如支持无类别域间路由（CIDR）、VLSM（可变长度子网掩码）等。</p><p>本文不会花时间专门讲v1版本与v2版本的区别，都半截入土的技术了。</p><p>用起来也是直接用v2版本，因此直接默认使用v2来讲解。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>RIP协议的核心在于跳数，设备直连时，则前往该网段的跳数为0，不需要经过其他路由设备。</p><p>前往目标网段需一台设备中继，则跳数为1。</p><p>以此类推，直到跳数为16，<strong>16表示不可达</strong>，为上限值。也是因此，RIP协议不可用于大型网络。</p><p>这便是距离矢量中的长度向量。</p><p>RIP协议的次核心的接口（包含接口的ip），当设备开启RIP协议时，实际设备并不会发送去接收RIP报文，需要为RIP进程配置启用RIP的接口。</p><blockquote><p>业内习惯称为”宣告网段”，但实际是宣告启用的接口，符合“宣告的网段”内的ip地址的接口就会被加入RIP进程。</p></blockquote><p>当接口加入RIP进程，自然其直连路由也就纳入了RIP路由表。（直连路由跳数写为0）</p><p>设备便会向所有运行RIP进程的接口去发送RIP路由报文。（发送时将直连路由跳数写为1）</p><p>当设备从某一接口收到了附近邻居发来的RIP路由报文，便会记录在自身的数据库中，未来匹配到路由时也就能从该接口转发出去。（将对方写跳数1的路由直接加入表中）</p><blockquote><p>也就是发送RIP报文时，先将跳数+1再发布出去。而接收者，接收到路由信息则无需处理，直接纳入路由表中。</p></blockquote><p>当设备收到数据包，需要进行路由转发时，<strong>先匹配网段再匹配跳数，走跳数低的路径。</strong></p><p>这是碍于该协议诞生时的环境导致的逻辑——跳数低的路径则意味着距离近，能更快的传递消息。</p><p>但到了现在，链路的带宽速率已经有了很大的差别，可能会出现跳数低的路径都是百兆的链路，而跳数多的链路都是千兆及以上的链路。</p><h4 id="RIP路由表的生成过程"><a href="#RIP路由表的生成过程" class="headerlink" title="RIP路由表的生成过程"></a>RIP路由表的生成过程</h4><p>RIP启动时的初始路由表仅包含本设备的一些直连接口路由。通过相邻设备互相学习路由表项，才能实现各网段路由互通。</p><ul><li>RIP协议启动之后，RouterA会向相邻的路由器广播一个Request报文请求周边邻居的RIP路由表。同时也会发送一个Response报文发布自己持有的路由。</li><li>当RouterB从接口接收到RouterA发送的Request报文后，把自己的RIP路由表封装在Response报文内，然后向该接口发送。</li><li>RouterA根据RouterB发送的Response报文，形成自己的路由表。</li></ul><h4 id="RIP的更新与维护"><a href="#RIP的更新与维护" class="headerlink" title="RIP的更新与维护"></a>RIP的更新与维护</h4><h5 id="RIP定时器"><a href="#RIP定时器" class="headerlink" title="RIP定时器"></a>RIP定时器</h5><p>RIP协议在更新和维护路由信息时主要使用四个定时器： </p><ul><li>更新定时器（Update timer）：默认30秒，当此定时器超时时，立即<strong>发送更新报文</strong>。</li><li>老化定时器（Age timer）：默认180秒，RIP设备如果在老化时间内<strong>没有收到</strong>邻居发来的路由更新报文，则认为该路由不可达，<strong>停用</strong>该路由。从路由表中删除，但还保留在数据库中，一方面是为了方便收到更新时能快速启用该路由，另一方面是会在发布的更新报文继续发布该路由，但度量值设定为16，以通告给周边路由器，自己持有的该路由失效了。</li><li>垃圾收集定时器（Garbage-collect timer）：默认120秒，当路由被标记为不可达，从路由表中删除时，就会启用该计时器。如果在垃圾收集时间内不可达路由<strong>没有收到</strong>来自同一邻居的更新，则该路由将被从本设备RIP中<strong>彻底删除</strong>。 </li><li>抑制定时器（Suppress timer）：当RIP设备收到对端的路由更新，其度量值为16时，对应路由进入抑制状态，并启动抑制定时器。为了防止路由震荡，在抑制定时器超时之前，即使再收到对端路由cost小于16的更新，也不接受。当抑制定时器超时后，就重新允许接受对端发送的路由更新报文。</li></ul><blockquote><p> 注：RIP协议定期更新的路由报文一般都是发送设备一整张RIP路由表，默认不作个性化区分，一律发送完整路由表。</p></blockquote><p>RIP路由与定时器之间的关系：</p><ul><li><p>RIP的路由信息<strong>发布</strong>是由更新定时器控制的，默认为每30秒发送一次。（或者是接收到邻居的request请求报文）</p></li><li><p>每一条路由表项对应两个定时器：老化定时器和垃圾收集定时器。</p><p>当学到一条路由并添加到RIP路由表中时，老化定时器启动。</p><p>如果老化定时器超时，设备仍没有收到邻居发来的更新报文，则在RIP数据库中把该路由的度量值置为16（表示路由不可达，路由表中删除），并启动垃圾收集定时器；同时设备对外发送不可达路由更新请求报文。</p><p>如果垃圾收集定时器超时，设备仍然没有收到更新报文，则在RIP数据库中删除该路由。</p></li></ul><blockquote><p>简单来说：</p><p>更新定时器用于控制设备的RIP报文发布的周期。</p><p>老化定时器用于标记接收到路由信息是否可用，垃圾收集定时器用于清理不可用的路由。</p></blockquote><h5 id="触发更新"><a href="#触发更新" class="headerlink" title="触发更新"></a>触发更新</h5><p>由于RIP路由信息的发布由更新定时器控制，所以当设备有路由信息更新了，也需要等更新定时器到点后才会向周边邻居发布。</p><p>是的，这跟STP很像，链路故障后，收敛速度慢，每两台设备之间需要最多30s才更新实时的网络拓扑状态。</p><p>至于为什么要设定更新定时器这个机制，则是因为RIP协议发布路由信息是将RIP的整张路由表发送出去。</p><p>如果周期设置的短，大量数据的来回传播会占用大部分网络资源。</p><p>这<strong>个问题在后来的RIP v2中得到了改善：引入了触发更新机制。</strong></p><p>触发更新是指<strong>当路由信息发生变化时，立即向邻居设备发送触发更新报文</strong>，<strong>而不用等待更新定时器超时，从而避免产生路由环路。</strong></p><p>路由环路是什么呢，下面就介绍以下RIP协议中可能出现的环路现象。</p><h4 id="RIP的防环机制"><a href="#RIP的防环机制" class="headerlink" title="RIP的防环机制"></a>RIP的防环机制</h4><p>RIP协议是基于距离矢量的路由协议，它并不会去检查与记录路由信息的来源与确定性，这就导致会出现路由环路的可能。</p><p>假设AR1与AR2相连且开启了RIP协议，AR1下有一直连网段192.168.1.0&#x2F;24，AR1会通过RIP传递该网段路由信息给周边设备（包含了AR2）。</p><p>AR2接收的报文，了解了到达192.168.1.0&#x2F;24网段的跳数为1，记录进表中。</p><p>之后AR2定时发送更新报文，就会发送能到达192.168.1.0&#x2F;24但跳数为2的路由信息。</p><p>以下便是我在模拟器，抓包到的内容：</p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/9cdaed1691e86714b7ea3.png" alt="图7——RIP-AR1toAR2" style="zoom:67%;" /><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/42096046d81af1fc18500.png" alt="图8——RIP-AR2toAR1" style="zoom:67%;" /><p><strong>如果没有开启触发更新特性</strong>，当AR1到192.168.1.0&#x2F;24的直连链路故障后，AR1失去了跳数为0的直连路由。</p><p>AR1需要等到30s的更新周期到达后，就会向周围邻居告知，他拥有的路由失效了（发布时，跳数写为16）</p><p><strong>对AR2来说，在没收到AR1的更新报文前，它不知道AR1的直连路由断了，因此它依旧会发送可到达192.168.1.0.&#x2F;24跳数为2的路由</strong>。</p><p>当AR2的更新报文来的比AR1快的时候，AR1收到新的含有能到达192.168.1.0&#x2F;24网段的路由，便会启用该跳数为2的通过AR2转发的路由。</p><p>此时AR2会按照它表里的到达192.168.1.0&#x2F;24跳数为1的走AR1的路由，将数据包转给AR1。而AR1按照它表里的到达192.168.1.0&#x2F;24跳数为2的走AR2的路由再把数据包转给AR2。</p><p>这就导致数据包会在AR1与AR2之间循环。</p><p>不过这种路由环路不会无期限的存在，每个30s周期，他们之间互相更新RIP报文，都会将跳数依次累加上去，直到16跳，被视为不可达。</p><p>没错，<strong>设定最大跳数为16，其实也是一钟防环机制，与ipv4中的TTL字段异曲同工。</strong></p><p>RIP的路由环路，简单来说就是设备两两之间会重复对方之前发来的路由信息。为此便诞生两个治本的防环机制。</p><h5 id="水平分割"><a href="#水平分割" class="headerlink" title="水平分割"></a>水平分割</h5><p>水平分割（Split Horizon）的原理是，RIP从某个接口学到的路由，不会从该接口再发回给邻居路由器。</p><p>这样不但减少了带宽消耗，还可以防止路由环路。 </p><blockquote><p>操作步骤：</p><ol><li>执行命令<strong>system-view</strong>，进入系统视图。</li><li>执行命令<strong>interface</strong> <em>interface-type</em> <em>interface-number</em>，进入接口视图。</li><li>执行命令<strong>rip split-horizon</strong>，启动水平分割。</li></ol></blockquote><h5 id="毒性反转"><a href="#毒性反转" class="headerlink" title="毒性反转"></a>毒性反转</h5><p>毒性反转（Poison Reverse）的原理是，RIP从某个接口学到路由后，从原接口发回邻居路由器，并将该路由的开销设置为16（即指明该路由不可达）。利用这种方式，可以快速清除对方路由表中的无用路由。</p><blockquote><p>操作步骤</p><ol><li>执行命令<strong>system-view</strong>，进入系统视图。</li><li>执行命令<strong>interface</strong> <em>interface-type</em> <em>interface-number</em>，进入接口视图。</li><li>执行命令<strong>rip poison-reverse</strong>，启动毒性反转。</li></ol></blockquote><h5 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h5><p>因为毒性反转逻辑上优于水平分割，所以即便同时配置了水平分割与毒性反转，设备也只启用毒性反转功能。</p><p>其实更治本的方案就是触发更新，所以该机制默认都会启动。（但如果专门问起RIP的防环机制是什么，对方想听到的是水平分割与毒性反转）</p><h4 id="报文类型及格式"><a href="#报文类型及格式" class="headerlink" title="报文类型及格式"></a>报文类型及格式</h4><p>RIP协议的报文采用UDP封装，报文的源端口与目的端口都是520，目的IP地址为224.0.0.9，这是一个组播地址。只有侦听该组播地址的设备在接收到该数据报文时会对其进行处理，其他设备则丢弃该报文。（本文默认只讲解RIPv2）</p><p>使用组播地址的好处就是非RIP设备无需对数据报文进行解封装看到数据内容才知道是自己不需要的，这能节约这些设备的处理资源。</p><p><strong>RIPv2的报文格式：</strong></p><ol><li><p>命令字段（Command）：该字段用于标识 RIP 报文的类型。 </p><ul><li><p>值为1时该报文为Request报文，用于向直连路由器请求全部或部分路由信息。 </p></li><li><p>值为2时该报文为Response报文，用于发送路由。该报文可以作为对Request报文的回应，也可以是路由器自主发送的，例如周期性发送路由更新或者触发性发送路由更新。 一个Response报文中最多可携带25个路由条目,当待发送的路由数量大于该值时，需使用多个Response报文。</p></li></ul></li><li><p>版本字段(Version)：在RIPv1中,该字段的值为2。 </p></li><li><p>地址族标识符(Address Family Identifier, AFI)：该字段值为2时表示IP协议。 </p><ul><li>如果该报文为Request报文并且是用于向直连路由器请求其整张路由表，则该字段值被设置为0，同时这个Request报文中包含且只包含一个路由条目，该路由的目的网络地址为 0.0.0.0，度量值为 16。（另外，这个报文的TTL值设定为1，这是为了实现只发送给直连路由器。）</li></ul></li><li><p>路由标记(Route Tag)：用于为路由设置标记信息，缺省为0。当一条外部路由被引入 RIP 从而形成一条 RIP 路由时，RIP 可以为该路由设置路由标记，当这条路由在整个 RIP 域内传播时，路由标记不会丢失。（需要人为进行配置，标记其实就是为路由起个名称）</p></li><li><p>IP 地址（IP Address）：路由的目的网络地址。</p></li><li><p>网络掩码(Netmask)：RIPv2定义了该字段用于存储路由条目的目的网络掩码，如此一来, RIPv2便能够支持VLSM(Variable Length Subnet Mask，可变长子网掩码）。</p></li><li><p>下一跳(Next Hop): RIPv2 定义了该字段，使得路由器在多路访问网络上可以避免次优路径现象。一般情况下,在路由器所发送的路由更新中，路由条目的“下一跳”字段会被设置为0.0.0.0，此时收到该路由的路由器将路由条目加载到路由表时，将路由的更新源视为到达目的网段的下一跳。在某些特殊的场景下，该字段值会被设置为非0.0.0.0，本章将在“下一跳字段”一节中介绍该字段。</p></li><li><p>度量值（Metric）：该路由的度量值。（也就是跳数）</p></li></ol><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p><strong>操作步骤：</strong></p><ol><li>执行命令<strong>system-view</strong>，进入系统视图。</li><li>执行命令<strong>rip</strong> [ <em>process-id</em> ]，创建RIP进程并进入RIP视图。（若不指定id，默认为进程1）</li><li>执行命令<strong>version</strong> <strong>2</strong>，设置RIP版本为RIP-2。 </li><li>执行命令<strong>network</strong> <em>ip-address</em>，宣告启用RIP的网段接口。</li></ol><p><strong>第四步需要按传统A、B、C类地址划分的规则去填写网络地址，且不需要填写掩码</strong></p><blockquote><p>A类网络的IP地址范围是1.0.0.0到126.0.0.0，默认子网掩码是255.0.0.0。</p><p>B类网络的IP地址范围是128.0.0.0到191.255.0.0，默认子网掩码是255.255.0.0。</p><p>C类网络的IP地址范围是192.0.0.0到223.255.255.0，默认子网掩码是255.255.255.0。</p></blockquote><p>实际上就是看点分十进制下第一位数字的大小确定属于哪一类。</p><p>切记，<strong>该命令并不是宣布网段路由，而是通知符合该网段的接口开启RIP功能，然后发布这些接口的直连路由。</strong></p><p>比如对于一台拥有10.1.1.0&#x2F;24网段的设备，输入命令时，必须写成<em><strong>network 10.0.0.0</strong></em> </p><p>但实际不会生成发布10.0.0.0&#x2F;8的路由，而是发布已存在的10.1.1.0&#x2F;24的直连路由。</p><h4 id="路由引入"><a href="#路由引入" class="headerlink" title="路由引入"></a>路由引入</h4><p>将本路由器上的其他路由信息添加进相应的RIP进程的RIP路由表中，用于在发送RIP更新报文时，将这些路由发送给RIP邻居。</p><ol><li><p>执行命令<strong>system-view</strong>，进入系统视图。</p></li><li><p>执行命令<strong>rip</strong>  <em>process-id</em> ，进入RIP视图。</p></li><li><p>（可选）执行命令<strong>default-cost</strong> <em>cost</em>，设定引入路由的缺省度量值。如果在引入路由时没有指定度量值，则使用缺省度量值。</p></li><li><p>以下命令按需求进行执行。</p><ul><li><p>执行命令<strong>import-route</strong> { <strong>static</strong> | <strong>direct</strong> | <strong>unr</strong> } ，引入静态&#x2F;直连&#x2F;用户路由；</p></li><li><p>执行命令<strong>import-route</strong>  { <strong>rip</strong> | <strong>ospf</strong> | <strong>isis</strong> } <em>process-id</em> ，引入动态路由协议指定进程号内的路由信息；</p></li><li><p>执行命令<strong>import-route</strong> <strong>bgp</strong> [ <strong>permit-ibgp</strong>  ] 引入BGP协议的路由信息；</p></li></ul></li><li><p>（可选）执行命令<strong>filter-policy</strong> { <em>acl-number</em> | <strong>acl-name</strong> <em>acl-name</em> | <strong>ip-prefix</strong> <em>ip-prefix-name</em> } <strong>export</strong> [ <em>protocol</em> [ <em>process-id</em> ] | <em>interface-type</em> <em>interface-number</em> ]，对引入的路由信息向外发布时进行过滤。</p><p>由于RIP要发布的路由信息中，有可能是引入的其他路由协议的路由信息，所以可通过指定<em>protocol</em>参数来对这些特定的路由信息进行过滤。如果没有指定<em>protocol</em>参数，则对所有要发布的路由信息进行过滤，包括引入的路由和本地RIP路由（相当于直连路由）。</p></li></ol><blockquote><p>路由引入的写法在其他动态路由协议中也基本如此，届时会详细举案例说明。</p></blockquote><h4 id="配置RIP发布缺省路由"><a href="#配置RIP发布缺省路由" class="headerlink" title="配置RIP发布缺省路由"></a>配置RIP发布缺省路由</h4><p>在路由表中，缺省路由以到网络0.0.0.0（掩码也为0.0.0.0）的路由形式出现。当报文的目的地址不能与路由表的任何目的地址相匹配时，设备将选取缺省路由转发该报文。 </p><p>操作步骤</p><ol><li>执行命令<strong>system-view</strong>，进入系统视图。</li><li>执行命令<strong>rip</strong> [ <em>process-id</em> ]，进入RIP视图。</li><li>执行命令<strong>default-route originate</strong>，将存在的缺省路由引入到RIP路由表中，并将缺省路由发送给邻居。</li></ol><h4 id="静默端口Silent-interface"><a href="#静默端口Silent-interface" class="headerlink" title="静默端口Silent-interface"></a>静默端口Silent-interface</h4><p>虽然RIPv2使用组播地址进行RIP报文的发送，这减少了对非RIP设备的影响。但这些报文在对端非RIP设备的链路上占用的网络资源却没有变化。</p><p>将对端都是非RIP设备的路由器接口设置为Silent-interface接口，可以让路由器不在该接口发送RIP报文，从而减少对网络资源的占用。</p><p>操作步骤</p><ol><li>执行命令<strong>system-view</strong>，进入系统视图。</li><li>执行命令<strong>rip</strong> [ <em>process-id</em> ]，进入RIP视图。</li><li>执行命令<strong>silent-interface</strong> <em>interface-type</em> <em>interface-number</em>，禁止指定接口发送更新报文。</li></ol><h1 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h1><p>本来想讲一下RIP与BFD的联动，但最终还是觉得对于过时的技术没必要花太多精力，未来还会被ospf全面替代。（最新版的华为认证考试甚至删除了RIP协议）</p><p>另外还有RIP的禁止发送&#x2F;接收更新报文，修改定时器&#x2F;跳数，路由过滤等配置，这部分建议看华为官网的技术文档，配置很简单的（但没有学习的意义，以后真要用了，知道会有这个东西就够了）</p><p>实际工作中，用最多的，其实是静态路由，除非专门干大型网络搭建的。</p><p>目前国内已经不是互联网的拓张建设时期了，是处于维护阶段。</p><p>可能会对单台设备进行更新，重新进行配置，但不会对整个网络架构进行大刀阔斧的改动。</p><p>学会分析案例、排除故障才是最重要的。</p><p>我认为，学习这些网络知识、协议原理、配置命令是为了做一次扫盲，去构建一个知识体系。</p><p>你不需要精通熟记，但你要能在故障排查过程中回想起这些点，再就着这些点去试探检验。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 路由 </tag>
            
            <tag> 静态路由 </tag>
            
            <tag> RIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文字的失真——人际交往中的语言冲突</title>
      <link href="/2024/01/11/%E6%96%87%E5%AD%97%E7%9A%84%E5%A4%B1%E7%9C%9F/"/>
      <url>/2024/01/11/%E6%96%87%E5%AD%97%E7%9A%84%E5%A4%B1%E7%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="信息与媒介"><a href="#信息与媒介" class="headerlink" title="信息与媒介"></a>信息与媒介</h1><p><strong>媒介承载的信息都是失真的信息。</strong></p><p>这是一个很浅显的道理，本文不打算长篇大论去论证，因为本文重点不在于此。</p><blockquote><p>有兴趣可以去看看歌曲等音频文件的采样率与比特率的科普。<br>同样的，还有视频的分辨率、帧数、码率等等参数的含义科普。</p></blockquote><p>在同意该观点的前提下，我们来具体讨论一下文字这一媒介。</p><p>另外，信息所对应的具体含义是脑子中的内容(包含立体图像、知识、想法、思路、逻辑等等)(本文后续提及的“想法”一词就包含这一些)</p><h1 id="文字的形成"><a href="#文字的形成" class="headerlink" title="文字的形成"></a>文字的形成</h1><p>我们需要先讨论一个“先有鸡还是先有蛋”的问题。</p><p>文字，具体一点，一个词；其所代表的含义是先有这个词了才有这种含义，还是先有这种含义才出现了这个词？</p><p>是脑子里先有了内容，才创造了对应的词，这样没错吧。</p><p>早期，人们脑子里有了内容，想表达出来，才创造出来象形字，以此来表达某一个事或物。</p><p>遇到了没见过的事物，就再创造文字来表示。</p><blockquote><p>而部分迷信&#x2F;宗教类相关的词汇就是遇到了没见过且无法解释的事物，又需要表达出来才创造的。（妖魔鬼怪、神仙上帝、中医的部分词汇）</p></blockquote><p>文字就是被慢慢创造出来的，甚至到了现代，遇到新鲜的舶来品&#x2F;新技术等，我们也得创造新词汇来指代。<br>(咖啡，沙发，芝士，电脑，电话，手机)</p><p>此外还有一些抽象的概念，抽象的信息，例如一些疾病、心理、思想。</p><p>它们是一直存在的，后来才开始创造词汇表示它们。(老年痴呆症，抑郁症，虚无主义，唯物主义)</p><p>总之就是目前还找不到词汇来代指的，我们才开始创造出对应的文字来表示。<br>另外这个词汇被广泛认知还需要一段很长的时间。<br><strong>文字的形成就是如此，文字所能表示的信息也远远不及脑海中的冰山一角。</strong></p><h1 id="失真的文字所带来的冲击"><a href="#失真的文字所带来的冲击" class="headerlink" title="失真的文字所带来的冲击"></a>失真的文字所带来的冲击</h1><p>接下来就是本文所重点讨论的内容了。</p><p>我之前在网上看到一个求推荐床垫的帖子。底下有人回复“席梦思”，而这条言论被另外一个网友抨击为不结合实际，乱推奢侈品，甚至上升到对人品的攻击。</p><blockquote><p>席梦思牌的床垫近万元</p></blockquote><p>最后才解释清楚，第一位评论说的“席梦思”是表示弹簧床垫这一品类，而那位抨击者以为是“席梦思”品牌的床垫产品。</p><p>这是同一个词在不同人眼中意思不同导致的冲突。</p><p>此外还有数码圈经典的“华为口”，很多人将type-c接口称为华为口(大部分人是因为其第一次接触到type-c接口是在华为手机上)<br>当一方因为这情况称type-c为华为口时，对方可能会有几种解读。</p><ol><li>就是单纯的不知道是在说type-c，花费时间沟通后才知道是指type-c（然后转到以下选项）</li><li>知道，但理解，也不做其他的反应</li><li>知道且纠正对方。(纠正过程也有可能引起别的冲突)</li><li>知道且鄙视对方，认为对方没文化&#x2F;脑残华为粉(可能表现为第二种，也可能表现为第三种，甚至可能直接吵起来)</li></ol><p>这是一个词汇未被广泛熟知，导致同一个物品有不同词汇代指导致的冲突。</p><p><strong>某种意义上来说，网络上的冲突，很大一部分都是因为文字表达不准确导致的。</strong></p><blockquote><p>不止刚刚提到的这种词汇含义混淆的现象。</p></blockquote><p>还有一种常见的就是词汇被部分人赋予了其他含义。<br>先不提被赋予了地域歧视、种族歧视的词汇。<br>现在很多词汇被用于阴阳怪气后，导致词汇本身对了解其阴阳属性的人来说显得很扎眼。<br>(呵呵，不会吧，6，圣母)</p><p>最后出现“说者无意，听者有心”的现象。</p><h1 id="想法塞不进文字里"><a href="#想法塞不进文字里" class="headerlink" title="想法塞不进文字里"></a>想法塞不进文字里</h1><p>归根到底，很多时候，我们都无法将自己脑海里的东西塞到一段文字里。</p><p>这不仅是文字本身承载的信息失真，还有可能是我们无法使用好文字，或者说我们无法将自己想法尽可能不丢失太多信息的塞进文字里。</p><p>大部分人都亲身遇到过老师专业知识很扎实，水平很高；但他讲课就是很差，经常听不懂。</p><p>也会遇到过明明自己有理，但是争论的时候却说不清，常常事后第二天才想明白要怎么语言反击。</p><p>更多的时候是要描述一个东西或者一件事，就是跟人说不清。</p><h1 id="认知决定言论"><a href="#认知决定言论" class="headerlink" title="认知决定言论"></a>认知决定言论</h1><p>基于文字的形成，一个想法被表达出来需要一个词汇对应，可如果一个人没有对这个词汇的认知，那他就无法准确表达出来。反过来，他也无法理解别人所表达的意思。<br>例子就是我们学习专业知识的过程。</p><blockquote><p>我还是举一个吧，以前在玩桥梁建筑师游戏时，都会搭多个三角形的结构。但我一直不知道怎么表达，后来才知道到在土木工程专业中，这叫做桁架结构。<br>反过来，我去找个人说搭个桁架，那他也听不明白</p></blockquote><h1 id="有趣但又不有趣的现象"><a href="#有趣但又不有趣的现象" class="headerlink" title="有趣但又不有趣的现象"></a>有趣但又不有趣的现象</h1><p>以下这些我就不举例子了，如果经常上网的话，都见过不少了。</p><h2 id="叠甲"><a href="#叠甲" class="headerlink" title="叠甲"></a>叠甲</h2><p>现在很多人发表言论时，为了避免被错误解读、过度解读，都会进行特别说明，进行“叠甲”，防止被攻击。</p><h2 id="语言艺术"><a href="#语言艺术" class="headerlink" title="语言艺术"></a>语言艺术</h2><p>以言论被过度解读为前提对文字进行加工。</p><blockquote><p>我不会→我可以学<br>我不知道→我研究一下</p></blockquote><h2 id="“我不是说了吗”"><a href="#“我不是说了吗”" class="headerlink" title="“我不是说了吗”"></a>“我不是说了吗”</h2><p>有的人文字提炼能力低(从想法到文字的转换)而<strong>不自知</strong>。<br>常常脑子里过了一边，然后表达出的文字信息量却很低且缺少很大部分，但他又认为自己明确完整的把自己脑子里的东西转达给别人了。</p><h2 id="跨频道聊天"><a href="#跨频道聊天" class="headerlink" title="跨频道聊天"></a>跨频道聊天</h2><p>双方交流不在一个点，一个频道上。</p><h2 id="你就是这个意思吧"><a href="#你就是这个意思吧" class="headerlink" title="你就是这个意思吧"></a>你就是这个意思吧</h2><p>自己先误解对方言论，然后在这个误解的情况下去“反击”。（也是因此才有了“叠甲”）</p><blockquote><p>“你还真是高高在上呢”也是基于这种思路才导致的误解。</p></blockquote><p>不过我们习惯称发言者是不太会说话&#x2F;话没说好。</p><blockquote><p>非要分对错，那就是都有错，或者说都没错。</p></blockquote><h2 id="各种方言-语种的词汇差异"><a href="#各种方言-语种的词汇差异" class="headerlink" title="各种方言&#x2F;语种的词汇差异"></a>各种方言&#x2F;语种的词汇差异</h2><p>基于“文字的形成”，注定了各种语言之间对某一事物是否有词汇表示并不统一。<br>可能在中文里的某个词，在英语中找不到一个准确的单词来表示。<br>相反的，其他语言翻译成中文，也会存在找不到准确的词汇的情况。<br>这就是很多国外书籍的译本被评价为不如看原文的原因。</p><h1 id="接下来是偏主观的内容"><a href="#接下来是偏主观的内容" class="headerlink" title="接下来是偏主观的内容"></a>接下来是偏主观的内容</h1><p>我在日常中经常遇到上一节的“我不是说了吗”这种类型的人，哈哈，这个分类名就带有我的怨气了，没少被这类人的这句话隔应。<br>尤其是在工作中，对方总以为他交代清楚了，最后你没做到或者你过段时间去问他，他就开始发脾气&#x2F;教训你。</p><p><strong>这个世界上很多人都是善良的，正所谓人之初、性本善。</strong><br><strong>但因为文字的不准确性与个人语言匮乏的原因，才导致了很多冲突。</strong></p><p>我在看别人的言论时，常常会尽可能客观的琢磨背后的真实含义。<br>我发表言论时，也力求发言准确&#x2F;不引起误解，同时不以揣测后的信息去攻击对方。(其实我一般也不会攻击人)<br>有时我不确定对方的真实想法，在我打算与对方好好交流的时候，我就会追问确认。</p><blockquote><p>在此解释一下，本文的“想法”可以包含脑海里的所有内容</p></blockquote><p>举个例子<br>我出过几个故障处理的教程，因此有不少人来找我询问。<br>有次，被人直接问“我也有这个情况，请问要怎么弄，教程我看不明白”。<br>我就会去问“哪里看不懂，你怎么操作的，你做了哪些尝试，都提示的什么，你用的什么设备什么工具什么软件”。</p><blockquote><p>我想不少人遇到这种事就会血压上升，“明明录了视频、写了教程，怎么就看不明白了，也不说是哪”。</p></blockquote><p>再举一个<br>我以前也出过游戏视频，有次我收到一条回复“dlc好费钱啊”<br>我第一反应是去steam查了dlc的价格，也就20元(游戏本体60元，dlc内容挺丰富的)。<br>说实话，查完价格后，我皱了眉头，不太理解，还有点小火气。<br>但我还是在聊天框输入了“还行吧，dlc内容挺丰富的，包含几个大地图还有好多道具跟材料。20元不算贵，从一周的饭钱里稍微抠抠也还是能攒出来的。”<br>不过，敲完这段还没点发送的时候，我就想明白了。“好费钱”应该是好费游戏里的金币，dlc里新增了很多道具跟皮肤，全收集的话需要很多游戏金币。后来就这个方向去回复交流也证实了是这个意思。</p><blockquote><p>我也叠个甲。这里是建立在去购买了正版游戏本体了，本体要60多。<br>如果都能花60多买本体了，20买一个增加大量游戏内容的dlc还嫌贵的话，我是不太理解了。</p></blockquote><p>基于“认知决定言论”，我与人沟通时总会默认对方不理解专业术语的意思，尽量用大白话解释一下。</p><blockquote><p>我最近这份工作的经理就常用他熟悉的词汇，而且跟我说事情都是打电话说一下就挂断，我没少被整迷糊。<br>经常需要细细回味经理是在说什么。印象最深的一次是“拉爆”，其实就是爆炸螺丝。</p></blockquote><p>另外，这个理论还可能体现为不理解无法说明的情况下导致“胡言乱语”。<br>干售后维修的，有句话叫做“客户的话不能全信”。</p><p>再从“客户的话不能全信”这句话开始延伸一下。<br>如果有人找我咨询故障，我都会让对方详细说明一下，另外附一下图，最好是有视频。</p><p>反过来，我去找同事、上级沟通问题的时候我自己也会准备好详细的文字与图片材料。<br>同样的，如果我要找厂家售后维修，我也会这么操作，甚至我会说我做过什么尝试了。<br>(一方面方便对面判断故障，另一方面省的对方让我去做尝试，这样能节省大家时间)</p><h1 id="学习时请勿抠字眼"><a href="#学习时请勿抠字眼" class="headerlink" title="学习时请勿抠字眼"></a>学习时请勿抠字眼</h1><p>这件事很重要，所以单独拉出来讲。(不过并不是很契合本文主题)（“学习”这两个字的范围可以扩大一些）</p><p>我见过不少人学习专业知识的时候，对着文档里的某一句话死磕，一直纠结为什么那句话要这么说。</p><p>哪怕我给他解答了意思，也说明了歧义的点，说文档写的不是很严谨。</p><p>但过了一天，我又被这个人就这这个问题缠着问。</p><p><strong>请记住，你是来学习的，重点是整体的知识内容，不是具体的某一句话。</strong></p><p>说难听点，书就完全没错了？出版书不还经常出修订版。而且很多事并不是非黑即白，你根本不能强求一个确定的答案。</p><blockquote><p>比喻一下。一处景点的柱子是米白色的。A写了段文字描写这个景点，其中写到柱子时用的形容词是“浅黄色”。B也参观了这个景点，他描述为白色的柱子。<br>有位网友看了这两段旅游介绍后迷糊了，他就纠结啊纠结，饭都吃不好，旅游也不想去了，到处问、到处找其他人的指南看，就想知道这个柱子到底是浅黄色还是白色。</p></blockquote><blockquote><p>举个正常的例子：练字，有的人一直在纠结握笔姿势，怎么握才对啊？我怎么用着用着又变回去了？<br>你是来练字的，先练了字再说，握笔姿势不重要，有的人用脚都能写好看，你握笔姿势不是所谓的标准姿势重要吗？<br>(重点是对笔的掌控，对笔画跟结构的理解)</p></blockquote><p><strong>同样的，阅读文本时，请记住，要关心的是文本编写者要传达的主要想法，而不要去抠他的某句话某段话。</strong><br>哪怕他哪句话写的不和你意，但又如何，你只需要注意他的核心思想。</p><blockquote><p>我前段时间看一个数码爱好者想说明“便宜的东西并不是性价比高的东西，反而是中端产品，因为各大厂商竞争内卷，买到性价比高的东西几率更大”。<br>但他全文没有这么写出来，而是简单的论证为100元买的东西、可能成本是30；而300买的、成本可能是250。<br>结果导致很多人以为这位爱好者是在鼓吹中端产品，一棒子打死低端产品。</p></blockquote><h1 id="纯粹私货时间"><a href="#纯粹私货时间" class="headerlink" title="纯粹私货时间"></a>纯粹私货时间</h1><p>年纪越大，越对与人沟通这件事感到心累。<br>我发言如此小心、细致、认真，但还是有被人无视的时候。</p><blockquote><p>比较常见的是去找厂家报修，整理了故障情况说明，视频实录，我尝试过的操作，我验证过确定没问题的内容(也带图片)。<br>结果对方回复过来的内容就是让我去重复我早做过的事，车轱辘来回扯，也再操作一遍并发图过去，花了一个多小时才回到开头。</p></blockquote><p>也有就是前面说的，遇到对某一句话死磕的人。遇到这类人花时间替他解答，可能过段时间他又蒙了，又来找你。</p><blockquote><p>我之前在一个群聊里花了2个小时给一个人解答问题，同时我建议他去看一下正统出版的专业书，别光看别人的文档。<br>到了第2天，他截图了一张我也不知道什么书的，反正就光秃秃的一句话，又来接着问。<br>后来第四天，第七天都来，都是同一个问题，他就是纠结，必须弄明白。</p></blockquote><p>还有就是会因为一个词或者一句话，被抓住输出。</p><blockquote><p>印象深刻的是在工厂，设备生产的时候，回收罐原料溢出到地上。<br>（介绍一下，是有个类似泄压阀功能的三通阀，压力过高就转回料管到回收罐，泄压后需要手动把阀门调过去。）<br>原料溢出后，我紧急调低了设备单位时间工作效率，同时找人去回收溢出的原料，另外瞟了瞟姑且确实故障原因。<br>（不是要紧事就不停机，启停一次消耗很大）<br>就在我拿好工具准备也过去收拾原料的时候主管过来询问。<br>我就说了情况，还有“应该是管道还有在往回料罐打，那个阀门不到位”。<br>说完这句话主管就冒火了，“应该？不要说什么应该，是就是，不是就不是，不要提什么应该。你也别整天看手机看手机，这就是没手动调回阀门才漏的料吧”一顿骂。<br>直到前面那个被我叫过去收拾原料的同事大喊那边还在漏(还有料往回收罐打)，主管这才闭嘴。<br>最后设备停机，拆开才确定就是三通阀的密封圈变形，导致虽然走的主管道，但还是有一部分原料往回收管道过去了。<br>这是我毕业那年去工厂遇到的事，类似的还有两次，加上当时工厂车间环境差，食宿条件也不好就跑路了。</p></blockquote><p>当社畜后，在工作中遇到这类事越多，就越对交流感觉厌烦。以至于我越来越少去当群聊和事佬，萌新的热心大佬。</p><p>现在有人来询问问题，我分享自己的知识见解时，如果对方看起来没怎么在听也会变得很毛燥很火大。</p><blockquote><p>唉、如果要分享知识，还是写文章好了，对方爱看不看，看了后懂还是不懂都不去管。<br><strong>说到底，这其实都是对方自己的事，<em>我又没收钱。</em></strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 个人杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三观 </tag>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【生成树协议】STP、RSTP</title>
      <link href="/2024/01/03/%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AE%E4%B9%8BSTP%E4%B8%8ERSTP/"/>
      <url>/2024/01/03/%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AE%E4%B9%8BSTP%E4%B8%8ERSTP/</url>
      
        <content type="html"><![CDATA[<h1 id="STP（生成树协议）"><a href="#STP（生成树协议）" class="headerlink" title="STP（生成树协议）"></a>STP（生成树协议）</h1><p>以太网交换网络中为了进行链路备份，提高网络可靠性，通常会使用冗余链路。</p><p>但是使用冗余链路会在交换网络上产生环路，引发广播风暴以及MAC地址表不稳定等故障现象，从而导致用户通信质量较差，甚至通信中断。</p><p>为解决交换网络中的环路问题，提出了生成树协议STP（Spanning Tree Protocol）。</p><p><strong>运行STP协议的设备通过彼此交互信息发现网络中的环路，并有选择的对某个接口进行阻塞，最终将环形网络结构修剪成无环路的树形网络结构。</strong></p><blockquote><p>对于聚合的链路，其在实际作用中已经成为单条链路了，所以STP并不感知，也就不会阻塞管控。</p></blockquote><p>STP是一个成熟的自动化协议，在交换设备上开启STP功能（<strong>stp enable</strong>）即可做到防止环路，无需再做任何配置。</p><p>甚至对于大部分可stp的设备来说，都<strong>默认开启了stp功能的</strong>。因此我们的目标是学习STP是如何实现防环的。</p><blockquote><p>也还是有一些可配置的东西的，主要是用来修改什么链路被阻塞。不修改也没关系，只是链路不是最优的而已，并不影响通信。</p></blockquote><h2 id="STP的基础概念"><a href="#STP的基础概念" class="headerlink" title="STP的基础概念"></a>STP的基础概念</h2><p>在此之前，我们需要先理解几个概念。</p><p>请先全部看完，不要就某一点死磕，要合在一起才能理解透。</p><h3 id="BPDU（Bridge-Protocol-Data-Unit）"><a href="#BPDU（Bridge-Protocol-Data-Unit）" class="headerlink" title="BPDU（Bridge Protocol Data Unit）"></a>BPDU（Bridge Protocol Data Unit）</h3><p>STP协议中的数据单元，用于在网络中传递信息并计算最佳路径。(类似于vlan技术的vlan标签那种作用，不过BPDU是一个完整的数据包)</p><p>BPDU包含以下重要信息：</p><ol><li>源MAC地址：BPDU的发送者的MAC地址。</li><li>目的MAC地址：BPDU的接收者的MAC地址。</li><li>源优先级（Priority）：用于确定根桥（Root Bridge）的优先级。</li><li>源根标识（Root Identifier）：用于标识根桥的MAC地址和优先级。</li><li>发送端口标识（Port Identifier）：用于标识发送BPDU的端口。</li><li>路径开销（Path Cost）：用于计算到达根桥的路径开销。</li><li>BPDU类型：用于标识BPDU的类型，一共有两种：<em>配置BPDU</em> 、<em>拓扑更改通知BPDU</em>。</li></ol><p><strong>STP通过在网络中传递BPDU来建立一个拓扑树，选择一个根桥，并禁用一些端口以防止环路。</strong></p><p>设备通过<em>配置BPDU</em>比较优先级、根标识、路径开销等信息来确定最佳路径，并选择根桥。</p><p><strong>当网络中发生拓扑变化时，如链路故障或端口状态改变，STP会生成并发送<em>拓扑更改通知BPDU</em>，通知其他设备进行拓扑重计算。</strong></p><p>这样，网络中的所有设备都能保持一个无环的拓扑结构，确保数据包的正常传输。</p><blockquote><p>BPDU是通过组播的方式进行转发的，其组播地址为 <code>01:80:C2:00:00:00</code>。</p></blockquote><h3 id="根桥（Root-Bridge）"><a href="#根桥（Root-Bridge）" class="headerlink" title="根桥（Root Bridge）"></a>根桥（Root Bridge）</h3><p>树形的网络结构必须有树根，于是STP引入了根桥的概念。根桥是在使用STP协议的网络中，被选为拓扑树根节点的交换机。</p><p>对于一个STP网络，根桥在全网中只有一个，它是整个网络的逻辑中心，但不一定是物理中心。</p><p><strong>根桥是网络中所有交换机的参考点，用于计算最佳路径和防止环路。</strong></p><p>根桥会根据网络拓扑的变化而动态变化。根桥的选择是通过比较交换机的优先级（Priority）来确定的。</p><p><strong>每个交换机都有一个默认的优先级值，通常是32768。优先级值越低，交换机被选为根桥的概率越大。</strong></p><p>如果优先级相同，则比较交换机的MAC地址，MAC地址较小的交换机将成为根桥。</p><blockquote><p>具体来说，是通过比较***BID (Bridge ID)**<em>来确定根桥的，其值为</em>优先级 + mac地址*。</p><p>一般都不会修改设备的mac地址，所以人为的修改根桥是通过修改优先级（默认32768的那个）来实现的。</p></blockquote><p>根桥的作用是：</p><ol><li><p><strong>确定最佳路径</strong>：根桥作为拓扑树的根节点，它决定了数据包在网络中的传输路径。其他交换机通过比较路径开销（Path Cost）选择到达根桥的最佳路径。路径开销是通过每个链路的速度来计算的，速度越快，路径开销越低，被选为最佳路径的概率越大。</p></li><li><p><strong>防止环路</strong>：根桥通过发送BPDU（Bridge Protocol Data Unit）来通知其他交换机网络的拓扑结构。交换机根据接收到的BPDU信息进行拓扑计算，并禁用一些端口以防止环路的发生。这样，根桥确保网络中没有冗余的链路，避免了数据包在网络中无限循环的问题。</p></li></ol><p>根桥是STP协议中的一个重要概念，它的选择对网络的性能和稳定性有着重要影响。</p><p>在一个网络中，只有一个交换机能够成为根桥，其他交换机都将根据根桥的信息进行拓扑计算和路径选择。</p><h3 id="路径开销（Path-Cost）"><a href="#路径开销（Path-Cost）" class="headerlink" title="路径开销（Path Cost）"></a>路径开销（Path Cost）</h3><p>STP中的路径开销（Path Cost）是用于计算到达根桥的路径代价的指标（类似于耗时、延迟）。</p><p><strong>路径开销是基于链路的速度来计算的，速度越快，路径开销越低，被选为最佳路径的概率越大。</strong></p><p>在STP中，每个链路都有一个默认的路径开销值，这个值根据链路的速度来确定。</p><blockquote><p>以下是两种标准下链路速度和对应的默认路径开销值：</p><table><thead><tr><th>链路速度</th><th>IEEE 802.1D-1998</th><th>IEEE 802.1T</th></tr></thead><tbody><tr><td>10 Mbps</td><td>100</td><td>200000</td></tr><tr><td>100 Mbps</td><td>19</td><td>20000</td></tr><tr><td>1 Gbps</td><td>4</td><td>2000</td></tr><tr><td>10 Gbps</td><td>2</td><td>200</td></tr></tbody></table><p>不同厂商的设备默认使用的标准可能不同，但可进行切换。华为还有一个自己私有的计算方式，不过还好默认的是IEEE 802.1T。</p></blockquote><p>路径开销的计算是通过将链路上的路径开销值相加来完成的。</p><p><strong>当STP计算最佳路径时，会比较到达根桥的不同路径的路径开销。</strong></p><p><strong>路径开销较小的路径（也就是速度最快的路径）将被选为最佳路径，数据包将通过该路径传输</strong>。</p><p>选择最佳路径，是为了确保数据包在网络中的传输效率和稳定性，这样可以避免数据包在网络中出现拥塞或延迟的问题。</p><p>路径开销是STP协议中的一个重要概念，它与拓扑计算密切相关，确保网络中的数据包能够以最佳路径传输，同时避免环路的发生。</p><h3 id="根端口（Root-Port）和指定端口（Designated-Port）"><a href="#根端口（Root-Port）和指定端口（Designated-Port）" class="headerlink" title="根端口（Root Port）和指定端口（Designated Port）"></a>根端口（Root Port）和指定端口（Designated Port）</h3><p>在STP中，根端口和指定端口是两种不同类型的端口，用于建立拓扑树并选择最佳路径。</p><ol><li><p>根端口（Root Port）：根端口是指每个非根桥上与根桥相连的端口，根端口负责与根桥进行通信。每个非根桥都会选择一个且仅一个根端口，<strong>该端口提供了到达根桥的最佳路径。</strong></p></li><li><p>指定端口（Designated Port）：指定端口是指在<strong>每个链路上被选为传输BPDU的端口。</strong>指定端口是从每个交换机上与相邻交换机连接的端口中选择出的。</p></li></ol><p><strong>根端口和指定端口的选择是通过STP协议中的BPDU交换来完成的。交换机通过比较BPDU中的路径开销和优先级等信息，选择最佳的根端口和指定端口，以确保数据包在网络中的传输路径是无环且最优的。</strong></p><p>根端口和指定端口是STP协议中的关键概念，它们的选择和配置对于网络的性能和稳定性非常重要。通过选择最佳的根端口和指定端口，STP协议能够建立一个无环的拓扑树，并提供最佳的数据包传输路径。</p><p><strong>可以简单理解不是根端口的都为指定端口，而如果一条链路两端都是指定端口(环路)，那么其中一个必须成为阻塞端口，根据优先级阻塞其中一个。</strong></p><blockquote><p>请记住，<strong>STP的核心是消除环路</strong>，其次才是确定最佳路径。</p><p><strong>根端口是用来接收根桥发来的BPDU，指定端口是用来转发BPDU给其他交换机。</strong></p><p>优先级不只是开销，因为存在开销一样的情况，后面会具体学习优先级的相关内容。</p></blockquote><h2 id="STP原理"><a href="#STP原理" class="headerlink" title="STP原理"></a>STP原理</h2><h3 id="启用到稳定阶段"><a href="#启用到稳定阶段" class="headerlink" title="启用到稳定阶段"></a>启用到稳定阶段</h3><p>先放一张最终图理解一下上面介绍的概念。</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/ffd3db0ec56b34897011b.png" alt="图1——STP接口"></p><p>如图，交换1为根桥，链路都为同一速率，所以交换机2、交换机3与交换机1相连的接口都为根端口。</p><p>交换机4左侧的端口到达交换1的优先级最高选为根端口。</p><p>其他剩下的链路为指定端口，其中有两条链路，两侧都为指定端口，再判断哪个端口优先级高，将低的阻塞掉。</p><p>最后拓扑就被修剪为树状了，达到了避免环路的目的。</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/aed1e6d5a664d8697ec45.png" alt="图2——修剪为树状拓扑"></p><p>同时，被阻塞的链路在目前被选中的最佳路径链路断开时能够自动启用，成为新的最佳链路，完成链路冗余的目的。</p><p>达成这个过程，依靠的就是交换机之间发送的BPDU包，设备的接口从加入到稳定一共会经过以下5个阶段。</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/184939c74fdba4c36aae2.png" alt="图3——STP接口状态"></p><table><thead><tr><th>端口状态</th><th>目的</th><th>说明</th></tr></thead><tbody><tr><td>Disabled</td><td>端口不仅不处理BPDU报文，也不转发用户流量。</td><td>端口状态为Down。</td></tr><tr><td>Listening</td><td>确定端口角色，将选举出根桥、根端口和指定端口。不转发用户流量。</td><td>过渡状态，持续15秒。</td></tr><tr><td>Learning</td><td>设备会根据收到的用户流量构建MAC地址表，但不转发用户流量。</td><td>过渡状态，持续15秒。增加Learning状态防止临时环路。</td></tr><tr><td>Forwarding</td><td>端口既转发用户流量也处理BPDU报文。</td><td>只有根端口或指定端口才能进入Forwarding状态。</td></tr><tr><td>Blocking</td><td>端口仅仅接收并处理BPDU，不转发用户流量。</td><td>阻塞端口的最终状态。</td></tr></tbody></table><p><strong>网络中所有的设备启动STP协议后，每一台设备都认为自己是根桥。</strong></p><p>此时，每台设备仅仅收发<em>配置BPDU</em>，而不转发用户流量，所有的端口都处于Listening状态。</p><p>所有设备通过交换<em>配置BPDU后</em>，进行选举工作，选出根桥、根端口和指定端口。</p><p>这就是STP的启动到稳定过程，这个过程常被称为“<strong>收敛</strong>”。</p><p><strong>该过程中用户流量无法传输，呈现为断网状态，一般收敛时间至少需要30秒</strong>（Listening状态与Learning状态的总耗时）。</p><blockquote><p>在稳定的状态下，发送链路变化时，也需要端口经过状态的切换，因此也需要至少30秒的时间。</p></blockquote><h3 id="稳定后的维护阶段"><a href="#稳定后的维护阶段" class="headerlink" title="稳定后的维护阶段"></a>稳定后的维护阶段</h3><p>一般STP稳定之后，根桥会周期性的发布BPDU以维护STP状态（默认2秒一次），其他设备只接收并转发该BPDU。</p><p>网络中发生拓扑变化时，例如链路中断或接口异常Down等情况，由于MAC地址的老化时间的存在（老化是指“过期”，时间默认为5分钟，超过该时间未更新就会删除交换mac地址表内的该mac信息）。</p><p>如果不及时通知上游设备，则可能会导致上游设备的报文在这段时间内一直向一个不可达的链路发送。</p><p>这样就可能导致流量的丢失，此时就需要拓扑变化机制来将拓扑的变更及时通知到整个STP网络。</p><blockquote><p>使用ensp模拟器的话就可能会出现这个bug，链路变动后，交换机的mac地址表却未随着变动，导致通信失败。</p></blockquote><p>TCN BPDU（Topology Change Notification Bridge Protocol Data Unit，拓扑更改通知BPDU）是一种特殊类型的BPDU报文，用于通知网络中的其他设备发生了拓扑变化。</p><p><strong>当网络中的拓扑发生变化，比如链路故障或端口状态改变时，交换机会生成并发送TCN BPDU报文。</strong>TCN BPDU报文的目的是通知其他设备进行拓扑重计算，以便更新拓扑树并选择新的最佳路径，<strong>同时将MAC地址老化时间暂时改为15秒，适应拓扑变。</strong></p><p>TCN BPDU报文的发送和接收是STP协议中的重要机制，它确保网络中的所有设备能够及时感知到拓扑变化，并相应地调整拓扑树和路径选择，以保持网络的稳定性和高可用性。</p><p>TCN BPDU报文的触发过程：</p><ol><li><p>当交换设备的接口发生变更后，下游设备会不间断地向上游设备发送TCN BPDU报文。</p></li><li><p>上游设备收到下游设备发来的TCN BPDU报文后，只有指定端口处理TCN BPDU报文。其它端口也有可能收到TCN BPDU报文，但不会处理。（指定端口为最靠近根桥的端口）</p></li><li><p>上游设备会把<em>配置BPDU</em>报文中的Flags的TC位和TCA位同时置1，然后发送给下游设备，</p><p>TC位置1是为了通知下游设备直接删除桥MAC地址表项，TCA位置1是为了通知下游设备停止发送TCN BPDU报文。</p></li><li><p>上游设备复制一份TCN BPDU报文，向根桥方向发送。</p></li><li><p>重复步骤1、2、3、4，<strong>直到根桥收到TCN BPDU报文</strong>。</p></li></ol><blockquote><p>置位的TC标记的配置BPDU报文主要是上游设备用来告知下游设备拓扑发生变化，请下游设备直接删除桥MAC地址表项，从而达到快速收敛的目的。</p></blockquote><h3 id="选举优先级"><a href="#选举优先级" class="headerlink" title="选举优先级"></a>选举优先级</h3><h4 id="根桥的选举"><a href="#根桥的选举" class="headerlink" title="根桥的选举"></a>根桥的选举</h4><p>设备开启阶段，所有设备都会认为自己是根桥，在发送的配置BPDU中，将根桥项目填写为自己的mac。</p><p><strong>交换机之间彼此收发配置BPDU，比较收到的包中根桥优先级与自己优先级的差距。</strong></p><p>( <strong>选举根桥的BID＝优先级＋mac地址；默认优先级为32768，越小越优先。</strong>)</p><p>自身BID低，就不再主动发布根桥为自己的<em>配置BPDU</em>包了。</p><p>转而开始转发其认可为根桥的BPDU包，同时也填入了其到根桥的开销。例如：</p><blockquote><p>Root Identifier: 32768 &#x2F; 0 &#x2F; 4c:1f:cc:07:3f:df</p><p>Root Path Cost: 20000</p><p>Bridge Identifier: 32768 &#x2F; 0 &#x2F; 4c:1f:cc:16:72:7b</p></blockquote><p>第三行为交换机自己的BID。</p><p>最终，当只剩下一台设备在自发性的产生并发布BPDU，其他设备只转发该BPDU，根桥的选举也就结束了。</p><h4 id="根端口的选举"><a href="#根端口的选举" class="headerlink" title="根端口的选举"></a>根端口的选举</h4><p>根桥确定后，就开始选举根端口，根端口是到达根桥的最佳路径所在的接口。</p><p>优先级为：开销》对端BID（包括mac）》对端PID》本端PID</p><p>一个一个讲，请注意，现在是在选举<strong>一台交换机</strong>上的哪个端口为根端口。</p><h5 id="开销"><a href="#开销" class="headerlink" title="开销"></a>开销</h5><p><strong>收到的BPDU中，包含了Root Path Cost这一项表示到根桥的总开销，但这个BPDU是由上级交换机生成发送过来的，因此是上级交换机到根桥的开销。</strong></p><p><strong>所以要计算本端交换机端口到到根桥的开销，还得再加上与上级交换机所在链路的开销值。</strong></p><p>开销越小的越优先。</p><h5 id="对端BID"><a href="#对端BID" class="headerlink" title="对端BID"></a>对端BID</h5><p>当端口到根桥的开销值一样时，就开始比较对端设备的BID。（也就是比较收到的两个BPDU中的BID值）</p><p>哪个端口的上级交换机的BID更优先，就采用哪个端口作为根端口。</p><h5 id="对端PID"><a href="#对端PID" class="headerlink" title="对端PID"></a>对端PID</h5><p>如果对端都是同一个交换机，就开始比较PID（PID＝接口优先级+接口编号）。</p><p>接口优先级默认为128，而接口编号就是查看交换机接口信息时从上到下的顺序。（display interface brief ）</p><blockquote><p>PID也是BPDU包中的一个字段。</p></blockquote><h5 id="本端PID"><a href="#本端PID" class="headerlink" title="本端PID"></a>本端PID</h5><p>如果遇到了对端为同一接口，就比较自己这边的PID。（两台交换机之间串联了一个集线器就会出现这个情况。）</p><hr><blockquote><p>因此，请不要简单的认为与根桥连在一起的交换机，其直连链路就是根端口所在的链路。</p><p>如果该直连链路速率低（比如百兆），那么其开销值可能大于从其他交换机绕行的链路（比如千兆）。</p></blockquote><h4 id="指定端口-阻塞端口的选举"><a href="#指定端口-阻塞端口的选举" class="headerlink" title="指定端口&#x2F;阻塞端口的选举"></a>指定端口&#x2F;阻塞端口的选举</h4><p>对于一台交换机来说，确定完根端口后，其他接入在STP中的端口就都是指定端口了。</p><p><strong>但当两台非根桥交换机连在一起，且链路所在端口都不是根端口时，就必须选举出最优的一个作为指定，另一个阻塞。</strong></p><blockquote><p>STP本质是防止环路的技术，当链路两侧都不是根端口，说明该链路是环路。</p></blockquote><p>指定端口是用来转发根桥发来的BPDU的，因此要选出到根桥路径最佳的那一个。</p><p>所以第一个优先级就是比较端口到达根桥的开销。（其实就是交换机的根端口到根桥的开销，也就是BPDU包里的Root Path Cost）</p><p>当开销相同时，就比较设备的BID。（BID中包含了mac地址，因此不存在BID相同的情况）</p><h4 id="说白了，选举的就是为了传递最好的BPDU"><a href="#说白了，选举的就是为了传递最好的BPDU" class="headerlink" title="说白了，选举的就是为了传递最好的BPDU"></a>说白了，选举的就是为了传递最好的BPDU</h4><p>一是要求传递出的BPDU中的Root Path Cost（到根桥开销）为最小。</p><p>二是要求传递出的BPDU中BID与PID为优先级最高的。</p><h3 id="STP中的几个时间"><a href="#STP中的几个时间" class="headerlink" title="STP中的几个时间"></a>STP中的几个时间</h3><p> <span id="bpdu">先贴一个抓到的BPDU包的报文内容</span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Spanning Tree Protocol</span><br><span class="line">    Protocol Identifier: Spanning Tree Protocol (0x0000)</span><br><span class="line">    Protocol Version Identifier: Spanning Tree (0)</span><br><span class="line">    BPDU Type: Configuration (0x00)</span><br><span class="line">    BPDU flags: 0x00</span><br><span class="line">        0... .... = Topology Change Acknowledgment: No</span><br><span class="line">        .... ...0 = Topology Change: No</span><br><span class="line">    Root Identifier: 32768 / 0 / 4c:1f:cc:58:6c:b7</span><br><span class="line">    Root Path Cost: 0</span><br><span class="line">    Bridge Identifier: 32768 / 0 / 4c:1f:cc:58:6c:b7</span><br><span class="line">    Port identifier: 0x8001</span><br><span class="line">    Message Age: 0</span><br><span class="line">    Max Age: 20</span><br><span class="line">    Hello Time: 2</span><br><span class="line">    Forward Delay: 15</span><br></pre></td></tr></table></figure><table><thead><tr><th>时间</th><th>说明</th></tr></thead><tbody><tr><td>Message Age</td><td>该BPDU包年龄值（以秒为单位）。默认每经过一个交换机，年龄就加1s。</td></tr><tr><td>Max Age</td><td>最大年龄值，默认为20s。收到的包Message Age大于20就丢弃该BPDU包。二是当接口持续20秒未收到BPDU，则认为上游设备已经出现故障，本设备会重新进行生成树计算。</td></tr><tr><td>hello time</td><td>2s。根桥定期发布<em>配置BPDU</em>的时间。</td></tr><tr><td>Forward Delay</td><td>状态迁移的延迟时间，默认15s。接口进入监听与学习状态各需要等待15秒，总计30秒。<br />也就是说30秒是端口状态发生变化直到稳定的最短时间。</td></tr><tr><td>Max Age + Forward Delay</td><td>50s。最坏情况下，拓扑发生变化后，先等待20s才开始重选举，选举又需要30s的时间收敛，一共50s，就是网络恢复正常所消耗的最短时间。</td></tr></tbody></table><blockquote><p>注：华为交换机不再使用Max Age 来决定端口角色变化需等待的超时时间。</p><p>目前，华为交换机STP&#x2F;RSTP 实现中，超时时间＝Hello Time × 3 × Timer Factor。</p><p>（若未设置Timer Factor的值，则超过时间是Hello Time的9倍。）</p></blockquote><h2 id="STP的配置"><a href="#STP的配置" class="headerlink" title="STP的配置"></a>STP的配置</h2><p>STP由于收敛需要30秒，故障响应也要20秒；不是很迅速，所以目前都采用的改进后的RSTP或MSTP。</p><p>因此，如果要体验与配置STP，需要先将STP模式修改为原始的STP。</p><table><thead><tr><th>命令</th><th></th></tr></thead><tbody><tr><td><strong>stp enable</strong></td><td>开启stp，默认就是开启状态。</td></tr><tr><td><strong>stp disable</strong></td><td>关闭stp。</td></tr><tr><td><strong>stp mode stp</strong></td><td>修改STP模式为STP</td></tr><tr><td><strong>stp priority</strong>  ？</td><td>修改设备的BID优先级，默认为32768。修改需要填写为4096的倍数。</td></tr><tr><td><strong>stp root primary</strong></td><td>配置当前设备为根桥设备。 等同于<strong>stp priority</strong>  0</td></tr><tr><td><strong>stp root secondary</strong></td><td>配置当前设备为备用根桥设备。 等同于<strong>stp priority</strong>  4096</td></tr><tr><td><strong>stp pathcost-standard</strong> ？</td><td>修改设备的开销计算标准。参数为<em>dot1d-1998</em>或<em>dot1t</em></td></tr><tr><td><strong>display stp</strong></td><td>查看生成树的状态信息与统计信息。带brief则显示接口主要信息。<br />也可以指定查看某一接口的信息。如：<strong>dis stp interface</strong> <em>GigabitEthernet 0&#x2F;0&#x2F;1</em></td></tr><tr><td>以下命令为接口视图下执行</td><td></td></tr><tr><td><strong>stp cost</strong> ？</td><td>修改当前端口的路径开销值。（填数值）</td></tr><tr><td><strong>stp port priority</strong> ？</td><td>修改端口的优先级，默认为128。</td></tr></tbody></table><blockquote><p>一般常用的也就设置主根桥与备用根桥。</p></blockquote><p>配置就不演示了，推荐自己打开ensp自己随便搭几个交换机跟多条链路，然后自己推算一下根桥、根端口、指定端口、阻塞端口是谁。</p><p>再思考一下如果要修改的话，需要使用什么命令（修改谁的BID优先级，修改哪个接口的开销或PID优先级）。</p><h1 id="RSTP"><a href="#RSTP" class="headerlink" title="RSTP"></a>RSTP</h1><h2 id="STP的不足之处"><a href="#STP的不足之处" class="headerlink" title="STP的不足之处"></a>STP的不足之处</h2><p>STP协议虽然能够解决环路问题，但是由于网络拓扑收敛慢，影响了用户通信质量。如果网络中的拓扑结构频繁变化，网络也会随之频繁失去连通性，从而导致用户通信频繁中断，这是用户无法忍受的。</p><p>STP的不足之处如下：</p><ul><li><p>STP没有细致区分端口状态和端口角色，不利于初学者学习及部署。</p><p>网络协议的优劣往往取决于协议是否对各种情况加以细致区分。</p><ul><li>从用户角度来讲，Listening、Learning和Blocking状态并没有区别，都同样不转发用户流量。</li><li>从使用和配置角度来讲，端口之间最本质的区别并不在于端口状态，而是在于端口扮演的角色。</li></ul></li><li><p>STP算法是被动的算法，依赖定时器等待的方式判断拓扑变化，收敛速度慢。</p></li><li><p>STP算法要求在稳定的拓扑中，根桥主动发出配置BPDU报文，而其他设备进行处理，传遍整个STP网络。这也是导致拓扑收敛慢的主要原因之一。</p></li></ul><blockquote><p>端口状态指Disabled、Listening、Learning、Forwarding、Blocking这五个。</p><p>端口角色指的是根端口、指定端口、阻塞端口这三个。</p></blockquote><h2 id="RSTP对STP的改进"><a href="#RSTP对STP的改进" class="headerlink" title="RSTP对STP的改进"></a>RSTP对STP的改进</h2><p>根据STP的不足，RSTP新增加了2种端口角色，删除了3种端口状态，并且把端口属性充分的按照状态和角色解耦。</p><p>此外，RSTP还增加了相应的一些增强特性和保护措施，实现网络的稳定和快速收敛。</p><h3 id="通过端口角色的增补，简化了生成树协议的理解及部署。"><a href="#通过端口角色的增补，简化了生成树协议的理解及部署。" class="headerlink" title="通过端口角色的增补，简化了生成树协议的理解及部署。"></a><strong>通过端口角色的增补，简化了生成树协议的理解及部署。</strong></h3><p>RSTP的端口角色共有4种：根端口、指定端口、Alternate端口（原STP中的阻塞端口）和Backup端口。</p><p>根端口和指定端口的作用同STP协议中定义，Alternate端口和Backup端口的描述如下：</p><ul><li><p>从配置BPDU报文发送角度来看：</p><ul><li>Alternate端口就是由于学习到其它网桥发送的配置BPDU报文而阻塞的端口。</li><li>Backup端口就是由于学习到自己发送的配置BPDU报文而阻塞的端口。</li></ul></li><li><p>从用户流量角度来看：</p><ul><li>Alternate端口作为根端口的备份端口，提供了从指定桥到根的另一条可切换路径。</li><li>Backup端口作为指定端口的备份，提供了另一条从根桥到相应网络的备份通路。</li></ul><p>给一个RSTP域内所有端口分配角色的过程就是整个拓扑收敛的过程。</p></li></ul><h3 id="端口状态的重新划分"><a href="#端口状态的重新划分" class="headerlink" title="端口状态的重新划分"></a><strong>端口状态的重新划分</strong></h3><p>RSTP的状态规范把原来的5种状态缩减为3种。根据端口是否转发用户流量和学习MAC地址来划分:</p><ul><li>如果不转发用户流量也不学习MAC地址，那么端口状态就是Discarding状态。</li><li>如果不转发用户流量但是学习MAC地址，那么端口状态就是Learning状态。</li><li>如果既转发用户流量又学习MAC地址，那么端口状态就是Forwarding状态。</li></ul><p>如表所示，新的端口状态与STP规定的端口状态比较。端口状态和端口角色是没有必然联系的，显示了各种端口角色能够具有的端口状态。</p><table><thead><tr><th>STP端口状态</th><th>RSTP端口状态</th><th>端口在拓扑中的角色</th></tr></thead><tbody><tr><td>Blocking</td><td>Discarding</td><td>包括Alternate端口、Backup端口</td></tr><tr><td>Disabled</td><td>Discarding</td><td>包括Disable端口</td></tr><tr><td>Listening</td><td>Discarding</td><td>包括根端口、指定端口</td></tr><tr><td>Learning</td><td>Learning</td><td>包括根端口、指定端口</td></tr><tr><td>Forwarding</td><td>Forwarding</td><td>包括根端口、指定端口</td></tr></tbody></table><h3 id="配置BPDU的处理发生变化"><a href="#配置BPDU的处理发生变化" class="headerlink" title="配置BPDU的处理发生变化"></a><strong><em>配置BPDU</em>的处理发生变化</strong></h3><ul><li><p>拓扑稳定后，<em>配置BPDU</em>报文的发送方式</p><p>在STP中，拓扑稳定后，根桥按照Hello Time规定的时间间隔发送配置BPDU。其他非根桥设备在收到上游设备发送过来的配置BPDU后，才会触发发出配置BPDU，此方式使得STP协议计算复杂且缓慢。</p><p>RSTP对此进行了改进，即在拓扑稳定后，无论非根桥设备是否接收到根桥传来的配置BPDU报文，非根桥设备仍然按照Hello Timer规定的时间间隔发送配置BPDU，该行为完全由每台设备自主进行。</p></li><li><p>更短的BPDU超时计时</p><p>如果一个端口在超时时间（超时时间＝Hello Time × 3 × Timer Factor）内没有收到上游设备发送过来的配置BPDU，那么该设备认为与此邻居之间的协商失败。而不像STP那样需要先等待一个Max Age。</p></li><li><p>处理次等BPDU</p><p>当一个端口收到上游的指定桥发来的BPDU报文时，该端口会将自身存储的BPDU与收到的BPDU进行比较。</p><p>如果该端口存储的BPDU的优先级高于收到的BPDU，那么该端口会直接丢弃收到的BPDU，立即回应自身存储的BPDU。</p><p>当上游设备收到下游设备回应的BPDU后，上游设备会根据收到的BPDU报文中相应的字段立即更新自己存储的BPDU。</p><p>由此，RSTP处理次等BPDU报文不再依赖于任何定时器通过超时解决拓扑收敛，从而加快了拓扑收敛。</p></li></ul><h3 id="快速收敛"><a href="#快速收敛" class="headerlink" title="快速收敛"></a><strong>快速收敛</strong></h3><ul><li><p><strong>Proposal&#x2F;Agreement机制</strong></p><p>当一个端口被选举成为指定端口之后，在STP中，该端口至少要等待一个Forward Delay（Learning）时间才会迁移到Forwarding状态。</p><p>而在RSTP中，此端口会先进入Discarding状态，再通过Proposal&#x2F;Agreement机制快速进入Forward状态。这种机制必须在点到点全双工链路上使用。</p><p>Proposal&#x2F;Agreement机制简称P&#x2F;A机制，详细描述稍后介绍。</p></li><li><p><strong>端口快速切换机制</strong></p><p>如果RSTP网络中，一台交换机的根端口失效，那么该交换机最优的Alternate端口将成为根端口并直接进入Forwarding状态。</p><p>因为通过这个Alternate端口连接的链路上必然有个指定端口可以通往根桥。</p><p>阻塞端口也是周期性的接收到BPDU包才能保持的，因此必定是到根桥链路为通的状态。</p></li><li><p>STP模式时，阻塞端口切换成根端口后，要等待一个Forward Delay时间（缺省值为15秒）进入Learning状态，再继续等待一个Forward Delay时间才进入Forwarding状态。</p><ul><li>RSTP模式时，阻塞端口切换成根端口后，直接进入Forwarding状态。</li></ul><p>相比较STP模式时接口需要等待2*Forward Delay时间才能进入Forwarding状态，RSTP模式时的根端口快速切换机制使接口直接切换成Forwarding状态，减少业务流量丢包。</p><p>同样的，如果指定端口失效，该交换机最优的Backup端口将成为指定端口并直接进入Forwarding状态</p></li></ul><blockquote><p>此处指的都是同一台交换机存在阻塞端口的情况。</p></blockquote><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>RSTP作为一个独立于STP的新协议，其报文自然也会有所改动，马上就会开始介绍。</p><p>STP如果抛开时间问题，其已经是非常完美的防环协议了。但作为早期协议，并没有考虑到安全问题，恶意者可以利用BPDU的优先级选举机制来搞破坏，通过伪装BPDU报文，发送给交换设备，以引起通信的异常中断。</p><p>为此，RSTP就加入了许多安全保护机制。（也是稍后介绍）</p><h2 id="RST-BPDU"><a href="#RST-BPDU" class="headerlink" title="RST BPDU"></a>RST BPDU</h2><p>在配置BPDU报文的格式上，除了保证和STP格式基本一致之外，RSTP作了一些小变化：</p><ul><li>Type字段，配置BPDU类型不再是0而是2，所以运行STP的设备收到RSTP的配置BPDU时会丢弃。</li><li>Flags字段，使用了原来保留的中间6位，这样改变的配置BPDU叫做RST BPDU。</li></ul><p>下表为一个RSTP协议的BDPU报文中的内容。可以与前面摘抄的<a href="#bpdu">STP的BPDU</a>比对。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Spanning Tree Protocol</span><br><span class="line">    Protocol Identifier: Spanning Tree Protocol (0x0000)</span><br><span class="line">    Protocol Version Identifier: Rapid Spanning Tree (2)</span><br><span class="line">    BPDU Type: Rapid/Multiple Spanning Tree (0x02)</span><br><span class="line">    BPDU flags: 0x7c, Agreement, Forwarding, Learning, Port Role: Designated</span><br><span class="line">        0... .... = Topology Change Acknowledgment: No</span><br><span class="line">        .1.. .... = Agreement: Yes</span><br><span class="line">        ..1. .... = Forwarding: Yes</span><br><span class="line">        ...1 .... = Learning: Yes</span><br><span class="line">        .... 11.. = Port Role: Designated (3)</span><br><span class="line">        .... ..0. = Proposal: No</span><br><span class="line">        .... ...0 = Topology Change: No</span><br><span class="line">    Root Identifier: 32768 / 0 / 4c:1f:cc:4b:6f:48</span><br><span class="line">    Root Path Cost: 0</span><br><span class="line">    Bridge Identifier: 32768 / 0 / 4c:1f:cc:4b:6f:48</span><br><span class="line">    Port identifier: 0x8001</span><br><span class="line">    Message Age: 0</span><br><span class="line">    Max Age: 20</span><br><span class="line">    Hello Time: 2</span><br><span class="line">    Forward Delay: 15</span><br><span class="line">    Version 1 Length: 0</span><br></pre></td></tr></table></figure><p>其中，flags字段的信息如下：</p><ul><li>Topology Change Acknowledgment: No - 该标志位表示没有收到拓扑变化的确认。</li><li>Agreement: Yes - 该标志位表示该端口与对应的邻居端口达成了一致，表示两个端口的状态相互匹配。</li><li>Forwarding: Yes - 该标志位表示该端口处于转发状态，可以接收和转发数据帧。</li><li>Learning: Yes - 该标志位表示该端口处于学习状态，可以接收数据帧并将源 MAC 地址添加到 MAC 地址表中。</li><li>Port Role: Designated (3) - 该标志位表示端口角色为 Designated，即指定端口。其他字节对应的端口如下：<ul><li>00 Unknown</li><li>01 Alternate&#x2F;Backup port</li><li>10 Root port</li><li>11 Designated port</li></ul></li><li>Proposal: No - 该标志位表示没有发送 RSTP 配置 BPDU 的提议。</li><li>Topology Change: No - 该标志位表示没有网络拓扑变化。</li></ul><blockquote><p>这种BPDU称为RST BPDU，以区分普通STP的BPDU。 从现在开始，本文后续关于RSTP的BPDU包都会称为RST BPDU。</p></blockquote><h2 id="Proposal-Agreement机制"><a href="#Proposal-Agreement机制" class="headerlink" title="Proposal&#x2F;Agreement机制"></a>Proposal&#x2F;Agreement机制</h2><p>在STP中，端口需要等待Forward Delay时间才迁移到Forwarding状态，其目的是为了避免环路，等待一定的时间，以保证所有设备都确定好了端口角色。</p><p>在RSTP中，当一个端口被选为根端口和指定端口后，其进入转发状态的延时将大大缩短，从Discarding尽快进入Forwarding状态。</p><p>指定端口的端口状态快速迁移的条件是：</p><ul><li>如果指定端口是边缘端口，则指定端口可以直接进入转发状态。（边缘端口即该端口直接与用户终端相连，而没有连接到其他交换设备或共享网段上）</li><li>如果指定端口连接着点对点链路，则设备可以通过与下游设备握手，得到响应后即刻进入转发状态。该握手机制为Proposal&#x2F;Agreement机制</li></ul><p>根端口的端口状态快速迁移的条件是：</p><ul><li>本设备上旧的根端口已经停止转发数据，而且上游指定端口已经开始转发数据。</li></ul><blockquote><p>Proposal与Agreement的数值位于RST BPDU包的flags字段内（请看上一节贴出的flags字段内容）</p></blockquote><h3 id="Proposal-Agreement机制过程原理"><a href="#Proposal-Agreement机制过程原理" class="headerlink" title="Proposal&#x2F;Agreement机制过程原理"></a>Proposal&#x2F;Agreement机制过程原理</h3><p>Proposal&#x2F;Agreement机制，目前交换设备的端口支持以下两种方式：</p><ul><li>普通方式：当前端口在计算同步标志位时忽略根端口。<ol><li>上游设备发送Proposal报文，请求进行快速迁移，下游设备接收到后，把与上游设备相连的端口设置为根端口，并阻塞所有非边缘端口，根端口转为Forwarding状态。</li><li>下游设备回应Agreement报文，上游设备接收到后，把与下游设备相连的端口设置为指定端口，指定端口进入Forwarding状态。</li></ol></li><li>增强方式：当前端口在计算同步标志位时计算根端口。<ol><li>上游设备发送Proposal报文，请求进行快速迁移，下游设备接收到后，把与上游设备相连的端口设置为根端口，并阻塞所有非边缘端口。</li><li>上游设备<strong>继续发送Agreement报文</strong>，下游设备接收到后，根端口<strong>才</strong>转为Forwarding状态。</li><li>下游设备回应Agreement报文，上游设备接收到后，把与下游设备相连的端口设置为指定端口，指定端口进入Forwarding状态。</li></ol></li></ul><blockquote><p>在运行生成树的通信网络中，如果华为公司的数据通信设备与其他厂商设备混合组网，可能会因为与其他厂商设备的Proposal&#x2F;Agreement机制不同导致互通失败。</p><p>需要根据其他厂商设备的Proposal&#x2F;Agreement机制，选择端口使用增强的快速迁移机制还是普通的快速迁移机制。</p></blockquote><p>举个例子：</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/388e125b1917fa60af952.png" alt="图4——P/A机制"></p><p>新链路连接成功后，P&#x2F;A机制协商过程如下：</p><ol><li>p0和p1两个端口马上都先成为指定端口，发送RST BPDU。</li><li>S2的p1口收到更优的RST BPDU，马上意识到自己将成为根端口，而不是指定端口，停止发送RST BPDU。</li><li>S1的p0进入Discarding状态，于是发送的RST BPDU中把Proposal和Agreement置1。</li><li>S2收到根桥发送来的携带Proposal的RST BPDU，开始将自己的所有端口进入sync变量置位——进入同步状态。</li><li>p2已经阻塞，状态不变；p4是边缘端口，不参与运算；所以只需要阻塞非边缘指定端口p3。</li><li>各端口同步后，p2、p3进入Discarding状态，p1进入Forwarding状态并向S1返回Agreement位置位的回应RST BPDU。</li><li>当S1判断出这是对刚刚发出的Proposal的回应，于是端口p0马上进入Forwarding状态。</li></ol><p>也就是在原来的基础上，进行了一次主动协商的过程，协商成功，就直接转入Forwarding状态，而不需要走原始的状态迁移。</p><p>这个协商过程中，为了防止其他的环路，会要求根端口以外的端口进入Discarding状态，让他们走原始的状态迁移；当然，如果有其他的设备与之进行P&#x2F;A机制协商，也会参与快速迁移。</p><h2 id="RSTP中的保护机制"><a href="#RSTP中的保护机制" class="headerlink" title="RSTP中的保护机制"></a>RSTP中的保护机制</h2><blockquote><p>所有保护功能默认都是未开启的。</p><p>一般来说，只会给根桥配置根保护，给边缘端口配置BPDU保护，其他的很少使用。</p></blockquote><h3 id="BPDU保护"><a href="#BPDU保护" class="headerlink" title="BPDU保护"></a>BPDU保护</h3><p>交换机上通常将直接与用户终端（如PC机）或文件服务器等非交换设备相连的端口配置为边缘端口。</p><p>正常情况下，边缘端口不会收到RST BPDU。</p><p>但如果有人伪造RST BPDU恶意攻击交换机，当边缘端口接收到RST BPDU时，交换机会自动将边缘端口设置为非边缘端口，并重新进行生成树计算。</p><p>当攻击者发送的RST BPDU报文中的桥优先级高于现有网络中根桥优先级时会改变当前网络拓扑，可能会导致业务流量中断。</p><p>这是网络中一种简单的拒绝服务DoS（Denial of Service）攻击方式。</p><p>交换机上启动了BPDU保护功能后，如果边缘端口收到RST BPDU，边缘端口将被error-down，但是边缘端口属性不变，同时通知网管系统。交换机上会打印如下日志信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSTP/4/BPDU_PROTECTION:This edged-port [port-name] that enabled BPDU-Protection will be shutdown, because it received BPDU packet!</span><br></pre></td></tr></table></figure><h4 id="操作步骤："><a href="#操作步骤：" class="headerlink" title="操作步骤："></a>操作步骤：</h4><ol><li><p>执行命令<strong>system-view</strong>，进入系统视图。</p></li><li><p>执行命令<strong>stp bpdu-protection</strong>，配置交换设备边缘端口的BPDU保护功能。</p><p>默认情况下，交换设备的BPDU保护功能处于禁用状态。</p></li></ol><h4 id="后续处理"><a href="#后续处理" class="headerlink" title="后续处理"></a>后续处理</h4><p>如果用户希望被error-down的边缘端口可自动恢复，可通过配置使能端口自动恢复功能，并设置延迟时间。</p><p>即在系统视图下执行命令<strong>error-down auto-recovery</strong> <strong>cause bpdu-protection</strong> <strong>interval</strong> <em>interval-value</em></p><p>启用端口自动恢复为Up的功能，并设置端口自动恢复为Up的延时时间。使被关闭的端口经过延时时间后能够自动恢复。</p><p>配置时需要注意：</p><ul><li>默认不启用该功能，所以没有默认的延迟时间值。当用户配置该命令时，必须指定恢复延迟时间（<em>interval-value</em>）。</li><li>取值越小表示端口的管理状态自动恢复为Up的延迟时间越短，端口Up&#x2F;Down状态震荡频率越高。</li><li>取值越大表示端口的管理状态自动恢复为Up的延迟时间越长，端口流量中断时间越长。</li><li>自动恢复仅对配置<strong>error-down auto-recovery</strong>命令之后发生error-down的端口有效，对配置此命令之前已经error-down的端口不生效。</li></ul><h3 id="根保护"><a href="#根保护" class="headerlink" title="根保护"></a>根保护</h3><p>由于维护人员的错误配置或网络中的恶意攻击，网络中合法根桥有可能会收到优先级更高的RST BPDU，使得合法根桥失去根地位，从而引起网络拓扑结构的错误变动。</p><p>这种不合法的拓扑变化，会导致原来应该通过高速链路的流量被牵引到低速链路上，造成网络拥塞。</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/475ca2e6601d064b574fc.png" alt="图5——RSTP根保护"></p><p>如图所示，DeviceA和DeviceB处于网络核心层，两者间的链路带宽为1000M，其他链路带宽均为100M。DeviceA为网络中的根桥，DeviceC处于接入层。正常情况下，DeviceB和DeviceC之间的链路被阻塞。</p><p>当DeviceD新接入DeviceC时，如果DeviceD的桥优先级高于DeviceA，此时DeviceD会被选举为新的根桥，两个核心交换机DeviceA和DeviceB之间的千兆链路被阻塞，这会导致VLAN中的流量都通过两条100M链路传输，可能会引起网络拥塞及流量丢失。</p><p>此时可以在DeviceC连接DeviceD的端口上，配置根保护。<strong>对于启用Root保护功能的指定端口，其端口角色只能保持为指定端口。</strong></p><p>一旦启用Root保护功能的指定端口收到优先级更高的RST BPDU时，端口状态将进入Discarding状态，不再转发报文。</p><p>在经过一段时间（通常为两倍的Forward Delay），如果端口一直没有再收到优先级较高的RST BPDU，端口会自动恢复到正常的Forwarding状态。</p><h4 id="操作步骤：-1"><a href="#操作步骤：-1" class="headerlink" title="操作步骤："></a>操作步骤：</h4><ol><li><p>执行命令<strong>system-view</strong>，进入系统视图。</p></li><li><p>执行命令<strong>interface</strong> <em>interface-type interface-number</em>，进入参与生成树协议计算的接口视图。 </p></li><li><p>执行命令<strong>stp root-protection</strong>，配置交换设备的Root保护功能。</p><p>默认情况下，端口的Root保护功能处于去使能状态。当端口的角色是指定端口时，配置的Root保护功能才生效。配置了根保护的端口，不可以配置环路保护。</p></li></ol><h3 id="环路保护"><a href="#环路保护" class="headerlink" title="环路保护"></a>环路保护</h3><p>在运行RSTP协议的网络中，根端口和其他阻塞端口状态是依靠不断接收来自上游交换设备的RST BPDU维持。</p><p>当由于链路拥塞或者单向链路故障导致这些端口收不到来自上游交换设备的RST BPDU时，此时交换设备会重新选择根端口。</p><p>原先的根端口会转变为指定端口，而原先的阻塞端口会迁移到转发状态，从而造成交换网络中可能产生环路。</p><p>当链路发生拥塞时，由于根端口在超时时间内收不到来自上游设备的BPDU报文，Alternate端口放开转变成了根端口，根端口转变成指定端口，从而形成了环路。</p><p>在启动了环路保护功能后，如果根端口或Alternate端口长时间收不到来自上游设备的BPDU报文时，则向网管发出通知信息（此时根端口会进入Discarding状态，角色切换为指定端口），而Alternate端口则会一直保持在阻塞状态（角色也会切换为指定端口），不转发报文，从而不会在网络中形成环路。直到链路不再拥塞或单向链路故障恢复，端口重新收到BPDU报文进行协商，并恢复到链路拥塞或者单向链路故障前的角色和状态。</p><p>交换机上会打印如下日志信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSTP/4/LOOP_GUARD:MSTP process [process-id] Instance[instance-id]&#x27;s LOOP-Protection port [port-name] did not receive message in prescriptive time!</span><br></pre></td></tr></table></figure><blockquote><p>环路保护功能只能在根端口或Alternate端口上配置生效。</p></blockquote><h4 id="操作步骤：-2"><a href="#操作步骤：-2" class="headerlink" title="操作步骤："></a>操作步骤：</h4><ol><li><p>执行命令<strong>system-view</strong>，进入系统视图。</p></li><li><p>执行命令<strong>interface</strong> <em>interface-type interface-number</em>，进入参与生成树协议计算的接口视图。 </p></li><li><p>执行命令<strong>stp loop-protection</strong>，配置交换设备根端口或Alternate端口的环路保护功能。</p><p>默认情况下，端口的环路保护功能处于关闭状态。</p></li></ol><h3 id="防TC-BPDU攻击"><a href="#防TC-BPDU攻击" class="headerlink" title="防TC-BPDU攻击"></a>防TC-BPDU攻击</h3><p>交换设备在接收到TC BPDU报文后，会执行MAC地址表项和ARP表项的删除操作。</p><p>如果有人伪造TC BPDU报文恶意攻击交换设备时，交换设备短时间内会收到很多TC BPDU报文，频繁的删除操作会给设备造成很大的负担，给网络的稳定带来很大隐患。</p><p>启用防TC-BPDU报文攻击功能后，在单位时间内，交换设备处理TC BPDU报文的次数可配置。</p><p>如果在单位时间内，交换设备在收到TC BPDU报文数量大于配置的阈值，那么设备只会处理阈值指定的次数。</p><p>对于其他超出阈值的TC BPDU报文，定时器到期后设备只对其统一处理一次。</p><p>这样可以避免频繁的删除MAC地址表项和ARP表项，从而达到保护设备的目的。</p><h4 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h4><ol><li><p>执行命令<strong>system-view</strong>，进入系统视图。</p></li><li><p>执行命令<strong>stp tc-protection interval</strong> <em>interval-value</em>，配置设备处理阈值指定数量的拓扑变化报文所需的时间。</p><p>默认情况下，设备处理最大数量的拓扑变化报文所需的时间是Hello Time。</p></li><li><p>执行命令<strong>stp tc-protection threshold</strong> <em>threshold</em>，配置交换设备在收到TC类型BPDU报文后，单位时间内，处理TC类型BPDU报文并立即刷新转发表项的阈值。</p><p>默认情况下，设备在指定时间内处理拓扑变化报文的最大数量是1。</p><p>配置后，在<strong>stp tc-protection interval</strong>指定的时间内，设备只会处理<strong>stp tc-protection threshold</strong>指定数量的拓扑变化报文，对于其他的报文会延迟处理，所以可能会影响生成树的收敛速度。例如，时间设定为10秒，阈值设定为5，则设备收到拓扑变化报文后，在10秒内只会处理最开始收到的5个拓扑变化报文，对于后面收到的报文则会等10秒超时后再统一处理。</p></li></ol><h2 id="RSTP配置"><a href="#RSTP配置" class="headerlink" title="RSTP配置"></a>RSTP配置</h2><p>STP的配置命令在RSTP这边基本都能使用，所以不重复介绍。</p><blockquote><p>注意，华为交换机默认为MSTP，需要使用命令stp mode rstp切换为RSTP，后续命令介绍都是在RSTP模式下的。</p><p>保护功能的配置在上节介绍了，也不重复了。</p></blockquote><h3 id="边缘端口"><a href="#边缘端口" class="headerlink" title="边缘端口"></a>边缘端口</h3><p>在RSTP里面，如果某一个指定端口位于整个网络的边缘，即不再与其他交换设备连接，而是直接与终端设备（PC）直连，这种端口叫做边缘端口。</p><p>我们可以手动将满足条件的端口配置为边缘端口，边缘端口不参与RSTP运算，可以由Disable直接转到Forwarding状态，且不经历时延，就像在端口上将STP禁用。</p><p><strong>但是一旦边缘端口收到配置BPDU，就丧失了边缘端口属性，成为普通STP端口，并重新进行生成树计算，从而引起网络震荡。</strong></p><p>因此可以启用边缘端口的BPDU报文过滤功能，使边缘端口不处理、不发送BPDU报文。</p><p>不过启用过滤后，端口将不处理、不发送BPDU报文。该端口将无法成功与对端设备直连端口协商STP协议状态。</p><blockquote><p>除了启用过滤，也可以启用BPDU保护功能。</p></blockquote><h4 id="操作步骤：-3"><a href="#操作步骤：-3" class="headerlink" title="操作步骤："></a>操作步骤：</h4><p>在接口模式下配置边缘端口和BPDU报文过滤功能：</p><ol><li><p>执行命令<strong>system-view</strong>，进入系统视图。</p></li><li><p>执行命令<strong>interface</strong> <em>interface-type interface-number</em>，进入参与生成树协议计算的以太接口视图。</p></li><li><p>执行命令<strong>stp edged-port</strong> <strong>enable</strong>，将端口配置成边缘端口。</p><p>默认情况下，设备的所有端口为非边缘端口。</p></li><li><p>执行命令<strong>stp bpdu-filter</strong> <strong>enable</strong>，配置当前端口为BPDU filter端口，过滤所有BPDU报文。</p><p>默认情况下，设备的所有端口为非BPDU filter端口。</p></li></ol><h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><p>启用生成树协议后，默认启用边缘端口自动探测功能，当端口在（2 × Hello Timer + 1）秒的时间内收不到BPDU报文，会自动设置为边缘端口。</p><p>如果在接口视图下配置了<strong>stp edged-port enable</strong>或<strong>stp edged-port disable</strong>或者在系统视图下配置了<strong>stp edged-port default</strong>，边缘端口自动探测功能就不生效了。</p><blockquote><p>分别是配置为边缘端口，配置为非边缘端口，以及全局配置该设备上所有的接口为边缘端口</p></blockquote><h3 id="配置RSTP超时时间"><a href="#配置RSTP超时时间" class="headerlink" title="配置RSTP超时时间"></a>配置RSTP超时时间</h3><p>在运行生成树算法的网络中，如果设备在配置的超时时间内没有收到上游设备发送的BPDU，就认为上游设备已经出现故障，本设备会重新进行生成树计算。</p><p>由于上游设备繁忙，有时设备在较长的时间内收不到上游设备发送的BPDU。在这种情况下一般不应该重新进行生成树计算，因此，在稳定的网络中，可以配置超时时间，以减少网络资源的浪费。</p><p>如果设备在超时时间（超时时间＝Hello Time × 3 × Timer Factor）内没有收到上游设备发送的BPDU，则生成树会重新进行计算。</p><h4 id="操作步骤：-4"><a href="#操作步骤：-4" class="headerlink" title="操作步骤："></a>操作步骤：</h4><ol><li><p>执行命令<strong>system-view</strong>，进入系统视图。</p></li><li><p>执行命令<strong>stp timer-factor</strong> <em>factor</em>，配置未收到上游的BPDU就重新开始生成树计算的超时时间。</p><p>默认情况下，设备未收到上游的BPDU就重新开始生成树计算的超时时间是Hello Timer的9倍。</p></li></ol><h3 id="配置P-A机制的迁移方式"><a href="#配置P-A机制的迁移方式" class="headerlink" title="配置P&#x2F;A机制的迁移方式"></a>配置P&#x2F;A机制的迁移方式</h3><p>迁移方式分普通与增强，并不兼容；华为设备默认使用增强方式，如果与其他采用普通方式的交换机连接在一起，该链路中P&#x2F;A机制会失效。（但不会影响网络，只是失去了P&#x2F;A机制带来的快速状态迁移，转而走原始的状态迁移。）</p><h4 id="操作步骤：-5"><a href="#操作步骤：-5" class="headerlink" title="操作步骤："></a>操作步骤：</h4><ol><li><p>执行命令<strong>system-view</strong>，进入系统视图。</p></li><li><p>执行命令<strong>interface</strong> <em>interface-type interface-number</em>，进入参与生成树协议计算的接口视图。 </p></li><li><p>执行命令<strong>stp no-agreement-check</strong>，配置端口使用普通的快速迁移方式。</p><p>默认情况下，端口使用增强的快速迁移机制。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> STP </tag>
            
            <tag> RSTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交换中的多链路问题——环路、广播风暴、链路聚合</title>
      <link href="/2023/12/22/%E4%BA%A4%E6%8D%A2%E4%B8%AD%E7%9A%84%E5%A4%9A%E9%93%BE%E8%B7%AF%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E7%8E%AF%E8%B7%AF%E3%80%81%E5%B9%BF%E6%92%AD%E9%A3%8E%E6%9A%B4%E3%80%81%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88/"/>
      <url>/2023/12/22/%E4%BA%A4%E6%8D%A2%E4%B8%AD%E7%9A%84%E5%A4%9A%E9%93%BE%E8%B7%AF%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E7%8E%AF%E8%B7%AF%E3%80%81%E5%B9%BF%E6%92%AD%E9%A3%8E%E6%9A%B4%E3%80%81%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="回顾交换过程"><a href="#回顾交换过程" class="headerlink" title="回顾交换过程"></a>回顾交换过程</h1><p>一般的交换机是二层设备，负责转发数据帧；只会解封装数据帧，获取源mac与目标mac，对数据帧的转发就是基于mac地址的。</p><p>收到一个数据帧：</p><blockquote><p>读取到源mac地址，就进行学习——记录在交换机内部的地址表中。</p><p>读取到目标地址，如果内部地址表中有该mac地址的信息，就根据表格指定的接口转发出去。</p><p>读取到目标地址，如果内部地址表中没有该mac地址的信息，就从其他所有接口转发出去；等目标设备回包了自然就能通过读取源mac学习到。</p><p>如果目标地址为全f，也就是广播地址，就会从所有接口直接转发出去（比如ARP包）</p></blockquote><h1 id="环路与广播风暴"><a href="#环路与广播风暴" class="headerlink" title="环路与广播风暴"></a>环路与广播风暴</h1><h2 id="环路"><a href="#环路" class="headerlink" title="环路"></a>环路</h2><p>环路是指交换机之间的链路形成了一个圈、一个循环。</p><p>可以是多台交换机彼此串联，最后形成一个圆环；也可以是两台交换机之间有多条链路互联；甚至可以是一台交换机同时连在网线的头尾。</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/307ca84936b5512702b02.png" alt="图1——三种环路"></p><p>现网中常出现的情况有两种：</p><blockquote><p>一是机房到办公区拉了多条网线（其中有作为备用的），备用的网线在机房已经接上交换机，在办公区这边只是打上水晶头未接上。某天有人将这条网线接上交换机的话，就形成环路了。（图中第二种）</p><p>二是办公区的交换机连了多台设备，有设备移动了，网线还留在交换机上。某天有人将这条因设备移动、未连接设备的网线接回交换机的话，就形成环路了。（图中第三种）</p></blockquote><p>如果形成环路的交换机之间有广播包存在，那么该广播包将无限制的循环下去。</p><h2 id="广播风暴"><a href="#广播风暴" class="headerlink" title="广播风暴"></a>广播风暴</h2><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/92c1f0df16297214f1245.png" alt="图2——广播风暴"></p><p>比如图中PC1想访问PC2，由于不知道PC2的mac地址，于是发送了ARP广播包。</p><p>基于广播特性，交换机2收到ARP包时会转发给交换1与3，交换机1再转发给交换机3，在交换机3这就一共有2份广播包了，最终PC2会收到2份广播包。（指单方向的一次通信，图中绿色箭头）</p><p>实际上交换机3分别收到交换机1与2发来的广播包，不会只发给PC2，也会转发到另一台交换机（图中红色箭头）。</p><p><strong>最终这两红箭头的广播包就会一直转发下去</strong>，在环路中形成一个“顺时针”与一个“逆时针”方向的“圈”。</p><p>另外<strong>对于PC1与PC2来说，也会收到无限多的该广播包。</strong></p><p><strong>这就是广播风暴。</strong></p><p>设备越多，形成环路后造成的广播风暴就越猛烈，很快就会导致网络资源被占满，导致一般的网络通信无法正常进行。</p><p>另外，基于交换机的mac地址学习机制——收到数据帧会学习记录数据帧的源mac地址。</p><p>以上述拓扑为例，对其中任何交换机来说，当他们收到“顺时针方向”的数据帧，就会记录PC1的mac地址来自于此；可收到“逆时针方向”的数据帧时，就又检测到PC1的mac地址来自于这另一个接口。</p><p>最终这个mac在交换机的地址表中，表现为在两个接口之间反复切换，这种现象被称为为mac地址漂移、或mac地址震荡。</p><p>这种现象会导致在广播风暴的初期——网络资源还未被完全消耗时，就出现网络时断时续的情况。</p><h2 id="预防措施"><a href="#预防措施" class="headerlink" title="预防措施"></a>预防措施</h2><p>一是对备用线缆做好标签，最好是不打水晶头，需要时再打水晶头。</p><p>二是做好管理教育，普通员工不要碰网络设备，哪怕是不小心撞到了，以为自己把网线碰松掉下来了，也不要自己接回去。（等有人上不了网报障了，运维人员再去处理。）</p><p>三是在可网管的交换机设备开启STP一类的防环路功能。（STP的内容在另一篇文章详细介绍）</p><h2 id="衍生"><a href="#衍生" class="headerlink" title="衍生"></a>衍生</h2><p>我们辩证的看一下环路，其还是能存在优点的。</p><p>就上面的拓扑图，假如这三台交换机之间某一条链路故障了，并不会造成局部网络不通，PC1与PC2依旧能访问到任何一台交换机。</p><p>如果是两台交换机之间存在环路（图1的第二种环路情况），一样也能保证单条链路故障后，依旧有链路能访问；甚至可以考虑同时使用这两条链路来收发数据，实现带宽的翻倍，网络性能的优化。</p><p>后面将介绍两种技术——链路聚合、生成树协议，就能实现以上功能，且不会造成广播风暴。</p><blockquote><p>打算一口气介绍完STP与RSTP，碍于篇幅，STP与RSTP本文暂不介绍，所以先介绍链路聚合技术。</p></blockquote><h1 id="链路聚合"><a href="#链路聚合" class="headerlink" title="链路聚合"></a>链路聚合</h1><p>以太网链路聚合Eth-Trunk简称链路聚合，通过将多个物理接口捆绑为一个逻辑接口，可以在不进行硬件升级的条件下，达到增加链路带宽的目的。</p><p>链路聚合技术主要有以下三个优势：</p><ul><li><p>增加带宽</p><p>链路聚合接口的最大带宽可以达到各成员接口带宽之和。（比如千兆交换机，原本只有1条链路时只能跑千兆；链路聚合3条链路的话就可以跑到三千兆。）</p></li><li><p>提高可靠性</p><p>当某条活动链路出现故障时，流量可以切换到其他可用的成员链路上，从而提高链路聚合接口的可靠性。（链路聚合了3条链路，其中一条链路故障了，其他2条还正常，所以不影响通信。）</p></li><li><p>负载分担</p><p>在一个链路聚合组内，可以实现在各成员活动链路上的负载分担。（聚合了3条链路，同时进行收发，将数据流量分摊。）</p></li></ul><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/8f4122ccdee05f9c9d2ec.png" alt="图3——链路聚合构成"></p><blockquote><p>注：链路聚合后，针对接口的配置只需要在链路聚合接口下直接配置即可。</p></blockquote><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><ol><li>执行命令<strong>system-view</strong>，进入系统视图。</li><li>执行命令<strong>interface eth-trunk</strong> <em>trunk-id</em>，创建Eth-Trunk接口，并进入Eth-Trunk接口视图。 </li><li>执行命令<strong>trunkport</strong> <em>interface-type</em> <em>interface-number1</em>，增加成员接口，可批量添加，规则同批量添加vlan一样。</li></ol><blockquote><p>将成员接口加入Eth-Trunk后，需要注意以下问题：</p><ul><li>一个以太网接口只能加入到一个Eth-Trunk接口，如果需要加入其它Eth-Trunk接口，必须先退出原来的Eth-Trunk接口。</li><li>当成员接口加入Eth-Trunk后，学习MAC地址或ARP地址时是按照Eth-Trunk来学习的，而不是按照成员接口来学习。</li><li>删除聚合组时需要先删除聚合组中的成员接口，另外切换接口类型&#x2F;模式需要清空接口配置。</li></ul></blockquote><p>聚合接口创建之后，对于交换机来说，这就是一个普通的接口，可以在该Eth-Trunk接口视图直接进行常规的配置（比如vlan）。</p><p>在交换机的内部地址表中，也只会显示为Eth-Trunk接口。</p><h3 id="小案例——手工模式"><a href="#小案例——手工模式" class="headerlink" title="小案例——手工模式"></a>小案例——手工模式</h3><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/d4acdad8bc522c3ff220c.png" alt="图4——链路聚合拓扑1"></p><p>以上图拓扑为例，交换机1与交换机2之间使用3条链路连接。</p><p>因为接口号都一样，两台交换机上都使用以下命令进行配置</p><blockquote><p><strong>interface Eth-Trunk</strong> 1</p><p><strong>trunkport</strong> g 0&#x2F;0&#x2F;1 to 0&#x2F;0&#x2F;3</p></blockquote><p>再执行命令<strong>dis eth-trunk</strong> <em>trunk-id</em>查看接口信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[magiku]dis eth-trunk 1</span><br><span class="line">Eth-Trunk1&#x27;s state information is:</span><br><span class="line">WorkingMode: NORMAL         Hash arithmetic: According to SIP-XOR-DIP         </span><br><span class="line">Least Active-linknumber: 1  Max Bandwidth-affected-linknumber: 8              </span><br><span class="line">Operate status: up          Number Of Up Port In Trunk: 3                     </span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">PortName                      Status      Weight </span><br><span class="line">GigabitEthernet0/0/1          Up          1      </span><br><span class="line">GigabitEthernet0/0/2          Up          1      </span><br><span class="line">GigabitEthernet0/0/3          Up          1    </span><br></pre></td></tr></table></figure><p>非常的简单，三个接口都加入聚合组了，完成了链路聚合。</p><p>使用几台PC互相通信后，再查看交换机的地址表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[SW1]display mac-address</span><br><span class="line">MAC address table of slot 0:</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">MAC Address    VLAN/       PEVLAN CEVLAN Port            Type      LSP/LSR-ID  </span><br><span class="line">               VSI/SI                                              MAC-Tunnel  </span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">5489-98bc-cc44 1           -      -      Eth-Trunk1      dynamic   0/-         </span><br><span class="line">5489-9857-cc33 1           -      -      GE0/0/5         dynamic   0/-         </span><br><span class="line">5489-9853-cc22 1           -      -      Eth-Trunk1      dynamic   0/-         </span><br><span class="line">5489-9873-cc11 1           -      -      GE0/0/4         dynamic   0/-         </span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Total matching items on slot 0 displayed = 4 </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[SW2]display mac-address</span><br><span class="line">MAC address table of slot 0:</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">MAC Address    VLAN/       PEVLAN CEVLAN Port            Type      LSP/LSR-ID  </span><br><span class="line">               VSI/SI                                              MAC-Tunnel  </span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">5489-9857-cc33 1           -      -      Eth-Trunk1      dynamic   0/-         </span><br><span class="line">5489-98bc-cc44 1           -      -      GE0/0/5         dynamic   0/-         </span><br><span class="line">5489-9853-cc22 1           -      -      GE0/0/4         dynamic   0/-         </span><br><span class="line">5489-9873-cc11 1           -      -      Eth-Trunk1      dynamic   0/-         </span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Total matching items on slot 0 displayed = 4 </span><br></pre></td></tr></table></figure><p><strong>可以看到mac地址对应的接口显示为聚合接口Eth-Trunk1，对交换机来说，已经不存g0&#x2F;0&#x2F;1 g0&#x2F;0&#x2F;2 g0&#x2F;0&#x2F;3这三个接口了。</strong></p><h3 id="手工模式的注意事项"><a href="#手工模式的注意事项" class="headerlink" title="手工模式的注意事项"></a>手工模式的注意事项</h3><p>以上这种配置方式为手工模式（还有一些可选命令就不介绍了），手动模式因其灵活性差，目前已很少使用。</p><p><strong>手工模式不感知对端设备</strong>，可能交换机1聚合的链路中有一条被接到其他的设备，而不是交换机2；对于交换机1来说，它并不知道。</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/634fcb20b134e7a46661f.png" alt="图5——手动模式的缺陷"></p><blockquote><p>在上图示例中SW1将四个接口加入到同一个聚合接口，但是其中一个接口的对端为SW3，而不是SW2，导致部分流量被负载分担到SW3，从而导致通信异常。</p></blockquote><p><strong>手工模式下，只感知自身的接口状态</strong>，如果链路中间有其他设备提供了链路状态（简单来说就是交换机接口亮灯），那么实际出现故障后，另一端交换机也感知不到异常。（比如电口交换机与光口交换机做链路聚合，中间使用了光电转换器；当一侧交换机接口故障时，由于光电转换器到另一端的交换机还是保持链路的，所以该交换机依旧以为聚合链路正常。）</p><p>因此，<strong>配置手工模式需要注意一个聚合接口的所有成员接口，其链路的另一头接口必须属于同一台设备，且属于同一个聚合接口。</strong></p><p>（一个交换机可创建多个聚合接口，所有要保证在一个聚合接口中）</p><p>为解决手工模式的缺陷，人们便考虑让聚合接口之间进行协议通信，交流彼此接口信息，这种新的配置模式就是LACP。</p><h2 id="LACP模式的链路聚合"><a href="#LACP模式的链路聚合" class="headerlink" title="LACP模式的链路聚合"></a>LACP模式的链路聚合</h2><h3 id="手工模式与LACP模式的对比"><a href="#手工模式与LACP模式的对比" class="headerlink" title="手工模式与LACP模式的对比"></a>手工模式与LACP模式的对比</h3><table><thead><tr><th>维度</th><th>手工模式</th><th>LACP模式</th></tr></thead><tbody><tr><td>Eth-Trunk的建立方式</td><td>Eth-Trunk的建立、成员接口的加入由手工配置，<br />没有链路聚合控制协议的参与。</td><td>Eth-Trunk的建立是基于LACP协议的，<br />LACP为交换数据的设备提供一种标准的协商方式，<br />以供系统根据自身配置自动形成聚合链路并启动聚合链路收发数据。<br />聚合链路形成以后，负责维护链路状态。<br />在聚合条件发生变化时，自动调整或解散链路聚合。</td></tr><tr><td>设备是否需要支持LACP协议</td><td>不需要</td><td>需要</td></tr><tr><td>数据转发</td><td>正常情况下，所有链路都是活动链路。<br />如果某条活动链路故障，链路聚合组自动在剩余的活动链路中分担流量。</td><td>正常情况下，部分链路是活动链路。<br />如果某条活动链路故障，链路聚合组自动在非活动链路中选择一条链路作为活动链路，参与数据转发的链路数目不变。</td></tr><tr><td>是否支持跨设备的链路聚合</td><td>不支持</td><td>支持</td></tr><tr><td>检测故障</td><td>只能检测到同一聚合组内的成员链路有断路等有限故障，但是无法检测到链路断连、错连等故障。</td><td>不仅能够检测到同一聚合组内的成员链路有断路等有限故障，还可以检测到链路故障、链路错连等故障。</td></tr></tbody></table><p><strong>所谓的活动链路就是指投入使用，负责数据转发的链路的。</strong></p><p><strong>手工模式默认所有链路都负责收发数据，LACP模式下可自定义启用多少条链路。</strong></p><h3 id="配置LACP模式的链路聚合"><a href="#配置LACP模式的链路聚合" class="headerlink" title="配置LACP模式的链路聚合"></a>配置LACP模式的链路聚合</h3><ol><li><p>执行命令<strong>system-view</strong>，进入系统视图。</p></li><li><p>执行命令<strong>interface eth-trunk</strong> <em>trunk-id</em>，创建并进入Eth-Trunk接口视图。</p></li><li><p>执行命令<strong>mode</strong> <strong>lacp</strong>，配置Eth-Trunk的工作模式为LACP。</p><ul><li><p>不执行此命令时，工作模式默认为手工模式，正常配置为手工模式的命令为<em>mode manual load-balance</em>。</p></li><li><p>配置时需要保证本端和对端的聚合模式一致。即如果本端配置为LACP模式，那么对端设备也必须要配置为LACP模式。</p></li></ul></li><li><p>执行命令<strong>trunkport</strong> <em>interface-type</em> <em>interface-number</em>，增加成员接口。</p></li><li><p>（可选）执行命令<strong>max active-linknumber</strong> <em>link-number</em>，配置链路聚合活动接口数上限阈值。</p><ul><li>不执行此命令时，默认上限需要看设备型号，一般至少大于4。</li><li>如果要执行此命令，最好本端和对端都做相同的修改。</li></ul></li></ol><blockquote><p>一般执行以上命令就可以完成配置了，但还有两个信息可做修改，一个是优先级，另一个是负载分担方式。</p><p>在给出命令之前，得先学习一下什么是lacp的优先级与负载分担。</p></blockquote><h3 id="LACP优先级"><a href="#LACP优先级" class="headerlink" title="LACP优先级"></a>LACP优先级</h3><h4 id="系统优先级"><a href="#系统优先级" class="headerlink" title="系统优先级"></a>系统优先级</h4><p>在lacp模式下，链路分活动链路与非活动链路（备用的不启用的链路）。如果交换机1选择链路1与2所在的接口为活动接口，交换机2链路3与4所在的接口为活动接口，这就会导致聚合链路的构建失败。</p><p>因此引入了系统LACP优先级的概念，优先级高的设备为主动端。</p><p>主动端选择好什么接口为活动接口，也就意味着活动链路确定了，于是优先级低的被动端就依此确定其活动接口。</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/3550a1562cd495ab5ddb1.png" alt="图6——优先级与活动接口"></p><p><strong>系统LACP优先级默认32768，越小越优</strong>，通常保持默认。</p><p>当优先级—致时LACP会通过比较MAC地址选择主动端，MAc地址越小越优。</p><blockquote><h6 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤:"></a>操作步骤:</h6><ol><li>执行命令<strong>system-view</strong>，进入系统视图。</li><li>执行命令<strong>lacp priority</strong> <em>number</em>，配置当前设备的系统LACP优先级。</li></ol></blockquote><h4 id="接口优先级"><a href="#接口优先级" class="headerlink" title="接口优先级"></a>接口优先级</h4><p>系统优先级是选出主动端与被动端，而接口优先级则是选出活动接口与非活动接口。</p><p>接口LACP优先级默认为32768，越小越优，通常保持默认。</p><p>当优先级—致时LACP会通过接口编号选择活动接口,越小越优。</p><blockquote><h6 id="操作步骤-（注意是进入物理接口修改）"><a href="#操作步骤-（注意是进入物理接口修改）" class="headerlink" title="操作步骤:（注意是进入物理接口修改）"></a>操作步骤:（注意是进入物理接口修改）</h6><ol><li>执行命令<strong>system-view</strong>，进入系统视图。</li><li>执行命令<strong>interface</strong> <em>interface-type</em> <em>interface-number</em>，进入接口视图。</li><li>执行命令<strong>lacp priority</strong> <em>number</em>，配置当前接口的LACP优先级。</li></ol></blockquote><h5 id="接口抢占功能与其延时时间"><a href="#接口抢占功能与其延时时间" class="headerlink" title="接口抢占功能与其延时时间"></a>接口抢占功能与其延时时间</h5><p><strong>开启LACP抢占功能可以保持接口LACP优先级最高的接口为活动接口。</strong></p><blockquote><p>当一条高优先级的接口因故障切换为非活动状态而后又恢复时；</p><p>如果开启了抢占，则高优先级的接口将重新成为活动接口；</p><p>如果未开启抢占，该接口不能重新成为活动接口。</p></blockquote><p>抢占延时即抢占等待时间，是指在LACP模式的Eth-Trunk中非活动接口切换为活动接口需要等待的时间。</p><p>配置抢占延时可以避免由于某些链路状态频繁变化而导致Eth-Trunk数据传输不稳定的情况。</p><blockquote><h6 id="操作步骤-1"><a href="#操作步骤-1" class="headerlink" title="操作步骤"></a>操作步骤</h6><ol><li><p>执行命令<strong>system-view</strong>，进入系统视图。</p></li><li><p>执行命令<strong>interface eth-trunk</strong> <em>trunk-id</em>，进入Eth-Trunk接口视图。</p></li><li><p>执行命令<strong>lacp preempt enable</strong>，开启当前Eth-Trunk接口的LACP抢占功能。</p><ul><li><p><strong>默认情况下，LACP抢占处于关闭状态</strong>。</p></li><li><p>为保证Eth-Trunk正常工作，要求Eth-Trunk两端统一配置LACP抢占开启或关闭。</p></li></ul></li><li><p>执行命令<strong>lacp preempt delay</strong> <em>delay-time</em>，配置当前Eth-Trunk接口的LACP抢占等待时间。</p><ul><li><p>默认情况下，LACP抢占等待时间为30秒。</p></li><li><p>当链路两端设备配置的抢占等待时间不一致时，以等待时间最长的作为实际抢占等待时间。</p></li></ul></li></ol></blockquote><h3 id="负载分担"><a href="#负载分担" class="headerlink" title="负载分担"></a>负载分担</h3><p>在使用Eth-Trunk转发数据时，由于聚合组两端设备之间有多条物理链路；</p><p>可能会产生同一数据流的第一个数据帧在一条物理链路上传输，而第二个数据帧在另外一条物理链路上传输的情况。</p><p>这样一来同一数据流的第二个数据帧就有可能比第一个数据帧先到达对端设备，从而产生接收数据包乱序的情况。</p><p>为了避免这种情况的发生，<strong>Eth-Trunk采用逐流负载分担的机制</strong>。</p><p>把数据帧中的地址通过HASH算法生成HASH-KEY值，然后根据这个数值在Eth-Trunk转发表中寻找对应的出接口。</p><p>不同的MAC或IP地址HASH得出的HASH-KEY值不同，从而出接口也就不同；源目地址不变的同一数据流，其出接口就保持为同一个。</p><p>这样既保证了同一数据流的帧在同一条物理链路转发，又实现了流量在聚合组内各物理链路上的负载分担。</p><p>逐流负载分担能保证包的顺序，但不能保证带宽利用率。</p><p>Eth-trunk支持基于报文的IP地址或MAc地址来进行负载分担，可以配置不同的模式将数据流分担到不同的成员接口上。</p><p>常见的模式有:源lP、源MAc、目的IlP、目的MAc、源IP+目的IP、源MAC+目的MAC，共6种。</p><p>实际业务中用户需要根据业务流星特征选择配置合适的负载分担方式。业务流量中某种参数变化越频繁，选择与此参数相<br>关的负载分担方式就越容易实现负载均衡。</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/904fd832e0aa5b1aa2aa0.png" alt="图7——负担算法"></p><blockquote><p>图中这种数据流可能发生在两台路由器间。</p></blockquote><p><strong>默认的负载分担方式为源IP+目的IP，可适用于大多数场景，一般不需要做修改。</strong></p><blockquote><h6 id="操作步骤-2"><a href="#操作步骤-2" class="headerlink" title="操作步骤"></a>操作步骤</h6><ol><li><p>执行命令<strong>system-view</strong>，进入系统视图。</p></li><li><p>执行命令<strong>interface eth-trunk</strong> <em>trunk-id</em>，进入Eth-Trunk接口视图。</p></li><li><p>执行命令<strong>load-balance</strong> ?  ，配置Eth-Trunk负载分担方式。(从下方参数6选1)</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>dst-ip</td><td>根据目的IP进行哈希算法</td></tr><tr><td>dst-mac</td><td>根据目的MAC进行哈希算法</td></tr><tr><td>src-dst-ip</td><td>根据源IP+目的IP进行哈希算法</td></tr><tr><td>src-dst-mac</td><td>根据源MAC+目的MAC进行哈希算法</td></tr><tr><td>src-ip</td><td>根据源IP进行哈希算法</td></tr><tr><td>src-mac</td><td>根据源MAC进行哈希算法</td></tr></tbody></table></li></ol></blockquote><blockquote><p>注：手工模式也可以配置负载分担。</p></blockquote><h2 id="综合实验"><a href="#综合实验" class="headerlink" title="综合实验"></a>综合实验</h2><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/67d8cf294021160f2dce3.png" alt="图8——链路聚合实验"></p><p>就图例拓扑，进行LACP模式链路聚合的配置，同时再配上vlan。</p><blockquote><p>路由器的0、1、2口与交换机1的1、2、3口进行链路聚合。活动2条，备用1条。</p><p>交换机2处于vlan10  10.1.1.0&#x2F;24，且1、2口与交换机1的4、5口链路聚合。活动1条，备用1条。</p><p>交换机3处于vlan20  20.1.1.0&#x2F;24，且1、2口与交换机1的6、7口链路聚合。活动1条，备用1条。</p></blockquote><p>先完成底下交换部分的配置：</p><p>对于交换机2，进行如下配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">system-view</span><br><span class="line">sysname SW2</span><br><span class="line">vlan batch 10 20</span><br><span class="line"></span><br><span class="line">interface GigabitEthernet0/0/3</span><br><span class="line">port link-type access</span><br><span class="line">port default vlan 10</span><br><span class="line"></span><br><span class="line">interface Eth-Trunk 1</span><br><span class="line">mode lacp-static</span><br><span class="line">max active-linknumber 1</span><br><span class="line">lacp preempt enable</span><br><span class="line">trunkport GigabitEthernet 0/0/1 0/0/2</span><br><span class="line"></span><br><span class="line">port link-type trunk</span><br><span class="line">port trunk allow-pass vlan 10 20</span><br></pre></td></tr></table></figure><p>对于交换机3，进行如下配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">system-view</span><br><span class="line">sysname SW3</span><br><span class="line">vlan batch 10 20</span><br><span class="line"></span><br><span class="line">interface GigabitEthernet0/0/3</span><br><span class="line">port link-type access</span><br><span class="line">port default vlan 20</span><br><span class="line"></span><br><span class="line">interface Eth-Trunk 1</span><br><span class="line">mode lacp-static</span><br><span class="line">max active-linknumber 1</span><br><span class="line">lacp preempt enable</span><br><span class="line">trunkport GigabitEthernet 0/0/1 0/0/2</span><br><span class="line"></span><br><span class="line">port link-type trunk</span><br><span class="line">port trunk allow-pass vlan 10 20</span><br></pre></td></tr></table></figure><p>交换机1进行如下配置，以完成交换机之间的通信：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">system-view</span><br><span class="line">sysname SW1</span><br><span class="line">vlan batch 10 20</span><br><span class="line"></span><br><span class="line">interface Eth-Trunk 1</span><br><span class="line">mode lacp-static</span><br><span class="line">max active-linknumber 1</span><br><span class="line">lacp preempt enable</span><br><span class="line">trunkport GigabitEthernet 0/0/4 0/0/5</span><br><span class="line"></span><br><span class="line">port link-type trunk</span><br><span class="line">port trunk allow-pass vlan 10 20</span><br><span class="line"></span><br><span class="line">interface Eth-Trunk 2</span><br><span class="line">mode lacp-static</span><br><span class="line">max active-linknumber 1</span><br><span class="line">lacp preempt enable</span><br><span class="line">trunkport GigabitEthernet 0/0/6 0/0/7</span><br><span class="line"></span><br><span class="line">port link-type trunk</span><br><span class="line">port trunk allow-pass vlan 10 20</span><br><span class="line"></span><br><span class="line">interface Vlanif 10</span><br><span class="line">ip address 10.1.1.254 24</span><br><span class="line"></span><br><span class="line">interface Vlanif 20</span><br><span class="line">ip address 20.1.1.254 24</span><br></pre></td></tr></table></figure><p>经过以上配置，PC1与PC2即可通信。聚合的链路只启用一条，另外一条作为备用。</p><hr><p>对于路由器R1，其配置为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">system-view</span><br><span class="line">sysname R1</span><br><span class="line">ip route-static 10.1.1.0 24 30.1.1.1</span><br><span class="line">ip route-static 20.1.1.0 24 30.1.1.1</span><br><span class="line"></span><br><span class="line">lacp priority 100</span><br><span class="line"></span><br><span class="line">interface Eth-Trunk 1</span><br><span class="line">undo portswitch</span><br><span class="line">mode lacp-static</span><br><span class="line">max active-linknumber 2</span><br><span class="line">trunkport GigabitEthernet 0/0/0 to 0/0/2</span><br><span class="line">lacp preempt enable</span><br><span class="line">ip address 30.1.1.254 24</span><br></pre></td></tr></table></figure><blockquote><p>ip route-static命令为配置静态路由，有关这部分的内容之后会单独介绍，目前这么配置即可。</p><p>对于路由器而言，配置链路聚合接口后需要使用undo portswitch命令切换接口层级，否则无法添加接口成员。</p></blockquote><p>则交换机1再追加以下配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Eth-Trunk 0</span><br><span class="line">mode lacp-static</span><br><span class="line">max active-linknumber 2</span><br><span class="line">trunkport GigabitEthernet 0/0/1 to 0/0/3</span><br><span class="line">lacp preempt enable</span><br><span class="line"></span><br><span class="line">interface Vlanif 1</span><br><span class="line">ip address 30.1.1.1 24</span><br></pre></td></tr></table></figure><blockquote><p>Eth-Trunk默认vlan接口类型为hybrid。其次所有交换机接口vlan默认为vlan1。因此可直接创建vlan1的vlanif接口，配置ip地址。</p></blockquote><p>以上配置完之后，PC1、PC2、交换机1、路由器1就都可以互相访问了。聚合链路也都保持着1条备用的非活动链路。</p><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>ensp模拟器与真机是存在差距的，真机中聚合链路的活动链路故障后，切换为其他链路是很快的，几乎感受不到网络的异常。</p><p>实验没有带着一行一行命令进行解释是希望各位能翻着看之前的命令介绍，同时多动手敲一敲。</p><p>另外关于链路聚合的原理，个人觉得不是很重要，所以没有介绍，有兴趣的话，可以自行查阅学习。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 交换 </tag>
            
            <tag> 链路聚合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【交换基础】vlan、接口类型、vlanif</title>
      <link href="/2023/12/11/%E3%80%90%E4%BA%A4%E6%8D%A2%E5%9F%BA%E7%A1%80%E3%80%91vlan%E3%80%81%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E3%80%81vlanif/"/>
      <url>/2023/12/11/%E3%80%90%E4%BA%A4%E6%8D%A2%E5%9F%BA%E7%A1%80%E3%80%91vlan%E3%80%81%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E3%80%81vlanif/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 交换机（二层交换机）：工作在数据链路层（第二层），<strong>根据目标MAC地址来转发数据帧。</strong>它可以通过学习源MAC地址和物理接口之间的映射关系，建立转发表，从而实现数据帧的快速转发。 </p><p> 这一部分的内容已经在上期的科普篇里有所介绍了，这边不再进行说明讲解。 </p><p> 随着技术的发展，交换机也拓展出了基于网络层（第三层）的功能。为了区分，通常会称为三层交换机。 </p><p> <strong>三层交换机有了网络层的功能</strong>，就可以<strong>作为网关实现跨网段的转发通信行</strong>，甚至分配动态ip。 </p><blockquote><p>另外，交换机还有傻瓜交换机与可网管交换机之分： </p><p>傻瓜交换机 —— 特指无法进行配置，插上即可使用。 </p><p>网管交换机 —— 也称企业级交换机，特指可以进行命令配置的交换机。 </p><p>注：<strong>网管交换机并不都是三层交换机，二层交换机一样也有网管级的。</strong></p></blockquote><p> 本篇主要是围绕着vlan（虚拟局域网）进行讲解介绍。 先从vlan技术（二层交换机）开始讲解一步步拓展到vlanif技术（三层交换机）。<br> 内容的介绍会涉及到命令的配置，使用的是华为的ensp模拟器来进行模拟配置。</p><h1 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h1><h2 id="什么是VLAN"><a href="#什么是VLAN" class="headerlink" title="什么是VLAN"></a>什么是VLAN</h2><p> <strong>VLAN（Virtual Local Area Network）即虚拟局域网</strong>，是一种逻辑上的网络分割技术，<strong>用于将物理上的局域网（LAN）划分成多个虚拟的子网（多个广播域）</strong>。  </p><p>通过使用VLAN，可以将不同的设备或用户组织到不同的逻辑网络中，即使它们物理上连接的是同一个交换机上。（不同交换机也可组织到同一个VLAN）</p><p> <strong>每个VLAN是一个广播域，VLAN内的主机间可以直接通信，而VLAN间则不能直接互通</strong>。(一方面是隔离广播域后无法使用ARP查找设备mac地址，另一方面是协议规定了设备遇到不同VLAN的数据帧就丢弃)</p><p>此外，VLAN还可以简化网络管理，因为管理员可以根据需要对每个VLAN进行配置和管理，而无需干扰其他VLAN。</p><p>VLAN是基于交换机的，交换机通过将数据帧打上VLAN标签来识别不同的VLAN。这些标签可以基于端口、MAC地址或其他标识符进行配置。  </p><p>当数据帧在交换机之间传输时，<strong>交换机会根据VLAN标签将数据帧转发到正确的VLAN中的目标设备</strong>。</p><p>总之，VLAN是一种用于划分局域网的技术，可以提供更好的网络管理、性能和安全性。  </p><h2 id="为什么需要VLAN"><a href="#为什么需要VLAN" class="headerlink" title="为什么需要VLAN"></a>为什么需要VLAN</h2><p>在二层网络中，一台主机发送一个广播数据帧，网络中所有主机都会收到，网络中的每一条链路都至少传输了一次广播包。我们把这样的转发接收广播数据帧的区域叫做广播域。  </p><p><strong>广播域范围过大，其中的广播数据会存在过多，占用太多带宽（网络资源），影响网络性能。</strong>  </p><p>在此之前，我们采用的方案是划分网段，使网络设备分处于不同的局域网（LAN），再由<strong>路由器</strong>来隔离广播域。广播包就被限定在每一个局域网内，不会影响到处于其他局域网的设备。  </p><p>而VLAN，即虚拟局域网，这种技术不需要修改设备的ip地址与网段，直接在<strong>二层网络</strong>中不涉及网络层的情况下就能虚拟出局域网，完成广播域的隔离。  </p><p>还有一个更主要的原因是原先使用网段划分，需要使用大量的路由器。<strong>如果依旧采用单台路由器配合多台交换机的方案，那还是无法隔离</strong>。</p><p>这是因为交换机只解封装到二层，发现数据帧报头的广播地址，便会从交换机的所有接口转发出去，不会去区分网段是否一致。</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/0ce8198d35b4c07a68ecd.png" alt="图1——前言拓扑"></p><blockquote><p>例如以上拓扑图，PC1是10网段，PC2也是10网段，但PC3是30网段。</p><p>PC1要与PC2通信，因为没有PC2的mac地址，于是发送了ARP广播来询问PC2的mac地址。</p><p>我们可能会觉得只是去查PC2的10.0.0.2这个ip对应的mac地址是多少，那么不会找到处于30网段的PC3去。</p><p>但只要去抓包，就能知道交换机2会将ARP包也转发给PC3跟路由器。</p></blockquote><p>引入vlan这种二层技术，只需要交换机就可以完成广播域的隔离了。</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/4b323cb19471ec3628159.png" alt="图2——vlan作用"></p><h2 id="VLAN技术带来的问题"><a href="#VLAN技术带来的问题" class="headerlink" title="VLAN技术带来的问题"></a>VLAN技术带来的问题</h2><p>VLAN技术，可以在数据链路层的层面进行隔绝广播域，这非常好的解决了广播泛滥带来的性能显著下降甚至造成网络不可用等问题。但也正因为隔绝了广播域，它带来了新的问题。  </p><p>广播包无法发送到其他vlan下的设备，意味着ARP包也无法跨vlan传播，这就导致<strong>无法获取其他vlan下设备的mac地址</strong>，进而导致不同vlan之间无法进行通信。**[ 但实际上即便知道了mac地址并手动绑定进ARP表中，也无法跨vlan通信；交换机不仅隔绝了广播包，不同vlan之间的单播包也会被拦截。]**</p><p>不过，也有很多人将这一问题视为vlan的优点，认为这<strong>增加了网络的安全性</strong>。  </p><p>想要解决这个问题，一个是逻辑上使vlan失效（后面就会介绍的标签管理）；</p><p>另一个方法就是通过三层设备的路由功能来实现，也就是使用网关，并为每一个vlan划定好网段；网关可以使用路由器，也可以使用三层交换机（开启vlanif）。</p><p>这一部分内容稍后会详细介绍，接下来我们讲一讲VLAN的原理与配置。  </p><h2 id="VLAN的原理"><a href="#VLAN的原理" class="headerlink" title="VLAN的原理"></a>VLAN的原理</h2><p>IEEE于1999年颁布了用于标准化VLAN实现方案的802.1Q协议标准草案，该标准定义了VLAN的数据帧结构。  </p><p>在传统的以太网数据帧基础上（源MAC地址字段和协议类型字段之间）增加4个字节的802.1Q Tag。</p><blockquote><p><strong>TPID</strong>（Tag Protocol Identifier）：TPID是VLAN标签的第一个字段，占据2个字节。它<strong>用于标识VLAN标签的存在</strong>，并指示后续字段的解释方式。对于以太网中的VLAN标签，TPID的值通常为0x8100。</p><p>PRI（Priority Code Point）：PRI字段是VLAN标签的第二个字段，占据3个比特位。PRI字段用于指示数据帧的优先级，用于实现QoS（Quality of Service，服务质量）功能。PRI字段的值范围从0到7，值越大优先级越高。当网络阻塞时，交换机优先发送优先级高的数据帧。</p><p>CFI（Canonical Format Identifier）：CFI字段是VLAN标签的第三个字段，占据1个比特位。CFI字段用于指示MAC地址是否采用规范格式。当CFI字段的值为0时，表示MAC地址采用规范格式；当CFI字段的值为1时，表示MAC地址采用非规范格式。</p><p><strong>VID</strong>（VLAN Identifier）：VID字段是VLAN标签的最后一个字段，占据12个比特位。<strong>VID字段用于标识数据帧所属的VLAN</strong>。每个VLAN都有一个唯一的VLAN ID，可以支持最多4096个不同的VLAN。<strong>通过VID字段，交换机可以根据VLAN ID来识别并转发数据帧到相应的VLAN</strong>。(<strong>协议规定了VLAN0与VLAN4095作为保留，因此真正可使用的为4094个</strong>)</p></blockquote><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/6f0a5b5eb68ea089a9db4.png" alt="图3——vlan标签"></p><p>请记住一点：<strong>VLAN是在交换设备上的技术，网络终端（PC）是不会发送与接收带有VLAN的数据帧。</strong></p><p>人为的在交换机上配置VLAN的划分规则后，PC发送过来的数据帧在经过交换机时，就会被交换机添加上VLAN标签。</p><p>交换机根据vlan标签来确定数据帧的发送范围，而当下一跳就为目的终端时，交换机会先将vlan标签剥离再发送。</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/ccfa1235bb485bb68b304.png" alt="图4——vlan标签的作用"></p><p><strong>打标签与剥离标签是vlan技术的重点内容。</strong>为了更好更方便的管理vlan标签，就引入了接口类型的概念。</p><p>实际上vlan的实现方式有好几种，但<strong>目前广泛采用的都是基于接口的方式</strong>。</p><p>简单说一下其他方式吧：【以下方式不被广泛采用都是因为配置繁琐、后期维护与拓展不易或有较大的漏洞（比如mac地址可被人为修改）】</p><blockquote><p><em>基于MAC地址划分：根据数据帧的源MAC地址来划分VLAN。</em></p><blockquote><p>网络管理员预先配置MAC地址和VLAN ID映射关系表，当交换机收到的是传统数据帧时，就依据该表给数据帧添加指定VLAN的标签，然后数据帧将在指定VLAN中传输。</p></blockquote><p><em>基于IP子网划分：根据数据帧中的源IP地址和子网掩码来划分VLAN。</em></p><blockquote><p>网络管理员预先配置IP地址和VLAN ID映射关系表，当交换机收到的是传统数据帧，就依据该表给数据帧添加指定VLAN的标签，然后数据帧将在指定VLAN中传输。</p></blockquote><p><em>基于协议划分：根据数据帧所属的协议（族）类型及封装格式来划分VLAN。</em></p><blockquote><p>网络管理员预先配置以太网帧中的协议域和VLAN ID的映射关系表，如果收到的是传统数据帧，就依据该表给数据帧添加指定VLAN的标签，然后数据帧将在指定VLAN中传输。</p></blockquote><p><em>基于策略划分：根据配置的策略划分VLAN，能实现多种组合的划分方式，包括接口、MAC地址、IP地址等。</em></p><blockquote><p>网络管理员预先配置策略，如果收到的是传统数据帧，且匹配配置的策略时，给数据帧添加指定VLAN的标签，然后数据帧将在指定VLAN中传输。</p></blockquote></blockquote><hr><p>在一个VLAN交换网络中，以太网数据帧主要有以下两种形式：</p><ul><li><strong>无标签帧（Untagged帧）</strong>：原始的、未加入4字节VLAN标签的传统数据帧。</li><li><strong>有标签帧（Tagged帧）</strong>：加入了4字节VLAN标签的帧。</li></ul><h2 id="VLAN的接口类型和VLAN标签的处理机制"><a href="#VLAN的接口类型和VLAN标签的处理机制" class="headerlink" title="VLAN的接口类型和VLAN标签的处理机制"></a>VLAN的接口类型和VLAN标签的处理机制</h2><p>交换机内部处理的数据帧一律都带有VLAN标签，而现网中交换机连接的设备有些只会收发传统数据帧，要与这些设备交互，就需要接口能够识别传统数据帧并在收发时给帧添加&#x2F;剥除VLAN标签。</p><p>同时，现网中属于同一个VLAN的用户可能会被连接在不同的交换机上，且跨越交换机的VLAN可能不止一个。</p><p><strong>如果需要用户间的互通，就需要交换机与交换机之间的接口能够同时识别和发送多个VLAN的数据帧。</strong></p><p>根据接口连接对象以及对收发数据帧处理的不同，当前有VLAN的多种接口类型，以适应不同的连接和组网。</p><p>不同厂商对VLAN接口类型的定义可能不同。<strong>常见的VLAN接口类型有两种：Access和Trunk。</strong></p><p>对于华为设备来说，还有第三种接口类型：Hybrid（一般不使用Hybrid）</p><p><strong>接口类型是在交换机上配置的</strong>，不同接口类型有不同的机制，接下来就学习一下这三种接口类型。</p><h2 id="默认VLAN-缺省VLAN"><a href="#默认VLAN-缺省VLAN" class="headerlink" title="默认VLAN&#x2F;缺省VLAN"></a>默认VLAN&#x2F;缺省VLAN</h2><p>在计算机术语中，<strong>“缺省”二字表示默认的意思</strong>。因为它听起来总是不那么适应，所以本文都会称为默认。</p><p><strong>默认VLAN代指PVID</strong>（Port Default VLAN ID）。</p><p>前面提到，<strong>交换机处理的数据帧都带Tag</strong>，当交换机收到Untagged帧（不带标签的传统数据帧）时，就需要给该帧添加Tag，添加什么Tag，就由接口上的默认VLAN决定。它的具体作用是：</p><ul><li>当接口接收数据帧时：如果接口收到一个Untagged帧，交换机会根据PVID给此数据帧添加等于PVID的Tag，然后再交给交换机内部处理；如果接口收到一个Tagged帧，交换机则不会再给该帧添加接口上PVID对应的Tag。</li><li>当接口发送数据帧时：如果发现此数据帧的Tag的VID值与PVID相同，则交换机会将Tag去掉，然后再从此接口发送出去。</li></ul><p><strong>每个接口都有一个默认VLAN。默认情况下，所有接口的默认VLAN均为VLAN1</strong>，但用户可以根据需要进行配置：</p><ul><li>对于Access接口，默认VLAN就是它允许通过的VLAN，修改接口允许通过的VLAN即可更改接口的默认VLAN。</li><li>对于Trunk接口和Hybrid接口，其接口可以允许多个VLAN通过，修改接口允许通过的VLAN不会更改接口的默认VLAN，修改默认VLAN需要使用专门的命令。</li></ul><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><p><strong>对一台交换机来说，接口都是独立</strong>，不止是交换机外部表现为独立，在交换机内部也是独立的。</p><p>后面介绍接口类型时，请一定不要将交换机当作一个整体。</p><p><strong>交换机的配置都是基于接口的</strong>，每一个接口都可以进行独立的配置。</p><p>所以一个数据帧进入交换机的接口时就开始进行处理，<strong>当处理完的数据帧，在交换机内部被移交到另一个接口时，会根据那一个接口的配置再进行一次处理</strong>。</p><p>理解了这一点之后，后面对接口类型的学习就会很清晰了。</p><h2 id="Access接口"><a href="#Access接口" class="headerlink" title="Access接口"></a>Access接口</h2><p><strong>Access接口一般用于和不能识别Tag的用户终端（如PC、服务器）相连，或者不需要区分不同VLAN成员时使用。</strong></p><p><strong>Access接口大部分情况只能收发Untagged帧</strong>。</p><p><strong>交换机内部只处理Tagged帧</strong>，所以Access接口需要给收到的数据帧添加VLAN标签，也就必须配置一个默认的VLAN。</p><p><strong>配置默认VLAN后，该Access接口也就加入了该VLAN，收到不带标签的数据帧就会打上该默认VLAN的标签。</strong></p><p><strong>如果Access接口收到带有Tag的帧，并且帧中VID与PVID（默认vlan）相同时，Access接口就接收并处理该帧。</strong></p><blockquote><p>当<strong>数据帧</strong>中的vlan标签内部的<strong>VID</strong>（vlan id）等于<strong>接口</strong>的<strong>PVID</strong>，那就说明这是萝卜回萝卜坑了。</p><p>都是同属于一个vlan，自然就可以正常接收该数据帧</p><p>如果ID不同，即不是同一vlan的数据帧，就会丢弃。</p></blockquote><p><strong>此外，当交换设备在发送带有Tag的帧前，Access接口会剥离Tag。</strong></p><blockquote><p>因为access接口在设定上是与无法识别带vlan标签的终端连接的。</p><p>因此，当一个带标签数据帧的目标链路是access接口所在的链路，那么交换机在发送数据帧时会将标签剔除。</p></blockquote><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/8e4311234a6ed980c5d3f.png" alt="图5——access接口标签处理"></p><h2 id="Trunk接口"><a href="#Trunk接口" class="headerlink" title="Trunk接口"></a>Trunk接口</h2><p><strong>Trunk接口一般用于连接交换机</strong>、路由器、AP。</p><p>它可以<strong>允许多个VLAN的帧带Tag通过</strong>，但只允许<strong>属于默认VLAN的帧从该类接口上发出时不带Tag</strong>（即剥离标签）。</p><blockquote><p>说白了，就是与access接口互补，access接口是用于连接不能识别标签的终端；trunk接口就是用于可以识别标签的设备。</p><p>因此trunk接口可以收发多个vlan的数据帧，只需要配置了允许哪些vlan标签的数据帧通过即可。</p><p>至于剥离标签的机制，大部分不剥离，只有跟PVID一致的vlan标签才剥离。</p></blockquote><p>Trunk接口上的默认VLAN，有的厂商也将它定义为native VLAN。</p><p>当Trunk接口收到Untagged帧时，会为Untagged帧打上Native VLAN对应的Tag。</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/331010dae222f3b35a3ff.png" alt="图6——trunk接口标签处理"></p><h2 id="Hybrid接口"><a href="#Hybrid接口" class="headerlink" title="Hybrid接口"></a>Hybrid接口</h2><p>Hybrid接口既可以用于连接不能识别Tag的用户终端（如用户主机、服务器）和网络设备（如Hub），也可以用于连接交换机、路由器、AP。</p><p>它不仅可以允许多个VLAN的帧带Tag通过（等同于trunk），还可以把从该接口<strong>发出的帧</strong>根据需要，设定某些VLAN的帧不带Tag（即<strong>剥除Tag</strong>）。</p><blockquote><p><strong>接收原理与trunk一样，而发送时，可以根据预先配置来判断是否剥离vlan标签。</strong></p></blockquote><p>Hybrid接口和Trunk接口在很多应用场景下可以通用，<strong>但在某些应用场景下，必须使用Hybrid接口。</strong></p><p>比如在灵活<a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/QinQ.html">QinQ</a>中，服务提供商网络的<strong>多个</strong>VLAN的报文在进入用户网络前，需要剥离外层VLAN Tag。</p><p>此时Trunk接口不能实现该功能，因为Trunk接口只能使该接口默认VLAN的报文不带VLAN Tag通过。</p><blockquote><p>Hybrid接口可以自由的使用命令来让交换机对什么vlan标签直接转发，对什么vlan标签进行剥离，有很大的操作空间。</p><p>但一般来说不会去使用它，只有当access与trunk都无法满足需求，且设备与链路还有vlan必须这样配置时，才会采用Hybrid接口。</p><p>这是因为现网中，很少全部采用同一品牌的设备，而Hybrid接口目前是华为设备使用的技术。更进一步的说，就是Hybrid接口还未被广大的基层网络工程师学习接受。</p></blockquote><h2 id="接口类型的命令配置"><a href="#接口类型的命令配置" class="headerlink" title="接口类型的命令配置"></a>接口类型的命令配置</h2><p>以上是三种接口类型的原理描述。接下来介绍一下配置命令，后面就使用命令来完成一个简易的拓扑配置。</p><p><strong>加粗</strong>的为固定的命令语法，<em>斜体</em>是自行修改的变量，具体用法可以参照后面的拓扑配置。</p><h3 id="创建vlan"><a href="#创建vlan" class="headerlink" title="创建vlan"></a>创建vlan</h3><p>首先需要在交换机内部创建好vlan，<strong>注意每一台交换机都需要配置vlan</strong>。</p><ol><li>执行命令<strong>system-view</strong>，进入系统视图。</li><li>执行命令<strong>vlan</strong> <em>vlan-id</em>，创建VLAN并进入VLAN视图。如果VLAN已经创建，则直接进入VLAN视图。<ul><li>如果需要批量创建，执行命令<strong>vlan bath</strong> <em>vlan-id1</em> <em>vlan-id2</em> ，命令后可创建多个vlan。每个vlan-id之间用空格隔开。</li><li>如果批量创建的vlan是递增的，可执行命令<strong>vlan batch</strong> <em>vlan-id1</em> to <em>vlan-idn</em>  ，比如创建2到10，就<strong>vlan bath</strong> <em>2</em> to <em>1</em>0</li></ul></li><li>执行命令<strong>quit</strong>，返回系统视图。</li></ol><h3 id="配置access接口"><a href="#配置access接口" class="headerlink" title="配置access接口"></a>配置access接口</h3><ol><li>执行命令<strong>interface</strong> <em>interface-type</em> <em>interface-number</em>，进入需要加入VLAN的以太网接口视图。</li><li>执行命令<strong>port link-type</strong> <strong>access</strong>，配置接口类型为access。</li><li>执行命令<strong>port default vlan</strong> <em>vlan-id</em>，配置接口的默认VLAN并将接口加入到指定VLAN。</li><li>（可选）执行命令<strong>port discard tagged-packet</strong>，配置接口丢弃入方向带VLAN 标签的数据帧，即不接收带标签的数据帧。</li></ol><blockquote><p>如果要批量的配置access接口，可以在vlan视图下直接添加接口。</p><ol><li>执行命令<strong>vlan</strong> <em>vlan-id</em>，进入VLAN视图。</li><li>执行命令<strong>port</strong> <em>interface-type</em> <em>interface-number</em> ，添加接口到vlan（以access的类型）</li></ol><p>该命令指定的接口数量也可以使用批量方式，接口号之间空格隔开或是使用“to”指定范围。</p></blockquote><h3 id="配置trunk接口"><a href="#配置trunk接口" class="headerlink" title="配置trunk接口"></a>配置trunk接口</h3><ol><li>执行命令<strong>interface</strong> <em>interface-type</em> <em>interface-number</em>，进入需要加入VLAN的以太网接口视图。</li><li>执行命令<strong>port link-type</strong> <strong>trunk</strong>，配置接口类型为trunk。</li><li>执行命令<strong>port trunk allow-pass vlan</strong> <em>vlan-id</em>，配置放行通过的vlan。<ul><li>批量添加也是可以多个vlan-id之间用空格隔开，或者使用“to”指代连续递增的vlan-id。</li><li>另外可以使用port trunk allow-pass vlan all，表示放行所有vlan。</li></ul></li><li>（可选）执行命令<strong>port trunk pvid vlan</strong> <em>vlan-id</em>，配置Trunk接口的默认VLAN。<ul><li>需要剥离标签的情景下使用，发送数据帧是会剥离与该pvid相同的vlan标签。</li></ul></li></ol><h3 id="配置hybrid接口"><a href="#配置hybrid接口" class="headerlink" title="配置hybrid接口"></a>配置hybrid接口</h3><ol><li><p>执行命令<strong>port link-type</strong> <strong>hybrid</strong>，配置接口类型为hybrid。</p></li><li><p>根据实际需要选择任一方式将接口加入VLAN（批量添加的方式与trunk接口一样）：</p><p>执行命令<strong>port hybrid tagged vlan</strong> <em>vlan-id</em>，配置指定vlan携带标签。（相当于放行vlan，等同于Trunk接口下的‘<strong>port trunk allow-pass vlan</strong> <em>vlan-id</em>’。）</p><p>执行命令<strong>port hybrid untagged vlan</strong> <em>vlan-id</em> ，配置指定vlan不带标签。（相当于放行vlan的同时剥离标签。注意：<strong>只在出接口，也就是发送数据帧时才剥离标签。</strong>）</p></li><li><p>（可选）执行命令<strong>port hybrid pvid vlan</strong> <em>vlan-id</em>，配置Hybrid接口的默认VLAN。</p></li></ol><h3 id="批量添加方式"><a href="#批量添加方式" class="headerlink" title="批量添加方式"></a>批量添加方式</h3><p>接口类型的配置是基于接口的，一般的网管交换机都是24口，一个一个配置很费事。</p><p>可以使用接口组，同时对多个接口进行<strong>相同</strong>的配置。配置不同的话，就还是得一个一个配。</p><p>使用<strong>port-group</strong> <em>group-name</em> 命令创建接口组，指定接口。再按一般的接口类型配置命令进行配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;HUAWEI&gt; system-view</span><br><span class="line">[HUAWEI] port-group pg1</span><br><span class="line">[HUAWEI-port-group-pg1] group-member gigabitethernet0/0/1 to gigabitethernet0/0/5</span><br><span class="line">[HUAWEI-port-group-pg1] port link-type access</span><br><span class="line">[HUAWEI-port-group-pg1] port default vlan 10</span><br></pre></td></tr></table></figure><h2 id="跨vlan通信"><a href="#跨vlan通信" class="headerlink" title="跨vlan通信"></a>跨vlan通信</h2><p>前面提到过，不同vlan之间无法互相通信，想要跨vlan通信有两种方法，一是使vlan”失效“，二是借助网关。</p><p>接下来就分开介绍这两种方法。</p><h3 id="使用接口类型的配置"><a href="#使用接口类型的配置" class="headerlink" title="使用接口类型的配置"></a>使用接口类型的配置</h3><p>vlan间的通信隔离实际就是通过vlan标签完成的，那么只要让<strong>跨vlan时传递的数据帧不携带vlan标签，就可以实现跨vlan通信。</strong></p><p>需要利用有三点：</p><ul><li>access接口发送的数据帧不携带标签。</li><li>接口要发送的数据帧携带的vlan标签id与该接口的默认vlan的id相同时就会剥离标签。</li><li>采用hybrid接口来剥离与目标终端相连接口的数据帧标签。</li></ul><h4 id="基于access与trunk的配置"><a href="#基于access与trunk的配置" class="headerlink" title="基于access与trunk的配置"></a>基于access与trunk的配置</h4><p>基于前两点就可以实现跨vlan通信了，以下就举一个拓扑案例。</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/3ef9129ec58b6f4196c7f.png" alt="图7——跨vlan通信拓扑1"></p><p>三台交换机串联在一起，每台交换机底下有一台PC，其中交换机1与3下的PC划分为vlan10；交换机2下的PC划分为vlan20。</p><p>PC无法识别带标签的数据帧，那么交换机与PC之间的接口就必须采用access接口。同时已经划分好了vlan，所以该接口的配置命令就完全确定下来了。</p><blockquote><p>三个交换机都使用以下的配置，只是在交换机2将vlan-id改为20；注意括号之后的加粗字符才是真正键入的命令。</p></blockquote><blockquote><p><magiku><strong>system-view</strong><br>[magiku]<strong>vlan 10</strong><br>[magiku-vlan10]<strong>q</strong><br>[magiku]<strong>interface g 0&#x2F;0&#x2F;1</strong><br>[magiku-GigabitEthernet0&#x2F;0&#x2F;1]<strong>port link-type access</strong><br>[magiku-GigabitEthernet0&#x2F;0&#x2F;1]<strong>port default vlan 10</strong></p></blockquote><p>因为涉及了多个vlan，所以交换机之间无法配置为access接口（access接口只能通行一个vlan），必须采用trunk接口。</p><p>同时该接口需要放行vlan10与20，剩下的就是默认vlan（pvid）的确定了。</p><p>现在让我们以交换机1为焦点，只有当标签为vlan10的数据帧才能转发给PC1，那么交换机1的trunk接口所接收到的数据帧就必须为vlan10。</p><p>这有两种方式：（可以往回翻，再重新看一下trunk接口处理标签的机制）</p><ul><li>一是交换机2发来的数据帧不带标签且交换机1的trunk接口默认vlan为10。</li><li>二是交换机2发来的数据帧携带vlan10的标签</li></ul><blockquote><p>不过方式二其实无法做到，因为想发出vlan10的标签。</p><p>在该拓扑之下，只能是交换机2在1号口收到的数据帧，处理为vlan10的标签。</p><p>这就要将1号口改为vlan10，而这就不满足PC2设置为vlan20的要求了。</p></blockquote><p>交换机2收到PC发过来的数据帧会打上vlan20的标签，想要在发送时剥离标签的话，就要将左侧的2号口默认vlan设置为20。</p><p>当不带标签的数据帧从交换机2到达交换机1，由于交换机1的2号口初始默认vlan为vlan1，所以会打上vlan1的标签，这就无法发送给PC1。</p><p>因此还要修改交换机1的2号口默认vlan为vlan10。</p><p>这正好也满足了PC1发送数据帧到达PC2的要求。</p><p>好的，按照以上两点去配置交换机1与交换机2后，PC1与PC2就可以互相通信了。</p><p>再按这个思路去配置交换机2与交换机3之间的接口，那么三台PC之间就能互相通信了。</p><p>其中，PC1与PC3虽然同属vlan10，但数据帧在接触到交换机2的接口时，会被打上20的标签，发出时根据默认vlan的配置，会剥离20标签。</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/77a9d3c048764f31d0ba2.png" alt="图8——标签过程.png"></p><p>在交换机之间抓包的话，都是无标签。标签的变动都是在交换机内部进行的，进入交换机时打上标签，离开交换机时剥离标签。</p><p>交换机1与交换机3的配置一样：</p><blockquote><p>vlan batch 10 20</p><p>interface GigabitEthernet0&#x2F;0&#x2F;1<br> port link-type access<br> port default vlan 10</p><p>interface GigabitEthernet0&#x2F;0&#x2F;2<br> port link-type trunk<br> port trunk pvid vlan 10<br> port trunk allow-pass vlan 10 20</p></blockquote><p>交换机2的配置：</p><blockquote><p>vlan batch 10 20</p><p>interface GigabitEthernet0&#x2F;0&#x2F;1<br> port link-type access<br> port default vlan 20</p><p>interface GigabitEthernet0&#x2F;0&#x2F;2<br> port link-type trunk<br> port trunk pvid vlan 20<br> port trunk allow-pass vlan 10 20</p><p>interface GigabitEthernet0&#x2F;0&#x2F;3<br> port link-type trunk<br> port trunk pvid vlan 20<br> port trunk allow-pass vlan 10 20</p></blockquote><h5 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h5><p>基于access与trunk的配置来实现跨vlan通信有一个缺点。</p><p>那就是trunk接口只能配置一个默认vlan，所以<strong>只能剥离一个vlan标签</strong>。</p><p>同时，<strong>如果在上一个交换机剥离了标签，那么到本交换机会被打上默认vlan标签。</strong></p><p>具体点，我们把上面的拓扑修改以下，删除交换机3，将PC3连入交换机2。</p><p>因此，需要将3号口修改为access接口，配置为vlan10。</p><p>修改后，PC1与PC2依旧可以互相通信，但PC1与PC3就无法通信了（明明是同一个vlan）。</p><p>因为PC1发送的数据帧在交换机1剥离了标签，在交换机2的2号口打上了20的标签，因为vlan不同，所以交换机不会将数据帧从3号口发送出去。</p><p>同样的，PC2与PC3也因为vlan不同，在同交换机下，无法互相通信。</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/c20393b35d48c02da12b5.png" alt="图9——拓扑修改"></p><h4 id="引入hybrid接口的配置"><a href="#引入hybrid接口的配置" class="headerlink" title="引入hybrid接口的配置"></a>引入hybrid接口的配置</h4><p>上面这种拓扑要求已经无法使用access接口与trunk接口来完成跨vlan通信了。</p><p>以交换机2为焦点，想让PC2与PC3通信，同时保持他们处于vlan20与vlan10。</p><p>那么只能是修改接口为hybrid，同时配置为剥离vlan10与20的标签，再分别配置其默认vlan。</p><blockquote><p>注：更换接口类型的话，需要删除之前的配置命令（放行vlan与pvid的命令），在之前配置的命令前打上<strong>undo</strong>用空格隔开；如果报错了，就去掉命令后面的自定义变量参数（vlan-id）。</p></blockquote><p>交换机2修改后的1号口与3号口配置</p><blockquote><p>interface GigabitEthernet0&#x2F;0&#x2F;1<br> port hybrid pvid vlan 20<br> port hybrid untagged vlan 10 20</p><p>interface GigabitEthernet0&#x2F;0&#x2F;3<br> port hybrid pvid vlan 10<br> port hybrid untagged vlan 10 20</p></blockquote><p>修改这两个接口的配置后，这三台PC就又可以互相通信了。</p><p>当然，也可以把其他的接口都修改为hybrid接口，有兴趣的话，建议自己尝试一下。</p><h3 id="使用网关的方式"><a href="#使用网关的方式" class="headerlink" title="使用网关的方式"></a>使用网关的方式</h3><p>一般来说，在企业中会基于部门、职能或办公区划分子网，再同时划分vlan来隔绝广播域。（很多管理设备与方案都是基于ip地址的）</p><p>在这种情形下，<strong>不同网段的设备之间就可以借助网关实现跨vlan通信。</strong></p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/2eb9af0aa1f4255227fc4.png" alt="图10——路由跨vlan"></p><p>这是本文一开始的拓扑图，在路由器的接口配置好IP地址，PC上的网关填写为路由器的ip地址。</p><p>再给交换机与路由器相连的接口配置好默认vlan，以保证发送无标签数据帧给路由器。</p><p>这样PC1与PC3就可以互相通信了（三层通信）。</p><p>不过这种方案不成熟，每一个vlan都需要占用一个路由器的物理接口。</p><p>成熟的采用路由器跨vlan通信的方案是单臂路由。</p><h4 id="单臂路由"><a href="#单臂路由" class="headerlink" title="单臂路由"></a>单臂路由</h4><p>所谓的单臂路由就是只使用单条链路连接下行设备的路由器方案。（单线复用）</p><p>单臂路由是通过在物理接口上虚拟出多个逻辑子接口，再配置不同的命令在这些虚拟接口上。</p><p>配置方式：</p><ol><li>执行命令<strong>interface</strong> <em>interface-type</em> <em>interface-number</em>.virtual-number ，创建并进入虚拟子接口视图</li><li>执行命令<strong>dot1q termination vid</strong> <em>vlan-id</em> ，将子接口与vlan进行关联，以处理该vlan的数据帧</li><li>执行命令<strong>ip address</strong> <em>IP地址 子网掩码</em>  ，为该子接口配置ip地址，作为该vlan的网关</li><li>执行命令<strong>arp broadcast enable</strong> ，使接口可以收发ARP广播包（旧型号的华为设备默认不开启该功能，不开启的话无法通信）</li></ol><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/eeeddfa296bcdf6e6e74f.png" alt="图11——单臂路由"></p><p>之前的拓扑图就可以修改为这样。AR1路由器上虚拟出了两个接口，配置了两个不同的ip地址作为10网段与30网段的网关地址。</p><p>交换机2与路由器间的链路就按正常的trunk方式配置，放行vlan10与vlan30的数据帧。</p><blockquote><p>interface GigabitEthernet0&#x2F;0&#x2F;4<br> port link-type trunk<br> port trunk allow-pass vlan 10 30</p></blockquote><p>路由器的配置：</p><blockquote><p>interface GigabitEthernet0&#x2F;0&#x2F;1.10<br> dot1q termination vid 10<br> ip address 10.0.0.254 255.0.0.0<br> arp broadcast enable</p><p>interface GigabitEthernet0&#x2F;0&#x2F;1.30<br> dot1q termination vid 30<br> ip address 30.0.0.254 255.0.0.0<br> arp broadcast enable</p></blockquote><p><strong>注：虚拟子接口的编号强烈建议设置为与vlan-id相同的</strong>，子接口可设置的编号范围与vlan-id的可设置范围都是一样的1-4095。</p><p>经过以上配置后，三台PC之间就可以互相通信了。（PC记得填写好子网掩码与网关地址）</p><p>同时，在路由器处抓包的话，可以看到数据帧的标签是来回切换的。</p><p>发过来的为10标签，经由路由器转发出去时就为30；反过来，收到30，发出去就为10。</p><h4 id="三层交换机与vlanif技术"><a href="#三层交换机与vlanif技术" class="headerlink" title="三层交换机与vlanif技术"></a>三层交换机与vlanif技术</h4><p>还记得我们一开始划分广播域的初衷吗——广播数据存在过多，会占用太多带宽（网络资源），影响网络性能。</p><p>使用单臂路由结合vlan技术，是完美做到了削减广播数据。</p><p>但是，进行跨vlan通信时，都需要跑到路由器上，并且还是单条链路进行收与发（一次双向通信，对上层链路的带宽占用是双倍的）。</p><p>以我们科普篇的一张企业拓扑图举例，明明只是与隔壁交换机下的一台主机互相通信，却要绕一大圈，这不仅降低效率，也占用了太多额外网络资源。</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/806480ad0d572120876ea.png" alt="图12——单路复用"></p><p>为了解决这一问题，就发展出了三层交换机，由三层交换机作为下行设备的网关，以缩小跨网段通信的“通勤”范围。</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/db93425ec7a33881dfd94.png" alt="图13——三层交换"></p><p><strong>vlanif就是三层交换机上的技术，在交换机上虚拟出拥有路由功能的三层接口，并自动绑定vlan。</strong></p><blockquote><p><strong>后期很多技术都是在该接口上配置（dns等）。</strong></p></blockquote><p>注意：</p><blockquote><p>单臂路由的子接口是虚拟在真实物理接口之下的，对应的ip是绑定在物理接口的。更换一个物理接口的话，就无法访问到。</p><p>而vlanif接口是在交换机的内部虚拟出来的三层接口，并不是绑定在某一物理接口，是绑定在vlan上的，匹配到vlan，就能访问到。</p><p>如果在多个物理接口上配置同一个vlan，那么随便接一个接口都可以访问到这个vlanif接口。</p></blockquote><p>配置方法:</p><ol><li>提前创建好vlan</li><li>执行命令<strong>interface Vlanif</strong> <em>vlan-id</em> ，创建vlanif接口，注意id号必须为已创建的vlan。</li><li>执行命令 <strong>ip address</strong> <em>IP地址 子网掩码</em> ， 为vlanif接口绑定ip地址，作为其vlan-id的网关。</li></ol><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/8dac6ce949d43ef80a79f.png" alt="图14——vlanif"></p><p>将上述单臂路由的拓扑中的路由器替换为三层交换机，拓扑中其他设备的配置不变。</p><p>只需要配置交换机3：</p><blockquote><p>vlan batch 10 30</p><p>interface GigabitEthernet0&#x2F;0&#x2F;1<br> port link-type trunk<br> port trunk allow-pass vlan 10 30</p><p>interface Vlanif10<br> ip address 10.0.0.254 255.0.0.0</p><p>interface Vlanif30<br> ip address 30.0.0.254 255.0.0.0</p></blockquote><p>三台交换机之间就又可以互相通信了。</p><h5 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h5><p>网络接口分二层接口与三层接口，<strong>路由器默认是三层接口，可以配置ip；交换机默认是二层接口，不可配置ip</strong>，只能配置vlan。</p><p>如果使用了vlanif接口作为下行设备的网关，那么就需要<strong>交换机的另一侧接口也拥有ip地址，才能做路由跳转</strong>。</p><p>这有两种方案：</p><ol><li>将交换机的接口通过命令配置修改为三层接口，然后配置ip（需要交换机支持切换）。</li><li><strong>新建一个vlan，配置在该物理接口上，然后再创建一个vlanif接口并配置ip地址</strong>。</li></ol><p>第一个方案不常用，因为第二个方案更优；可以给多个物理口配置同一个vlan，使其都使用同一个ip地址；而<strong>三层物理口无法做到多个接口使用同一个ip地址。</strong></p><p>多个物理口同ip的优势，一个是可以从每个接口独立分出，连接到傻瓜交换机或无线路由器&#x2F;AP作为接口拓展；另一个是后期链路故障时，可以很快速的通过更换接口来恢复网络。（现网中，可以提前规划配置好交换机的某两个接口为直连路由器的；这一链路故障后，直接在机房更换到空闲的另一个接口即可。）</p><p>关于三层交换机与路由器的搭配，由于还未学习路由技术，本文暂不详细介绍，之后会通过一个实验来融合讲解。</p><p>另外，也许现网中会有一些特殊需要，导致一个接口要配置给多个vlan使用。（一个接口连接多个设备，这些设备还不属于同一个vlan。这种需求可能是这个接口后带了一个不可网管的傻瓜交换机，或者是采用了ip电话）</p><p>这种需求就无法再使用本文介绍的基于接口类型的vlan划分，需要采用基于子网或者基于mac地址的方式。</p><p>有关这部分的内容，请参考官方产品文档设置，或等以后其他内容更新完毕，空闲下来了我再来做。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 交换 </tag>
            
            <tag> vlan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交换路由基础命令（查阅版）</title>
      <link href="/2023/10/19/%E4%BA%A4%E6%8D%A2%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/10/19/%E4%BA%A4%E6%8D%A2%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="交换部分——Vlan、DHCP、STP"><a href="#交换部分——Vlan、DHCP、STP" class="headerlink" title="交换部分——Vlan、DHCP、STP"></a>交换部分——Vlan、DHCP、STP</h2><p>描述：</p><blockquote><p>每台电脑代表一个部门，其中pc1、pc2、pc3、pc4则依次为vlan10、vlan20、vlan30、vlan40。</p><p>两台接入交换机LSW2、LSW3分别连接vlan10vlan20，vlan30vlan40</p><p>上行汇聚交换机LSW1开启DHCP服务，DNS设置为3.0.0.1</p><p>二层交换机直接互连，因此需开启STP，并将三层交换机设置为根。</p></blockquote><p><img src="https://telegraph-image-713.pages.dev/file/3dfc86b922ade3a582cc5.png"></p><p>下面命令，第一次都全拼且有注释，后续全为缩写</p><p>二层交换LSW2配置如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">system-view  //进入系统视图</span><br><span class="line">sysname sw2 //修改交换机名字</span><br><span class="line"></span><br><span class="line">vlan batch 10 20 30 40 //批量增设vlan10 vlan20 vlan30 vlan40</span><br><span class="line"></span><br><span class="line">interface Ethernet0/0/1 //进入1接口的视图</span><br><span class="line">port link-type access //配置为access模式</span><br><span class="line">port default vlan 10 //配置接口的VLAN</span><br><span class="line"></span><br><span class="line">int e0/0/2</span><br><span class="line">p l a</span><br><span class="line">p d v 20</span><br><span class="line"></span><br><span class="line">interface Ethernet0/0/3</span><br><span class="line">port link-type trunk //配置为trunk模式</span><br><span class="line">port trunk allow-pass vlan 10 20 30 40 //配置接口放行的VLAN</span><br><span class="line"></span><br><span class="line">int e0/0/4</span><br><span class="line">p l t</span><br><span class="line">p t a v 10 20 30 40</span><br></pre></td></tr></table></figure><p>二层交换LSW3配置如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sys</span><br><span class="line">sys sw3</span><br><span class="line"></span><br><span class="line">vlan batch 10 20 30 40</span><br><span class="line">interface Ethernet0/0/3</span><br><span class="line">port link-type access</span><br><span class="line">port default vlan 30</span><br><span class="line">int e0/0/4</span><br><span class="line">p l a</span><br><span class="line">p d v 40</span><br><span class="line">interface Ethernet0/0/1</span><br><span class="line">port link-type trunk</span><br><span class="line">port trunk allow-pass vlan 10 20 30 40</span><br><span class="line">int e0/0/2</span><br><span class="line">p l t</span><br><span class="line">p t a v 10 20 30 40</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>三层交换机LSW1配置如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">sys</span><br><span class="line">sys sw1</span><br><span class="line"></span><br><span class="line">dhcp enable // 开启DHCP功能</span><br><span class="line">vlan batch 10 20 30 40</span><br><span class="line">interface GigabitEthernet0/0/1</span><br><span class="line">port link-type trunk</span><br><span class="line">port trunk allow-pass vlan 10 20 30 40</span><br><span class="line">int g0/0/3</span><br><span class="line">p l t</span><br><span class="line">p t a v 10 20 30 40</span><br><span class="line"></span><br><span class="line">interface Vlanif10 //虚拟一个vlan10接口（需已创建vlan10）</span><br><span class="line">ip address 192.168.10.254 255.255.255.0 //为该虚拟接口配置ip地址</span><br><span class="line">dhcp select interface //在该接口上开启DHCP</span><br><span class="line">dhcp server dns-list 3.0.0.1 //在该接口DHCP上设定DNS服务地址</span><br><span class="line">int vlanif20</span><br><span class="line">ip add 192.168.20.254 24</span><br><span class="line">dhcp sel int</span><br><span class="line">dhcp server dns 3.0.0.1</span><br><span class="line">int vlanif30</span><br><span class="line">ip add 192.168.30.254 24</span><br><span class="line">dhcp sel int</span><br><span class="line">dhcp server dns 3.0.0.1</span><br><span class="line">int vlanif40</span><br><span class="line">ip add 192.168.40.254 24</span><br><span class="line">dhcp sel int</span><br><span class="line">dhcp server dns 3.0.0.1</span><br><span class="line"></span><br><span class="line">stp root primary //设置该交换机为STP的根服务器（由于华为交换机默认开启STP，所以都没有输入开启命令）</span><br></pre></td></tr></table></figure><blockquote><p>注：下游电脑获取到DHCP授权的ip地址的前提是交换机开起了DHCP功能，并在接口上启用DHCP，同时设置了VlanIf的ip地址，并且链路是放行了vlan。</p></blockquote><table><thead><tr><th>基础命令</th><th>说明与用例</th></tr></thead><tbody><tr><td>vlan *</td><td>创建vlan</td></tr><tr><td>vlan batch * *</td><td>同时创建多个vlan</td></tr><tr><td></td><td>用例：vlan batch 20 40              ||           vlan bath 20 to 40 (配置vlan20到vlan40)</td></tr><tr><td></td><td></td></tr><tr><td>interface Ethernet</td><td>进入接口模式（百兆口）</td></tr><tr><td>port link-type access</td><td>接口类型配置为access</td></tr><tr><td>port default vlan *</td><td>为接口配置vlan</td></tr><tr><td></td><td>用例：port default vlan 10</td></tr><tr><td></td><td></td></tr><tr><td>interface GigabitEthernet</td><td>进入接口模式（千兆口）</td></tr><tr><td>port link-type trunk</td><td>接口类型配置为trunk</td></tr><tr><td>port trunk pvid vlan *</td><td>接口配置pvid ——打上的vlan标签</td></tr><tr><td>port trunk allow-pass vlan *</td><td>接口放行对应的vlan通过</td></tr><tr><td></td><td>用例：port trunk allow-pass vlan 10 20</td></tr><tr><td></td><td></td></tr><tr><td>interface Vlanif *</td><td>对已创建的vlan，创建一个vlanif接口，作为改vlan的网关</td></tr><tr><td></td><td>用例：int vlan 10</td></tr><tr><td>ip address *</td><td>为vlanif接口添加ip地址——其下vlan设备的网关地址</td></tr><tr><td></td><td>用例：ip address 192.168.1.254 24</td></tr></tbody></table><h2 id="路由部分——动态路由ospf、静态路由、NAT"><a href="#路由部分——动态路由ospf、静态路由、NAT" class="headerlink" title="路由部分——动态路由ospf、静态路由、NAT"></a>路由部分——动态路由ospf、静态路由、NAT</h2><p>在上文的拓扑基础上，增加一个出口路由器</p><p><img src="https://telegraph-image-713.pages.dev/file/35e07912014e9a52d29ad.png"></p><p>首先需要配置LSW1，增加到AR1的链路信息与配置ospf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vlan 12</span><br><span class="line">interface GigabitEthernet0/0/2</span><br><span class="line"> port link-type access</span><br><span class="line"> port default vlan 12</span><br><span class="line">interface Vlanif12</span><br><span class="line"> ip address 192.168.12.2 255.255.255.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 开启ospf，并设定router-id为2.2.2.2</span><br><span class="line">// 开启area0</span><br><span class="line">// 宣告设备所连接的网段信息</span><br><span class="line">ospf 1 router-id 2.2.2.2</span><br><span class="line"> area 0.0.0.0</span><br><span class="line">  network 192.168.12.2 0.0.0.0</span><br><span class="line">  network 192.168.10.254 0.0.0.0</span><br><span class="line">  network 192.168.20.254 0.0.0.0</span><br><span class="line">  network 192.168.30.254 0.0.0.0</span><br><span class="line">  network 192.168.40.254 0.0.0.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置AR1路由器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sys</span><br><span class="line">sys r1</span><br><span class="line">int s4/0/0</span><br><span class="line">ip add 192.168.12.1 24</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ospf 1 router-id 1.1.1.1</span><br><span class="line"> area 0</span><br><span class="line">  network 192.168.12.1 0.0.0.0 </span><br><span class="line"></span><br><span class="line">//设置静态缺省路由，让未配置的网段路由统一走下一跳到12.0.0.2（假定该ip地址为AR1路由器所连接的公网路由器ip）</span><br><span class="line">ip route-static 0.0.0.0 0.0.0.0 12.0.0.2</span><br><span class="line">//将该静态缺省路由通过ospf宣告给ospf下的其他三层设备</span><br><span class="line">ospf 1</span><br><span class="line"> default-route-advertise</span><br></pre></td></tr></table></figure><p>假设在AR1路由器的右侧连接了运营商的公网路由器，其ip地址为12.0.0.2，运营商分配的公网ip为12.0.0.1</p><p>设置NAT出口策略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建一条acl策略，规则为全放行</span><br><span class="line">acl 2000</span><br><span class="line">rule 1 permit</span><br><span class="line">进入连接了公网路由器的1口，配置nat出口策略（使用2000号的acl规则）</span><br><span class="line">int g0/0/1</span><br><span class="line">nat outbound 2000</span><br></pre></td></tr></table></figure><hr><p>再增设3个路由器与2台服务器，对应公网的情况。</p><p><img src="https://telegraph-image-713.pages.dev/file/33a1c959a0ffb75afe917.png"></p><p>AR2通过串口线与AR1连接，也就是12.0.0.2ip的公网路由器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sys</span><br><span class="line">sys R2</span><br><span class="line">int s4/0/0</span><br><span class="line">  ip add 12.0.0.2 24</span><br><span class="line">int g0/0/0</span><br><span class="line">  ip add 23.0.0.2 24</span><br><span class="line">int g0/0/1</span><br><span class="line">  ip add 24.0.0.2 24</span><br><span class="line"></span><br><span class="line">ospf 1 router-id 2.2.2.2 </span><br><span class="line">area 0</span><br><span class="line">  network 12.0.0.2 0.0.0.0 </span><br><span class="line">  network 23.0.0.2 0.0.0.0 </span><br><span class="line">  network 24.0.0.2 0.0.0.0 </span><br></pre></td></tr></table></figure><p>AR3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sys</span><br><span class="line">sys R3</span><br><span class="line">int g0/0/0</span><br><span class="line">ip add 23.0.0.3 24</span><br><span class="line">int g0/0/1</span><br><span class="line">ip add 34.0.0.3 24</span><br><span class="line">int g0/0/2</span><br><span class="line">ip add 3.0.0.254 24</span><br><span class="line"></span><br><span class="line">ospf 1 router-id 3.3.3.3</span><br><span class="line">a 0</span><br><span class="line">net 23.0.0.3 0.0.0.0</span><br><span class="line">net 34.0.0.3 0.0.0.0</span><br><span class="line">net 3.0.0.254 0.0.0.0</span><br></pre></td></tr></table></figure><p>AR4</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sys</span><br><span class="line">sys R4</span><br><span class="line">int g0/0/0</span><br><span class="line">ip add 24.0.0.4 24</span><br><span class="line">int g0/0/1</span><br><span class="line">ip add 34.0.0.4 24</span><br><span class="line">int g0/0/2</span><br><span class="line">ip add 4.0.0.254 24</span><br><span class="line"></span><br><span class="line">ospf 1 router-id 4.4.4.4</span><br><span class="line">a 0</span><br><span class="line">net 24.0.0.4 0.0.0.0</span><br><span class="line">net 34.0.0.3 0.0.0.0</span><br><span class="line">net 4.0.0.254 0.0.0.0</span><br></pre></td></tr></table></figure><p>为dns服务器配置3.0.0.1地址，http服务器配置4.0.0.1地址</p><p>则私网的pc都可以连通到公网的这两个服务</p><p><img src="https://telegraph-image-713.pages.dev/file/d66b35aea5af074f68b92.png"></p><p><strong>注意：配置记得保存，以及模拟器会定期休眠。时间太久可能某一台路由器宕机了导致链路不通。</strong></p><h2 id="点对点协议认证"><a href="#点对点协议认证" class="headerlink" title="点对点协议认证"></a>点对点协议认证</h2><p>以上图为例，在右侧的AR2配置认证模式与账号密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//配置认证模式为chap</span><br><span class="line">interface Serial4/0/0</span><br><span class="line"> ppp authentication-mode chap </span><br><span class="line">q</span><br><span class="line"></span><br><span class="line">//创建用户，并将用户用于ppp协议</span><br><span class="line">aaa</span><br><span class="line"> local-user magiku password cipher magiku030</span><br><span class="line"> local-user magiku service-type ppp</span><br></pre></td></tr></table></figure><p>注：点对点协议是基于串口线连接的设备之间。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VRP命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【科普】计算机网络概述</title>
      <link href="/2023/10/19/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/10/19/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很多计算机网络的教程或课程，一开始就讲一堆术语与原理；</p><p>学习半天都还不知道有什么用，学一星期了也不清楚跟自己日常接触的网络有啥关系。</p><p>本文则是以字数少、通俗易懂为前提来科普整个网络方面的知识；</p><p>为各位阅读几百页的教材书或者观看几十集的网络课程时有一个基础的概念与体系，方便深入学习。</p><p><del>如果要以实践为主体的，在学习完本文后，跳转到本站的另一篇文章。（锐意制作中）</del></p><p>如果想深层次理解原理、进行网络搭建配置，可以去学习网络厂商的认证课程（例如华为HCIA、HCIP、HCIE）。</p><p><strong>请不要过分纠结本文中的某段话</strong>，本身出于以上原则写的，所以部分地方描述的并不严谨。</p><p><strong>请务必先看完全文，即使中途你有疑问。</strong></p><h1 id="从大家最熟悉的家庭网络开始介绍"><a href="#从大家最熟悉的家庭网络开始介绍" class="headerlink" title="从大家最熟悉的家庭网络开始介绍"></a>从大家最熟悉的家庭网络开始介绍</h1><p>一个家庭的网络从无到有，会经历这个过程</p><blockquote><p>找运营商购买宽带套餐</p><p>运营商派宽带师傅上门安装</p><p>宽带师傅从户外通信电箱拉光纤到房间</p><p>拿出光猫接上光纤，配置光猫</p><p>家庭有无线路由器的，再通过网线连上光猫</p><p>设置好无线路由器的配置后</p><p>手机连上WiFi就可以上网，电脑通过网线连接无线路由器也可以上网了。</p></blockquote><p>如果家中设备比较多，那么可以在无线路由器下再连接一个小型交换机</p><p>最终就是这样样子</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/9de074a8bc2776f472146.png" alt="图1——家庭网络架构"></p><p>简单用文字介绍，那就是 运营商提供的链路——光猫——路由器——交换机——网络设备</p><p>接下来就简单介绍这些设备在网络中起到什么作用</p><h4 id="光猫、或者说“猫”"><a href="#光猫、或者说“猫”" class="headerlink" title="光猫、或者说“猫”"></a>光猫、或者说“猫”</h4><p>这个设备的作用就是<strong>信号转换</strong>。比如将光纤中的光信号与网线中的电信号作互相转换。</p><p>这个设备英文名叫Modem，是 modulator（调制器）和 demodulator（解调器）的合成，也就是“调制解调器”。</p><p>早期大伙都音译叫做猫，于是”猫“这个叫法就这么一直流传下来了。</p><p>目前“猫”这个词所代指的设备很宽泛，不再单指调制解调器。</p><p><strong>现在运营商提供的光猫都带调制解调器功能与路由器功能</strong>，有的甚至加上了无线WiFi的功能。(也就是集成了无线路由器的功能)</p><h4 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h4><p>连接不同网络的“网关”，可以类比作不同国家之间的海关。</p><p>一般来说，<strong>一个网络中只配置一台路由器。</strong></p><p>路由器主要负责”路由“功能，也就是给网络数据的传播做一个导航指路的作用。</p><h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h4><p>一般交换机就是用来<strong>连接多台网络设备</strong>，使设备连接在一起。</p><p>同时可以理解为，交换机就是一个插排。</p><p>路由器&#x2F;其他交换机传过来的’电‘只剩一个’插座口‘，接上交换机这个‘插排’后，就可以给多台网络设备同时’供电‘了。</p><blockquote><p>以上都是以基础小白的概念以及家庭网络层面来介绍的，后续以公司网络架构为基础介绍数据包过程就会更为具体准确的讲解了</p><p>简单来说，数据包（要发送的信息）就是通过电脑主机形成、通过链路到达交换机、再用交换机转发到路由器、路由器再一路转发到目标电脑所在的局域网路由器、经过交换机到达目标电脑，由目标电脑解析数据包的内容。</p></blockquote><blockquote><p>在正式的网络中，就是一台路由器加数台交换机。</p><p>如果是规模比较大的网络，一般会考虑一个链路冗余、双机备份，避免某处线缆破损或者设备损坏导致大片设备无法上网。</p><p>这里贴一个网络拓扑图可以参考一下（与家庭网络相比最主要的区别就是将WIFI功能从路由器上剥离，使用专门的无线AP设备来实现）</p><p>强调一下，家用无线路由器是集成了WiFi、路由、交换三种功能的设备。在企业网络中，一般都是由专门的设备独立负责的（不使用家用无线路由器是出于性能考虑）</p></blockquote><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/1f6b213e66604a8bc5c32.png" alt="图2——企业网络架构"></p><h1 id="网络信息"><a href="#网络信息" class="headerlink" title="网络信息"></a>网络信息</h1><p>本章介绍网络通信时所需要的信息，平时会折腾一下电脑或手机网络可能都会看到这些</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/65bfc6defc73214dd2cca.png" alt="图3——计算机网络信息"></p><p>其中我们需要注意的 MAC地址（物理地址）、IP地址（一般指IPv4地址）、网关、DHCP、DNS。</p><blockquote><p>MAC地址是网卡的身份证——每个网络设备上至少有一块网卡，mac地址就是用来标识网卡的，严格来讲mac并不叫“地址”。</p><p>IP地址为门牌号——用来标识网络设备在网络中的具体位置</p><p>网关为小区门卫——管理一个网络的进出口链路，一般可以理解成网关就是路由器</p><p>DHCP是随机摇号机制——为网络设备分配ip地址</p><p>DNS是业主住址薄——用来查找一个网站域名对应的ip地址是多少</p></blockquote><p>图中网关、DHCP服务器、DNS服务器为同一个，是因为我用的电脑连接手机的热点。</p><p>DNS设置为网关，相当于使用网关的网络信息中的DNS服务器。（笔记本：我用什么DNS都依手机，跟他一样）</p><h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>端口这个说法不够具体，物理接口就叫做端口，比如交换机端口，墙面端口等等</p><p>这里要介绍的是抽象概念上的虚拟端口，在计算机中，其范围从0~65535，</p><p>你电脑上运行了很多联网的程序，他们都在使用网络资源，但他们都互不干扰。</p><p>具体一点就是你与很多qq好友同时在线聊天，你接收到A好友发来的消息并不会跑错到B好友的聊天窗口中。</p><p>这是因为在你的电脑上虚拟了很多个端口，应用进程使用其中一个端口与对方通信，就不会跟其他的冲突了。</p><p>打开系统的资源监视器就可以直观的看到了，注意看我只运行了一个qq（PID为12344），但它已经使用了很多个端口在与不同的远端电脑通信。</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/1c0515d4c9db8294d58f8.png" alt="图4——计算机进程端口映射表"></p><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>协议就是规则、规范，或者说一种语言。</p><p>因为计算机网络中传播的数据只有0和1，为此就需要协议来定义出各种编码解码方式（类似摩斯密码）</p><p>以及定义得到的各种参数代表什么含义。（类似缩写与黑话）</p><p>计算机通信中存在着许多的协议，这里按五层模型来展示的话，一共有这么多协议。</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/c69fcfccbbc0493af63b9.png" alt="图5——分层网络协议"></p><p>目前只需要知道有协议这个概念就行，以后会具体一个个协议的学习</p><h4 id="网络参考模型"><a href="#网络参考模型" class="headerlink" title="网络参考模型"></a>网络参考模型</h4><p>七层模型是ISO组织于1984年发布的细化的网络层级，更多的作用是让你理解网络通信这个抽象的东西，同时让厂商基于这个层级去标准化规范化的设置与遵循协议。</p><p>故障排查时也可以按照七层模型来逐级排查。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">应用层:OSI参考模型中最靠近用户的一层,为应用程序提供网络服务。</span><br><span class="line"></span><br><span class="line">表示层:提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。</span><br><span class="line"></span><br><span class="line">会话层:负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。</span><br><span class="line"></span><br><span class="line">传输层:提供面向连接或非面向连接的数据传递以及进行重传前的差错检测。</span><br><span class="line"></span><br><span class="line">网络层:定义逻辑地址,供路由器确定路径,负责将数据从源网络传输到目的网络。</span><br><span class="line"></span><br><span class="line">数据链路层:将比特组合成字节,再将字节组合成帧,使用链路层地址(以太网使用MAC地址)来访问介质,并进行差错检测。</span><br><span class="line"></span><br><span class="line">物理层:在设备之间传输比特流,规定了电平、速度和电缆针脚等物理特性。</span><br></pre></td></tr></table></figure><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/34123c5a32b053223662b.png" alt="图6——分层传输过程"></p><p>而TCP&#x2F;IP四层&#x2F;五层模型可以说是对OSI七层模型的简化。将最上的5、6、7层简化为一层。</p><p>具体内容感兴趣可自行查阅资料，<strong>目前五层模型更被广泛接受。</strong></p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/b442b24545d26f20f99b6.png" alt="图7——两种分层协议对比"></p><p>目前只需要知道<strong>二层是基于mac地址进行数据传输，三层是基于ip地址传输。</strong></p><p>因此在电脑之间的网络传播都是处于前3层上的。</p><p>路由器都是三层设备，而交换机会有二层交换机与三层交换机之分，一般个人接触到交换机都是二层交换机。</p><blockquote><p>介绍以上信息都是为了接下来介绍的数据包的传输做基础。</p></blockquote><h4 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h4><p>我们都知道计算机的底层是由0和1构成的，我们看到的图片、音频、视频在计算机底层都是一串串数字。</p><p>网络通信时传输的就是这些字符串。</p><p>在实际传输时，会把这些字符串拆解打包，封装，成为一个个数据包，有些地方会叫做报文（严格来讲，有包、段、帧的区分，但日常都统称为包）</p><p>一个数据包的结构可以简化为</p><p><strong>【目标地址】【源地址】【协议类型】【数据内容】【校验码】</strong></p><blockquote><p>具体可以百度搜索一下各数据报文结构。此处不是很严谨，不同分层下的数据包结构是不一样的，这里只是一个形象的简化概括。</p></blockquote><p>类比一下</p><table><thead><tr><th></th><th>含义</th><th>类比</th></tr></thead><tbody><tr><td><strong>目标地址</strong></td><td>数据包要送达的目的地</td><td>快递的收件人</td></tr><tr><td><strong>源地址</strong></td><td>数据包的发送来源</td><td>快递的寄件人</td></tr><tr><td><strong>协议类型</strong></td><td>该数据包遵循什么协议、使用什么协议解读</td><td>走哪一家物流公司的渠道</td></tr><tr><td><strong>数据内容</strong></td><td>真正要传输的数据</td><td>快递包裹内的东西</td></tr><tr><td><strong>检验码</strong></td><td>通过固定的算法计算出的数据包相关内容的值<br />如果设备收到该数据包后计算的出的值与该检验码不同<br />则说明该数据包损坏了，于是会丢弃该数据包<br />（也就是常说的“丢包”）</td><td>快递的包装、如果包装破损、物品缺失、会拒收</td></tr></tbody></table><h1 id="数据包的传输过程"><a href="#数据包的传输过程" class="headerlink" title="数据包的传输过程"></a>数据包的传输过程</h1><h2 id="交换阶段"><a href="#交换阶段" class="headerlink" title="交换阶段"></a>交换阶段</h2><p>不知道各位在学校上电脑课时，在老师还没开通“上网”功能前，有没有偷偷跟同学联机打几把cs。</p><p>多台电脑在没连通互联网时是如何联机打游戏的呢？ 应该有人会说出一个词——“局域网”。</p><p>局域网就是一个小型网络，在学校机房这个地方，其局域网可以简化为这样。</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/5b2b3d360339a99117c90.png" alt="图8——拓扑"></p><blockquote><p>交换机SW2开启DHCP功能，1号口连接SW1的4号口。MAC地址为：4c-1f-cc-25-2c-49</p><p>交换机SW1的1、2、3号口分别连接PC1、PC2、PC3。MAC地址为：54-89-98-b6-57-ab</p><p>PC1自动获取到的ip地址为192.168.10.251，MAC地址为：54-89-98-B6-57-AB</p><p>PC2自动获取到的ip地址为192.168.10.252，MAC地址为：54-89-98-32-67-F6</p><p>PC3自动获取到的ip地址为192.168.10.253，MAC地址为：54-89-98-A8-22-35</p></blockquote><h3 id="交换机的mac地址映射表"><a href="#交换机的mac地址映射表" class="headerlink" title="交换机的mac地址映射表"></a>交换机的mac地址映射表</h3><p>假设主机之间都知道彼此的mac地址，那么通讯就是基于二层，由二层交换机处理即可。</p><p>交换收到一个标注了mac地址的数据包，他要如何发送给对应的电脑呢？</p><p>这就要介绍交换机的两大特性：学习、泛洪（广播）</p><p>举例PC1指定发送给PC2，同时目前交换机是刚连入该网络中</p><blockquote><p>学习：交换机从1号接口收到一个数据包——数据包是会注明源地址与目标地址（发件人与收件人）</p><p><strong>交换机查看到数据包的源地址，就会记录下这个源地址就是来自这个端口</strong>（PC1来自1号口）</p></blockquote><blockquote><p>泛洪：<strong>交换机发现未曾记录过目的地址</strong>（PC2的mac），<strong>交换机就会进行广播</strong>，将该数据包同时从2、3、4口发送出去，当PC2收到并回复时，交换机便会学习记录下来（PC2在2口）</p><p>注：其余pc虽然收到了PC1发给PC2的数据包，但他们看到数据包开头的目标地址不是自己的mac地址，于是不会理会回应这个数据包</p></blockquote><p>以下是在模拟器中查询交换机SW1的mac地址对应表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;SW1&gt;dis mac-address</span><br><span class="line">MAC address table of slot 0:</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">MAC Address    VLAN/       PEVLAN CEVLAN Port            Type      LSP/LSR-ID  </span><br><span class="line">               VSI/SI                                              MAC-Tunnel  </span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">5489-98b6-57ab 10          -      -      Eth0/0/1        dynamic   0/-         </span><br><span class="line">5489-9832-67f6 10          -      -      Eth0/0/2        dynamic   0/-         </span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Total matching items on slot 0 displayed = 2</span><br></pre></td></tr></table></figure><p>基于学习与广播两种方式，一个普通的交换机就能完成一个简单的局域网通讯。</p><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>上面是在主机已知对方mac地址的情况下实现的（主机发送数据包时，填写了收件人）</p><p>目前我们记录与使用的都是ip地址，很少会去专门记mac地址。</p><blockquote><p>插播一条知识：即便是一个网站名，比如<a href="http://www.baidu.com,它其实也是一个ip地址,dns就是负责将网站名翻译为ip地址/">www.baidu.com，它其实也是一个ip地址，DNS就是负责将网站名翻译为ip地址</a></p></blockquote><p>那么在知道ip地址，不知道mac地址时，又是如何完成通信的呢。</p><p>首先，<strong>电脑会判断要访问的目标ip与自身是不是处于同一个子网</strong>（有关子网，稍后会介绍）</p><p><strong>若不同子网，电脑会将数据包的目标mac填写为网关的mac地址，使该数据包发送给网关，由网关去寻找目标ip</strong></p><p><strong>若同一子网，电脑会将额外发送一个ARP数据包</strong>，该数据包的目标mac填写为ffffffffffff，也就是广播。<strong>通过ARP获取了目标主机的mac地址后，才开始发送数据包。</strong></p><p>这里我抓了个包，是在PC1与PC2都没有对方mac信息是，由PC1去访问PC2的ip地址。</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/81fe6f52ea7bc0c80b266.png" alt="图9——抓包信息"></p><p>其中，第二行这段就是二层的信息，其注明了源地址为54:89:98:b6:57:ab 目标地址为ff:ff:ff:ff:ff:ff。以及该数据包的类型为ARP</p><p>交换机只识别到二层信息，发现目标地址是广播地址（全F），于是转发给所有主机。</p><blockquote><p>Ethernet II, Src: HuaweiTe_b6:57:ab (54:89:98:b6:57:ab), Dst: Broadcast (ff:ff:ff:ff:ff:ff)</p><p>Type: ARP (0x0806)</p></blockquote><p>下面这段摘抄一下，也是记录了源mac与IP地址，以及目标ma与IPc地址</p><blockquote><p>Address Resolution Protocol (request)<br>    Sender MAC address: HuaweiTe_b6:57:ab (54:89:98:b6:57:ab)<br>    Sender IP address: 192.168.10.251<br>    Target MAC address: Broadcast (ff:ff:ff:ff:ff:ff)   注意实际中此处为00:00:00:00:00，模拟器bug才显示的全f<br>    Target IP address: 192.168.10.252</p></blockquote><p>PC2收到这个数据包后，解析内容知道这是一个ARP数据包，并且数据内容中含有自己的IP地址（192.168.10.252）。</p><p>于是遵循协议，它会回复一个数据包。</p><p>该数据包，自然就写上了PC2自身的mac地址，PC1收到这个数据包，也就清楚了192.168.10.252对应54:89:98:32:67:f6</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/9334b3568d41a1e9627a2.png" alt="图10——抓包2"></p><p>我们也可以验证一下，在PC1的命令行中查看ARP表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PC&gt;arp -a</span><br><span class="line"></span><br><span class="line">Internet Address    Physical Address    Type</span><br><span class="line">192.168.10.252      54-89-98-32-67-F6   dynamic</span><br></pre></td></tr></table></figure><p>等拿到了mac地址，PC1与PC2的通信就简单了。</p><h2 id="路由阶段"><a href="#路由阶段" class="headerlink" title="路由阶段"></a>路由阶段</h2><p>前面我们介绍了交换过程，会发现<strong>交换过程有一个小问题，那就是广播包太多</strong>：交换机泛洪，ARP泛洪。</p><blockquote><p><strong>提一下，交换机的泛洪是由它自身发起的，是交换机本身不知道数据包中的目的mac地址在哪</strong></p><p><strong>ARP泛洪是要进行通讯的网络设备引起的，是为了要填写目的mac地址，需要知道目的设备的mac地址是多少。</strong></p></blockquote><p>网络中设备越多，这些<strong>广播包数量就越多，这样就会占用太多网络资源，导致“网络变卡”</strong></p><p>为此需要限制一下广播域，这就需要两项技术：<strong>路由与子网</strong></p><p>先简单说明路由的作用，路由作用在不同的网络之间，提供类似交换机一样的服务，但路由有一个最重要的作用，<strong>隔绝广播域</strong>。</p><p>网络内部，或者说局域网内部的广播数据包到达路由设备，路由设备不会将其扩散到其他局域网。</p><p>还记得我们看网络信息有ip地址、子网掩码与网关吗，包括我们手动修改ip地址时，也会让你填写。</p><p>网关就是路由设备的ip地址：<strong>如果要与其他网段通信的话，每个网段必定需要一个网关</strong></p><p>（不与其他网段的设备通讯的话，可不填写网关）</p><p>什么叫网段呢，网络号不相同的ip地址就是处于不同的网段，网段就是ip地址与子网掩码进行与运算后得到的网络地址。</p><p>因此我们先介绍子网的概念</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/7fe940190b93f6df4f8e2.png" alt="图11——计算机ip信息"></p><h3 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h3><p>我们可以看到ip地址、子网掩码每行都是由四段组成的，实际是4个字节，也就是4个8位二进制。例如</p><p>00000000  00000000  00000000  00000000 表示的是0.0.0.0</p><p>11111111  11111111  11111111  11111111 表示的是255.255.255.255</p><p>二进制十进制的转换就不介绍了，百度一下就有。（现在记住，一个8位的二进制全为1时，就是255）</p><p><strong>IP地址，是由网络号加主机号构成的</strong>，也就是小区地址与门牌号。</p><p><strong>子网掩码，是用来标识到哪一段都是网络号</strong>。</p><p>其规则为<strong>将标识网络号的部位写为1</strong>，主机号的部分写为0。</p><p>例如我们常见的</p><blockquote><p>ip地址：192.168.1.2</p><p>子网掩码：255.255.255.0</p></blockquote><p>255明显就是整个字节8位二进制都为1，也就是前面3个字节都表示的网段。</p><p>所以192.168.1 这一段为网络号，后面的.2为主机号。</p><p>其网段就是192.168.1.0</p><p>好吧，你可能感觉不好理解是吧。（其实这才是最好记得）</p><p>那么我们按照原理来算一遍</p><p>网络号的计算就是使用ip地址与子网掩码，进行二进制的与运算：有0则为0，都是1的才保留。</p><p>按原理来，写出来就如下表格：</p><table><thead><tr><th>类型\值</th><th>第一字节</th><th>第二字节</th><th>第三字节</th><th>第四字节</th></tr></thead><tbody><tr><td>十进制ip地址</td><td>192</td><td>168</td><td>1</td><td>2</td></tr><tr><td>十进制子网掩码</td><td>255</td><td>255</td><td>255</td><td>0</td></tr><tr><td>二进制ip地址</td><td>11000000</td><td>10101000</td><td>00000001</td><td>00000010</td></tr><tr><td>二进制子网掩码</td><td>11111111</td><td>11111111</td><td>11111111</td><td>00000000</td></tr><tr><td>进行“与”运算后的二进制</td><td>11000000</td><td>10101000</td><td>00000001</td><td>00000000</td></tr><tr><td>运算后的十进制（网络号）</td><td>192</td><td>168</td><td>1</td><td>0</td></tr></tbody></table><p>正因为“与”这种运算，有0则为0，都是1才1。</p><p>而子网掩码标记网络号的地方都标记为1，则我们算子网掩码前面有多少个1，去取ip地址前面多少个数就是网络号了。</p><p>根本不需要进行计算。</p><p>早期，子网分为三大类</p><table><thead><tr><th>类别</th><th>子网掩码</th></tr></thead><tbody><tr><td>A类</td><td>255.0.0.0</td></tr><tr><td>B类</td><td>255.255.0.0</td></tr><tr><td>C类</td><td>255.255.255.0</td></tr></tbody></table><p>这很方便我们理解，因为它们是以一整个字节来划分的。</p><h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><p>但在实际中，C类包括的主机号也达到了253个（255-1-1，一个二进制全0表示网段，一个二进制全1表示广播地址）</p><p>出于节省ip地址与<strong>进一步隔绝广播域</strong>的目的，后来人们将子网进一步划分。</p><p>原网段：</p><table><thead><tr><th>点分十进制</th><th>二进制</th></tr></thead><tbody><tr><td>IP地址：192.168.1.0</td><td>11000000  10101000  00000001  00000000</td></tr><tr><td>子网掩码：255.255.255.0</td><td>11111111  11111111  11111111  00000000</td></tr></tbody></table><p>比如规划给某一层楼的ip网段是192.168.1.0，255.255.255.0</p><p>假设这层楼有4个办公区，要按办公区划分子网，也就是分出4个子网来。</p><p>要表示4，需要至少两个二进制数，（00、01、10、11）。</p><p>而子网掩码对于网络号的定义是从左往右的，也就是我们要将原来二进制下的子网掩码多往右数两个数，写为1，用来标记这里也是表示网络号。</p><p>那子网掩码就为11111111  11111111  11111111  11000000 也就是255.255.255.192</p><p>划分后的的网段：</p><table><thead><tr><th>二进制</th><th>点分十进制</th><th>主机可分配的ip地址范围</th></tr></thead><tbody><tr><td><strong>11000000  10101000  00000001  <em>00</em></strong>000000</td><td>192.168.1.0</td><td>192.168.1.1~192.168.1.62</td></tr><tr><td><strong>11000000  10101000  00000001  <em>01</em></strong>000000</td><td>192.168.1.64</td><td>192.168.1.65~192.168.1.126</td></tr><tr><td><strong>11000000  10101000  00000001  <em>10</em></strong>000000</td><td>192.168.1.128</td><td>192.168.1.129~192.168.1.190</td></tr><tr><td><strong>11000000  10101000  00000001  <em>11</em></strong>000000</td><td>192.168.1.192</td><td>192.168.1.193~192.168.1.254</td></tr></tbody></table><blockquote><p>注意，虽然划分了不同网段，但对于外部网络来说，这四个子网区域依旧还是192.168.1.0，255.255.255.0这一个网段。</p><p>打个比喻，就是对于外面的人来说，我们一家人都住在101号房，但是我们家里每个人分别住在主卧、次卧、客卧。</p></blockquote><h4 id="子网掩码的简写"><a href="#子网掩码的简写" class="headerlink" title="子网掩码的简写"></a>子网掩码的简写</h4><p>子网掩码的书写总是要敲4段，而且有时不是很快理解。</p><p>所以我们会把子网掩码进行缩写，以二进制写法中，有多少个数值全为1，也就是说以网络号有多少位来简写</p><blockquote><p>192.168.1.2    255.255.255.0     可以简写为192.168.1.2    &#x2F;24</p><p>192.168.1.64  255.255.255.192 可以简写为192.168.1.64 &#x2F;26</p></blockquote><p>(当然，实际历史发展不是这样的，还是得强调本文旨在通俗易懂的理解计算机网络的基础概念，具体的学习更推荐另外看正统书籍)</p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>上面已经理解了网段的概念，接下来理解路由就很轻松了</p><p>路由就是指示去往其他网段的道路，是导航。</p><p>过程：</p><blockquote><p>当我们电脑要发送数据时，电脑会识别目标ip地址是不是同网段：</p><p>同网段，则不需要路由参与，按照交换过程传输数据包（无mac先ARP，拿到mac了直接通过mac发送数据包）</p><p>不同网段，则会在数据包的目标mac地址位置填写网关的mac地址（一样的，如果不知道网关的mac地址，就ARP寻找）</p></blockquote><blockquote><p>网关收到给自己的数据包，发现虽然mac’地址是自己，但ip地址不是自己的，网关就会根据路由信息去转发这个数据包。</p></blockquote><p> 所以把路由设备叫做网关很好理解，跟海关差不多。</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/bc8ded095962c0e282284.png" alt="图12——物流过程"></p><blockquote><p>1、电脑发送数据包</p><p>2、链路传输</p><p>3、交换机转发</p><p>4、路由设备寻址转发</p><p>5、路由设备之间的传输</p><p>6、目标网段的路由设备</p><p>7、8、目标网段内的交换</p><p>9、到达目标设备</p></blockquote><h4 id="路由原理"><a href="#路由原理" class="headerlink" title="路由原理"></a>路由原理</h4><p>路由设备与交换机可以说原理大同小异。</p><p>路由设备内部也是维护这一个数据表格，叫做路由表。</p><p>我在模拟器上搭了个简单的网络拓扑</p><p><img src="https://c4893f9d.telegraph-image-713.pages.dev/file/97888e3a3d7e245c3dc40.png" alt="图13——拓扑2"></p><blockquote><p>图片内容描述:</p><p>三台专业路由器AR1、AR2、AR3连接在一起，它们底下各自连着一台PC</p><p>注：<strong>专业级路由器。IP地址是配置在接口上的</strong>，所以一台设备拥有多个IP地址</p><p>RI与PC处于10.0.0.0 &#x2F;24网段，R1与R2处于12.0.0.0 &#x2F;24网段</p><p>R2与PC处于20.0.0.0 &#x2F;24网段，R2与R3处于23.0.0.0 &#x2F;24网段</p><p>R3与PC处于30.0.0.0 &#x2F;24网段。</p></blockquote><p>为设备配置好网段与IP地址后，我们来查看R1的路由表（我将本地回环与广播地址相关的删除了）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[R1]dis ip routing-table</span><br><span class="line">Route Flags: R - relay, D - download to fib</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Routing Tables: Public</span><br><span class="line"></span><br><span class="line">Destination/Mask    ProtoPreCostFlags NextHop         Interface</span><br><span class="line"></span><br><span class="line">10.0.0.0/24Direct00D   10.0.0.254      GigabitEthernet0/0/0</span><br><span class="line">12.0.0.0/24Direct00D   12.0.0.1        GigabitEthernet0/0/1</span><br></pre></td></tr></table></figure><p>我们需要注意的就是目标网段与下一跳(NextHop)</p><p>上述R1路由表的意思就是，前往10.0.0.0&#x2F;24网段，从10.0.0.254这个ip所在位置出发；前往12.0.0.0&#x2F;24网段，从12.0.0.1这个ip所在位置出发。</p><p>那么我们是不是可以从PC1通讯到路由器R2了呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PC&gt;ping 12.0.0.2</span><br><span class="line"></span><br><span class="line">Ping 12.0.0.2: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">Request timeout!</span><br></pre></td></tr></table></figure><p>很遗憾，还不行，让我们来排查一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PC&gt;ping 12.0.0.1</span><br><span class="line"></span><br><span class="line">Ping 12.0.0.1: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">From 12.0.0.1: bytes=32 seq=1 ttl=255 time=16 ms</span><br></pre></td></tr></table></figure><p>PC1到R1是通的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;R1&gt;ping 12.0.0.2</span><br><span class="line">  PING 12.0.0.2: 56  data bytes, press CTRL_C to break</span><br><span class="line">    Reply from 12.0.0.2: bytes=56 Sequence=1 ttl=255 time=10 ms</span><br></pre></td></tr></table></figure><p>R1到R2竟然也是通的？！而R1并没有故障。</p><hr><p>好，不卖关子，这是因为<strong>通信是双向的</strong>，虽然PC1可以联系到R2，但是目前R2联系不到PC1，所以他们就不互通，ping就会失败</p><p>这是R2的路由表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;R2&gt;dis ip routing-table</span><br><span class="line">Route Flags: R - relay, D - download to fib</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Routing Tables: Public   </span><br><span class="line"></span><br><span class="line">Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</span><br><span class="line"></span><br><span class="line">       12.0.0.0/24  Direct  0    0           D   12.0.0.2        GigabitEthernet0/0/1</span><br><span class="line">       20.0.0.0/24  Direct  0    0           D   20.0.0.254      GigabitEthernet0/0/0</span><br><span class="line">       23.0.0.0/24  Direct  0    0           D   23.0.0.2        GigabitEthernet0/0/2</span><br></pre></td></tr></table></figure><p>其中并没有前往10.0.0.0&#x2F;24的路由信息，手动添加一条静态路由信息进去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[R2]dis ip routing-table </span><br><span class="line">Route Flags: R - relay, D - download to fib</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Routing Tables: Public</span><br><span class="line"></span><br><span class="line">Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</span><br><span class="line"></span><br><span class="line">       10.0.0.0/24  Static  60   0          RD   12.0.0.1        GigabitEthernet0/0/1</span><br><span class="line">       12.0.0.0/24  Direct  0    0           D   12.0.0.2        GigabitEthernet0/0/1</span><br><span class="line">       20.0.0.0/24  Direct  0    0           D   20.0.0.254      GigabitEthernet0/0/0</span><br><span class="line">       23.0.0.0/24  Direct  0    0           D   23.0.0.2        GigabitEthernet0/0/2</span><br></pre></td></tr></table></figure><p>这时，PC1再去pingR2就通了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PC&gt;ping 12.0.0.2</span><br><span class="line"></span><br><span class="line">Ping 12.0.0.2: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">From 12.0.0.2: bytes=32 seq=1 ttl=254 time=16 ms</span><br></pre></td></tr></table></figure><hr><p>延申一下，既然PC1能ping通R2了。那么能ping通PC2吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PC&gt;ping 20.0.0.2</span><br><span class="line"></span><br><span class="line">Ping 20.0.0.2: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">Request timeout!</span><br><span class="line">Request timeout!</span><br></pre></td></tr></table></figure><p>是的不行，这是因为R1中没有前往20.0.0.0&#x2F;24网段的路由信息。</p><p>只要在R1配上对应的静态路由，PC1就能与PC2通信了。</p><p>包括后续与R3、PC3，因为都不是同一个网段，需要有对应的路由信息才能通信。</p><blockquote><p>有关路由的详细介绍，请看<a href="https://magiku.github.io/2024/06/04/%E3%80%90%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80%E3%80%91%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E3%80%81RIP%E5%8D%8F%E8%AE%AE/">路由基础</a>这篇文章。</p></blockquote><hr><h4 id="隔绝广播域的原理"><a href="#隔绝广播域的原理" class="headerlink" title="隔绝广播域的原理"></a>隔绝广播域的原理</h4><p>至于说路由设备为什么能隔离广播域</p><p>是因为在路由表中指定了广播地址（二进制全1，也就是255），的下一跳是127.0.0.1，也就是路由器本身，所以广播包不会转发出去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</span><br><span class="line">127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实理解了交换与路由的过程，就已经知道了计算机网络的全部通信过程。</p><p>其他的技术与知识都是在交换路由的基础上进行功能的丰富</p><p>到这里，我建议再回头从文章开始的位置再通读一遍，能更深刻的理解计算机网络中数据的传播过程。</p><h1 id="知识拓展"><a href="#知识拓展" class="headerlink" title="知识拓展"></a>知识拓展</h1><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>DNS（Domain Name System，域名系统），其作用是解析域名，将域名转换成ip地址。</p><p>早期，互联网都是直接使用ip地址通信，但对于人类来说，记忆ip地址还是太困难了。</p><p>于是出现了域名，访问百度，我们使用只需要记baidu.com，这非常方便好记。</p><p>而DNS就是对应的用来翻译域名的工具。</p><p>DNS服务器上有一个庞大的数据库，里面就记录域名对应了什么IP地址。</p><p>电脑访问一个域名时，会先访问DNS服务器，获取域名的IP地址，之后再根据IP地址去通信。</p><p>一些人可以听说过，“换一个DNS，网络就会好一些”</p><p>这有两个原因，一个是你与DNS服务器之间的访问速度；另一个则是DNS服务器翻译给你的ip地址不是最佳地址</p><p>多数情况都是第一个原因。</p><p>至于第二个原因，是因为大型网站，其搭配的运营商不止几个，服务器不止一台，甚至机房不止一处。</p><p>也就是说会有多个ip地址，虽然网站内容都是一样的，但是访问它们的速度自然会有差异。</p><p>另外，如果是电脑正常能够上网，但某个网站或者联网程序就是有网络问题，这就有可能是你使用的DNS服务器有问题——其数据库中没有解析出正确可用的ip地址。（只是说有可能，不是一定）</p><h4 id="hosts文件"><a href="#hosts文件" class="headerlink" title="hosts文件"></a>hosts文件</h4><p>如果是Windows与Linux系统，电脑本地会有一个hosts文件，其中也储存着域名与ip地址的映射信息（其实是先有hosts文件，后出现DNS技术的）</p><p>电脑访问一个域名时，会先查询hosts文件，有信息直接访问该IP；没有的再去请求DNS。</p><p>根据这个原理，我们可以玩个骚操作</p><p>在hosts文件中，添加一个常见的广告与流氓域名，将ip地址填写为127.0.0.1</p><p>这样电脑访问这些域名，就直接请求到本地地址去了，相当于自定义了黑名单。</p><blockquote><p>实际是先查询DNS缓存，没有再去找hosts文件，hosts文件也没有，才去找DNS。</p><p>但对于开机之后还没有去访问过的网站，那肯定没有相应的DNS缓存，会直接先去找hosts文件。</p></blockquote><h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>Network Address Translation，网络地址转换。</p><p>其诞生是因为IPv4地址即将分配完毕，由于成本问题与政治问题，众多国家不愿意迁移至IPv6。</p><p>美国于1994年开发推出了NAT技术，用于解决IPv4不够使用的问题。</p><p>其原理非常简单，就是将原来的局域网划为私网，不与互联网直接互通，而是在路由器上使用NAT技术，将私网的ip地址转化为一个公网ip地址。</p><p>使得原本需要几十个、几百个公网ip地址的区域，只需要配备一个公网ip地址就可以了。（你可以理解为变相的对一个公网地址进行子网划分）</p><p>目前使用的NAT技术，具体来说是NAT-PT（ Protocol Translator），是利用端口来进行地址转换。</p><p>在路由器内部有一张端口映射表，记录了路由器的什么虚拟端口对应什么私网内的ip地址（对应哪一台主机）。</p><p>路由器向公网通信就通过分配给自己的公网ip地址加上端口号。</p><p>NAT这个技术好处除开解决了IPv4不够用的问题之外，就是隔绝了公网与私网。</p><p>我们无法直接访问私网内的某一台设备，需要由对方先通信才行。（因为该设备未在路由器内建立映射，或者建立了，但你并不知道其对应哪一个端口）</p><p>这变相的保证了私网的安全：私网内的网络设备，不会被直接定向攻击。</p><p>但这个好处同时也是一个坏处。</p><p>私网内的网络设备不直接连通在公网上。很明显我们不能直接将随便一台网络设备作为服务器，其他人或者是你在其他地方无法直接访问到这台设备。</p><p>如果你家里的电脑有公网IP，那你在公司可以直接远程访问，可以作为你的云电脑，甚至你可以使用手机来远程，使手机拥有电脑的性能。</p><p><del>如果你的手机有公网IP，那你可以在家里，就远程放在公司的手机，直接打卡！</del></p><p><del>当然，现在有很多方案可以实现，比如：内网穿透。</del></p><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>IPv6虽然使用上与IPv4一样，但<strong>IPv6不是IPv4的升级，而是一个全新的协议，与IPv4不兼容</strong>。</p><p>早期人们发现计算机发展拓展速度很快，甚至出现了移动智能设备（手机），IPv4可预见的不够使用，于是提出了IPv6。</p><p>IPv6的二进制位数是IPv4的4倍（32*4&#x3D;128），虽然第一眼看只是4倍，但这是二进制位数</p><p>换算一下总数量为2<sup>128</sup>&#x3D;340282366920938463463374607431768211456。而IPv4是4294967296。</p><p>IPv6因为与IPv4不兼容，所以想替换为IPv6，需要客户端、服务在程序上替换为IPv6，还需要路由设备也同时替换为IPv6。</p><p>因此出于成本问题这项技术很难推广开来，而且后续出现的NAT技术，解决了地址分配问题，这使得许多国家与机构放弃了IPv6。</p><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>防火墙的作用是自定义隔绝网络请求，阻断特定的网络通讯。</p><p>防火墙分软件防火墙与硬件防火墙。</p><p>软件</p><blockquote><p>我们的个人电脑就有防火墙（Windows防火墙或者你安装的杀毒软件携带的防火墙）</p><p>路由设备上也有防火墙</p></blockquote><p>硬件</p><blockquote><p>专门的防火墙设备，常与路由器串联在一起</p></blockquote><p>一般只有大企业才使用硬件的防火墙设备。</p><p>举几个防火墙的实际作用</p><p>限制办公设备访问常见的娱乐域名（不知道各位公司有没有设置过，会让你登不了游戏跟游戏平台）</p><p>限制个别办公设备访问公司服务器</p><p>限制互联网设备访问内网设备的特定端口（例如3389，这是Windows远程桌面的默认端口）</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>有关IPv4、IPv6、NAT、DNS的技术背景与政治背景，我推荐看看这个视频 <a href="https://www.bilibili.com/video/BV1i14y157YV">电子监听、全国断网，棱镜门背后，中国如何从末路狂奔到世界之巅</a></p><p>这个视频做的非常好，我考虑之后摘抄记录一下。</p><p>看过以上知识后，相信你对计算机网络已经有了个大概了理解。</p><p>如果对计算机网络感兴趣，推荐去学习一下HCIA的知识，一套课程大概一个月就可以学习完毕。</p><p>之后还有兴趣再学习HCIP知识，到这我个人认为就足够了，已经覆盖了目前大多数的实际网络情况。</p><p>另外这个阶段去看看经典教材书籍也不错，尤其是TCP&#x2F;IP相关的书籍。</p><p>本文说是讲究”实际“”实践“，但其实还是以理论为主。</p><p>下一篇！下一篇就真正的以”实践“为主。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 科普 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
